<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>解析RDD算子（分组）</title>
      <link href="/2022/05/16/%E8%A7%A3%E6%9E%90RDD%E7%AE%97%E5%AD%90%EF%BC%88%E5%88%86%E7%BB%84%E7%AF%87%EF%BC%89/"/>
      <url>/2022/05/16/%E8%A7%A3%E6%9E%90RDD%E7%AE%97%E5%AD%90%EF%BC%88%E5%88%86%E7%BB%84%E7%AF%87%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="RDD常见转换算子解析"><a href="#RDD常见转换算子解析" class="headerlink" title="RDD常见转换算子解析"></a>RDD常见转换算子解析</h1><h3 id="1-groupBy和groupBykey"><a href="#1-groupBy和groupBykey" class="headerlink" title="1.groupBy和groupBykey"></a>1.groupBy和groupBykey</h3><p>根据指定的条件进行分组 </p><p>属性 或 逻辑运算</p><p>groupBy</p><p>返回分组后的RDD。每个组由一个键和一系列映射到该键的元素组成。不能保证每组中元素的顺序，甚至可能在每次评估结果RDD时有所不同。</p><pre class="line-numbers language-scala"><code class="language-scala">    <span class="token keyword">val</span> conf<span class="token operator">:</span> SparkConf <span class="token operator">=</span> <span class="token keyword">new</span> SparkConf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setMaster<span class="token punctuation">(</span><span class="token string">"local[*]"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setAppName<span class="token punctuation">(</span><span class="token string">"Control3"</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> SparkContext<span class="token punctuation">(</span>conf<span class="token punctuation">)</span>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token string">"spark"</span><span class="token punctuation">,</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token string">"spark"</span><span class="token punctuation">,</span><span class="token string">"scala"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    rdd<span class="token punctuation">.</span>groupBy<span class="token punctuation">(</span>x<span class="token keyword">=></span>x<span class="token punctuation">)</span><span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 结果为</span><span class="token comment" spellcheck="true">//(spark,CompactBuffer(spark, spark))</span><span class="token comment" spellcheck="true">//(scala,CompactBuffer(scala))</span><span class="token comment" spellcheck="true">//(hello,CompactBuffer(hello, hello))</span>            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>groupBykey 适合处理k-v类型的数据</p>]]></content>
      
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongoDB的安装和部署</title>
      <link href="/2022/05/11/mongoDB%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%83%A8%E7%BD%B2/"/>
      <url>/2022/05/11/mongoDB%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB数据库安装及配置环境"><a href="#MongoDB数据库安装及配置环境" class="headerlink" title="MongoDB数据库安装及配置环境"></a><a href="https://so.csdn.net/so/search?q=MongoDB&spm=1001.2101.3001.7020">MongoDB</a>数据库安装及配置环境</h1><h2 id="一-MongoDB的下载与安装"><a href="#一-MongoDB的下载与安装" class="headerlink" title="一. MongoDB的下载与安装"></a>一. MongoDB的下载与安装</h2><h2 id="windows端"><a href="#windows端" class="headerlink" title="windows端"></a>windows端</h2><h3 id="1-1-下载地址"><a href="#1-1-下载地址" class="headerlink" title="1.1 下载地址"></a>1.1 下载地址</h3><p><a href="https://www.mongodb.com/download-center/community?jmp=docs">https://www.mongodb.com/download-center/community?jmp=docs</a></p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220512172251154.png"></p><p>MongoDB 有两个服务器版本：<em>社区</em>版和 <em>企业版</em>。</p><h4 id="若想选择其他版本-可点击-Current-releases-amp-packages-自行下载"><a href="#若想选择其他版本-可点击-Current-releases-amp-packages-自行下载" class="headerlink" title="若想选择其他版本 可点击  Current releases &amp; packages 自行下载"></a>若想选择其他版本 可点击  Current releases &amp; packages 自行下载</h4><h4 id="打开-MongoDB-Shell-下载页面。"><a href="#打开-MongoDB-Shell-下载页面。" class="headerlink" title="打开 MongoDB Shell 下载页面。"></a>打开 MongoDB Shell 下载页面。</h4><h4 id="下载mongosh适用于您的操作系统的安装存档。"><a href="#下载mongosh适用于您的操作系统的安装存档。" class="headerlink" title="下载mongosh适用于您的操作系统的安装存档。"></a>下载<code>mongosh</code>适用于您的操作系统的安装存档。</h4><p>安装 “install mongoDB compass” 勾选（当然你也可以选择安装它，可能需要更久的安装时间），MongoDB Compass 是一个图形界面管理工具</p><h4 id="从下载的存档中提取文件"><a href="#从下载的存档中提取文件" class="headerlink" title="从下载的存档中提取文件"></a>从下载的存档中提取文件</h4><h4 id="将mongosh二进制文件添加到您的PATH环境变量中"><a href="#将mongosh二进制文件添加到您的PATH环境变量中" class="headerlink" title="将mongosh二进制文件添加到您的PATH环境变量中"></a>将<code>mongosh</code>二进制文件添加到您的<code>PATH</code>环境变量中</h4><p>确保提取的MongoDB Shell二进制文件位于文件系统中的所需位置，然后将该位置添加到<code>PATH</code> 环境变量中。</p><p>要将MongoDB Shell二进制文件的位置添加到您的 <code>PATH</code>环境变量中：</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511202542447.png"></p><h2 id="二、连接到远程服务器"><a href="#二、连接到远程服务器" class="headerlink" title="二、连接到远程服务器"></a>二、连接到远程服务器</h2><p>要使用MongoDB Shell ，您必须具有要连接的 MongoDB 部署。</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511203240401.png"></p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511203412464.png"></p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511203520850.png"></p><p>托管在云服务上可能要花费3-5min</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511203714885.png"></p><p>可以选择托管在云平台上  但只有512M的集群  如果要更多的存储空间 则要付费</p><p>默认情况下，MongoDB Atlas集群不需要能够启动与您的应用程序环境的连接。如果您希望启用具有 <a href="https://www.mongodb.com/docs/atlas/security-ldaps/#std-label-ldaps-authentication-authorization">LDAP 身份验证和授权</a>的Atlas集群，您必须允许从Atlas集群直接访问您的安全LDAP的网络访问。只要公共DNS主机名指向Atlas集群可以访问的 IP，您就可以允许使用公共或私有 IP 访问您的LDAP 。</p><p>简单来说就是通过ip来访问云服务</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511205759816.png"></p><p>连接说明中点第一个 然后就可以通过mongoDB compass连接上</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511205900562.png"></p><p>然后你会发现有三个集群节点可用 这也体现了分布式的特点</p><p>打开cmd</p><p>查看版本:mongod –version </p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511205950224.png"></p><p>进入shell :mongo, 默认端口为27017</p><p>mongod –dbpath 任意路径 默认就在根目录data下</p><p><strong>DataGrip</strong> 是JetBrains公司开发的数据库管理客户端工具 支持多种数据库连接 </p><p>特别棒的功能就是代码的智能提示 简直不要太好  可自行前往官网下载 </p><p>点击 new -&gt; data source mongodb 然后复制原本在compass上的url 点击test </p><p>如果没问题的话就可以连接上了</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511211000869.png"></p><p>show dbs</p><p>这两个数据库都是系统自带的，不建议更改，可以自己创个数据库 然后添加数据，这里就不做过多说明。</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511211206249.png"></p><p>到此为止，win端的mongodb的安装已经顺利成功</p><h2 id="Linux端的安装和数据迁移"><a href="#Linux端的安装和数据迁移" class="headerlink" title="Linux端的安装和数据迁移"></a>Linux端的安装和数据迁移</h2><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/100.png"></p><p>选择centos7版本的进行解压安装</p><p>1.新建文件夹 mkdir &#x2F;data  mkdir -p &#x2F;data&#x2F;db </p><p>2.解压:tar -zxvf xx -C   &#x2F;data</p><p>配置环境变量</p><pre class="line-numbers language-js"><code class="language-js">vim <span class="token operator">/</span>etc<span class="token operator">/</span>profile<span class="token comment" spellcheck="true">//拉到最下方</span><span class="token keyword">export</span> MONGODB_HOME <span class="token operator">=</span><span class="token operator">/</span>data<span class="token operator">/</span>mongodb<span class="token operator">/</span>bin<span class="token keyword">export</span> $PATH<span class="token punctuation">:</span>$MONGODB_HOME<span class="token operator">/</span>bin<span class="token comment" spellcheck="true">//更新环境变量</span>source <span class="token operator">/</span>etc<span class="token operator">/</span>profile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入mongo 直接报错 可以看见版本号但是 进不去mongo shell</p><p>报错信息如下：</p><p>Error: couldn’t connect to server 127.0.0.1:27017, connection attempt failed: SocketException: Error connecting to 127.0.0.1:27017 :: caused by :: Connection refused :</p><p>这时候我们将一台主机当做服务端  另一台当做客户端     通过客户端连接上服务端这样就可以正常访问   这里的本地模式并不是连接到windows上的本地  是linux的本地</p><p>bin&#x2F;mongod</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/101.png"></p><p>在另外一台输入</p><p>mongo </p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/102.png"></p><p>连接成功！ </p><p>当然在linux也可以连接之前在云端部署的MONGDB集群  具体操作如下</p><p>我们在官网登入自己的账户 点击command Line Tools</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/104.png"></p><p>点进去 然后选择 i have the MongoDB shell installed</p><p>然后复制一段代码 将mongosh 改为 mongo即可</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/105.png"></p><p>出现以下代码则说明连接成功</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/106.png"></p><p><strong>Q:第二次连接远程的时候连接不上 我们登入官网</strong> </p><p>点击NetWork Access 选择edit 将里面的连接方式改成运行任何地方的连接</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/107.png"></p><h3 id="如何导入数据"><a href="#如何导入数据" class="headerlink" title="如何导入数据"></a>如何导入数据</h3><p>首先要确保有mongorestore命令 如果没有的话则需要去官网下载工具包</p><p>mongodb-database-tools-rhel70-x86_64-100.5.2</p><p>解压到当前的bin目录下</p><p>mongorestore 如果可以Tab出来就代表没什么问题</p><p>mongorestore dump </p><p>即可导入成功</p><p>我们再重新登入客户端 </p><p>show dbs 就可以看见导入的数据库了 </p>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>scala指导手册</title>
      <link href="/2022/05/06/scala%E6%8C%87%E5%AF%BC%E6%89%8B%E5%86%8C/"/>
      <url>/2022/05/06/scala%E6%8C%87%E5%AF%BC%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="scala"><a href="#scala" class="headerlink" title="scala"></a>scala</h1><p>Scala combines <strong>object-oriented</strong> and <strong>functional programming</strong> in one concise, high-level language. Scala’s static types help avoid bugs in complex applications, and its JVM and JavaScript runtimes let you build high-performance systems with easy access to huge ecosystems of libraries.</p><p>(Scala将面向对象编程和函数式编程结合在一种简洁的高级语言中。Scala的静态类型有助于避免复杂应用程序中的错误，它的JVM和JavaScript运行时让您可以构建高性能系统，轻松访问庞大的库生态系统。)</p><ol><li>Scala embraces a fusion of functional programming (FP) and object-oriented programming (OOP)</li><li>Scala is statically typed, but often feels like a dynamically typed language</li><li>Scala’s syntax is concise(简洁), but still readable; it’s often referred to as <em>expressive</em></li><li><em>Implicits</em> in Scala 2 were a defining feature, and they have been improved and simplified（simply 简化） in Scala 3</li><li>Scala integrates(集成) seamlessly with Java, so you can create projects with mixed Scala and Java code, and Scala code easily uses the thousands of existing Java libraries </li><li>Scala can be used on the server, and also in the browser with <a href="https://www.scala-js.org/">Scala.js</a></li><li>The Scala standard library has dozens of pre-built, functional methods to save you time, and greatly reduce the need to write custom <code>for</code> loops and algorithms</li><li>“Best practices” are built into Scala, which favors immutability, anonymous functions, higher-order functions, pattern matching, classes that cannot be extended by default, and more</li><li>The Scala ecosystem offers the most modern FP libraries in the world</li><li>Strong type system</li></ol><h2 id="1-VARIABLES-AND-DATA-TYPES"><a href="#1-VARIABLES-AND-DATA-TYPES" class="headerlink" title="1.VARIABLES AND DATA TYPES"></a>1.VARIABLES AND DATA TYPES</h2><p>AnyVal(值类型)    </p><p>AnyRef(引用类型)</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/20200905165023396.png"></p><p>根类型 Any ，他是所有类的父类。</p><p>Class Any is the root of the Scala class hierarchy. Every class in a Scala execution environment inherits directly or indirectly from this class.</p><p>Starting with Scala 2.10 it is possible to directly extend Any using universal traits. A universal trait is a trait that extends Any, only has defs as members, and does no initialization.</p><p>scala 中一切皆为对象，分为两大类 AnyVal(值类型)， AnyRef(引用类型)， 他们都是 Any 子类</p><p>Null 类型是 scala 的特别类型，它只有一个值 null, 他是 bottom calss ,是 所有 AnyRef 类型的子类<br>Nothing 类型也是 bottom class ,他是所有类的子类，在开发中通常可以将 Nothing 类型的值返回给任意变量或者函数， 这里抛出异常使用很多</p><h3 id="Unit-类型、Null-类型和-Nothing-类型"><a href="#Unit-类型、Null-类型和-Nothing-类型" class="headerlink" title="Unit 类型、Null 类型和 Nothing 类型"></a>Unit 类型、Null 类型和 Nothing 类型</h3><p>1）Null 类只有一个实例对象，null，类似于 Java 中的 null 引用。null 可以赋值给任意引用类型(AnyRef)，但是不能赋值给值类型(AnyVal: 比如 Int, Float, Char, Boolean, Long, Double, Byte, Short)</p><p>2）Unit 类型用来标识过程，也就是没有明确返回值的函数。由此可见，Unit 类似于 Java 里的 void，Unit 只有一个实例。</p><p>3）Nothing，可以作为没有正常返回值的方法的返回类型，非常直观的告诉你这个方法不会正常返回，而且由于 Nothing 是其他任意类型的子类，他还能跟要求返回值的方法兼容。</p><h2 id="val-and-var-variables"><a href="#val-and-var-variables" class="headerlink" title="val and var variables:"></a>val and var variables:</h2><p>&#x2F;&#x2F;immutable</p><p>val a &#x3D; 10</p><p>&#x2F;&#x2F;mutable </p><p>var b &#x3D; 2</p><h2 id="Declaring-variable-types"><a href="#Declaring-variable-types" class="headerlink" title="Declaring variable types"></a>Declaring variable types</h2><p>val x :Int &#x3D; 10;</p><p>val p &#x3D; 10; </p><p>You can always explicitly declare a variable’s type if you prefer, but in simple assignments like these it isn’t necessary:</p><p><strong>val</strong> x: <strong>Int</strong> &#x3D; 1 </p><p><strong>val</strong> s: <strong>String</strong> &#x3D; “a string”</p><p><strong>val</strong> p: <strong>Person</strong> &#x3D; <strong>Person</strong>(“Richard”)</p><h2 id="CONTROL-STRUCTURES"><a href="#CONTROL-STRUCTURES" class="headerlink" title="CONTROL STRUCTURES"></a>CONTROL STRUCTURES</h2><p>Scala has the control structures you find in other programming languages, and also has powerful <code>for</code> expressions and <code>match</code> expressions:,it seems like java, but there have some differents  in  syntax  so that’s we begin!</p><ul><li><code>if</code>&#x2F;<code>else</code></li><li><code>for</code> loops and expressifoons</li><li><code>match</code> expressions</li><li><code>while</code> loops</li><li><code>try</code>&#x2F;<code>catch</code></li></ul><h3 id="if-x2F-else"><a href="#if-x2F-else" class="headerlink" title="if&#x2F;else"></a><code>if</code>&#x2F;<code>else</code></h3><pre><code>if(a&gt;10) print(a) //It can only be written in one sentence</code></pre><p>or like this :</p><pre class="line-numbers language-scala"><code class="language-scala"><span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">></span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{</span>print<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="for-loops-and-expressions"><a href="#for-loops-and-expressions" class="headerlink" title="for loops and expressions"></a>for loops and expressions</h2><p><strong>val</strong> ints &#x3D; <strong>List</strong>(1, 2, 3, 4, 5)</p><p> <strong>for</strong>( i &lt;- ints)  println(i)</p><p>for(i&lt;- 1 to&#x2F;until 10) {</p><p>}</p><p> for (i &lt;- 1 to 10 if i % 2 &#x3D;&#x3D; 1) { </p><p>​     println(i)    </p><p>}</p><p>For each iteration of your for loop, yield generates a value which will be remembered. It’s like the for loop has a buffer you can’t see, and for each iteration of your for loop, another item is added to that buffer. When your for loop finishes running, it will return this collection of all the yielded values. The type of the collection that is returned is the same type that you were iterating over, so a Map yields a Map, a List yields a List, and so on.</p><pre><code>val values:IndexedSeq[Int] = for(i&lt;- 1 to 10 )  yield i*2val list = List(1,2,3,4,5)val arr:Array[Int] = Array(1,2,3,5)val list_01:List[Int] = for(i&lt;-list) yield i*2val arr_01:Array[Int] = for (i&lt;-arr) yield i*2println(values)println(list_01)arr_01.foreach(println)</code></pre><h1 id="3-object-oriented"><a href="#3-object-oriented" class="headerlink" title="3.object-oriented"></a>3.object-oriented</h1><h1 id="4-Functions-and-methods"><a href="#4-Functions-and-methods" class="headerlink" title="4.Functions and methods"></a>4.Functions and methods</h1><h1 id="5-Interface-API"><a href="#5-Interface-API" class="headerlink" title="5.Interface API"></a>5.Interface API</h1><h1 id="6-option"><a href="#6-option" class="headerlink" title="6.option"></a>6.option</h1><h1 id="7-source"><a href="#7-source" class="headerlink" title="7.source"></a>7.source</h1><h1 id="8-Use-of-higher-order-functions"><a href="#8-Use-of-higher-order-functions" class="headerlink" title="8. Use of higher-order functions"></a>8. Use of higher-order functions</h1><h1 id="9-Implicit-conversion"><a href="#9-Implicit-conversion" class="headerlink" title="9. Implicit conversion"></a>9. Implicit conversion</h1><h1 id="10-Generics"><a href="#10-Generics" class="headerlink" title="10. Generics"></a>10. Generics</h1><h1 id="11-Collection"><a href="#11-Collection" class="headerlink" title="11.Collection"></a>11.Collection</h1><p>refresh ……..</p>]]></content>
      
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集(set)和映射(Map)</title>
      <link href="/2022/04/25/%E9%9B%86set%E5%92%8C%E6%98%A0%E5%B0%84Map/"/>
      <url>/2022/04/25/%E9%9B%86set%E5%92%8C%E6%98%A0%E5%B0%84Map/</url>
      
        <content type="html"><![CDATA[<p>默认情况下 你使用的set or map 都是不可变的对象   如果可变需要提前声明</p><p>以下是创建可变的集合</p><pre class="line-numbers language-scala"><code class="language-scala"><span class="token keyword">package</span> com<span class="token punctuation">.</span>heima<span class="token punctuation">.</span>arrp<span class="token keyword">import</span> scala<span class="token punctuation">.</span>collection<span class="token punctuation">.</span>mutable<span class="token comment" spellcheck="true">/** * @author lyc * @date 2022/4/25 11:30   * @version V1.0.0 */</span><span class="token keyword">object</span> Map_prc <span class="token punctuation">{</span>  <span class="token keyword">def</span> map<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> map01 <span class="token operator">=</span> mutable<span class="token punctuation">.</span>Map<span class="token punctuation">(</span><span class="token string">"aa"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> set01 <span class="token operator">=</span> mutable<span class="token punctuation">.</span>Set<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="set集合的基本使用"><a href="#set集合的基本使用" class="headerlink" title="set集合的基本使用"></a>set集合的基本使用</h2><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220425113431055.png"></p><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h3><ol><li><code>var 变量=Set()</code> （创建空的Set集合）</li><li><code>var 变量=Set[类型]()</code>  &#x2F;&#x2F;写死后里面的元素只能是set规定的数据类型</li></ol><p>scala内部能简化的全部帮你简化了</p><h3 id="2-差集和补集"><a href="#2-差集和补集" class="headerlink" title="2.差集和补集"></a>2.差集和补集</h3><ol><li>&amp;返回两个集合的交集</li><li>&amp;~返回两个集合的差集</li><li>++合并两个集合</li><li>diff比较两个集合的差集</li></ol><h3 id="3-遍历"><a href="#3-遍历" class="headerlink" title="3.遍历"></a>3.遍历</h3><ul><li>通过for（i &lt;- x )</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis概述</title>
      <link href="/2022/04/15/redis%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/04/15/redis%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Redis是用C语言开发的一个开源的高性能基于内存运行的键值对NoSQL数据库</p><p>Redis（Remote Dictionary Server 远程字段服务）是一个开源的使用ANSI C语言编写、支持网络、科技与<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>亦可持久化的日志型、key-value数据库，并提供多种语言的API。</p><p>(1) 支持数据的持久化，可以将数据保存在磁盘中，重启之后可以再次加载到内存中使用<br>(2) 支持多种数据类型，除了KV类型的数据，还支持list、set、<a href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a>等数据结构<br>(3) 支持master-slave模式的数据备份</p><h2 id="二、Redis应用场景"><a href="#二、Redis应用场景" class="headerlink" title="二、Redis应用场景"></a>二、Redis应用场景</h2><ol><li>热点数据加速查询(主要场景)，如热点商品、热点信息等访问量较高的数据</li><li>即时信息查询，如公交到站信息、在线人数信息等</li><li>时效性信息控制，如验证码控制、投票控制等</li><li>分布式数据共享，如分布式集群架构中的session分离消息队列</li></ol><h3 id="1-NoSQL技术"><a href="#1-NoSQL技术" class="headerlink" title="1.NoSQL技术"></a>1.NoSQL技术</h3><p>为了克服上述问题，java web项目通常会引入NoSQL技术，这是一种基于内存的数据库，并且提供一定的持久化功能。</p><p>Redis和MongoDB是当前使用最广泛的NoSQL， 而就Redis技术而言，它的性能十分优越，可以支持每秒十几万的读写操作，其性能远超数据库，并且还支持集群、。分布式、主从同步等配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还支持一定的事务能力，这保证了高并发的场景下数据的安全和一致性。</p><h3 id="2-高并发和快速原因"><a href="#2-高并发和快速原因" class="headerlink" title="2.高并发和快速原因"></a>2.高并发和快速原因</h3><p>Redis是基于内存的，内存的读写速度非常快；<br>Redis是单线程的，省去了很多上下文切换线程的时间；<br>Redis使用多路复用技术，可以处理并发的连接。非IO内部实现采用epoll，采用了epoll自己实现的简单的事件框架。epoll的读写、关闭、连接都转化为事件，然后利用epoll的多路复用特性，绝不在IO上浪费一点时间。</p><h3 id="3-单线程的优劣势"><a href="#3-单线程的优劣势" class="headerlink" title="3.单线程的优劣势"></a>3.单线程的优劣势</h3><p>1、优势</p><p>代码更清晰，处理逻辑更简单</p><p>不用考虑各种锁的问题，不存在加锁和释放锁的操作，没有因为可能出现死锁而导致的性能消耗</p><p>不存在多线程切换而消耗CPU</p><p>2、劣势</p><p>无法发挥多核CPU性能优势，不过可以通过单击开多个Redis实例来完善。</p><h3 id="4-Redis高并发总结"><a href="#4-Redis高并发总结" class="headerlink" title="4.Redis高并发总结"></a>4.Redis高并发总结</h3><p>1、Redis是纯内存数据库，一般都是简单存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快；</p><p>2、Redis使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成事件，减少了线程切换时上下文切换和竞争。</p><p>3、Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。</p><p>4、Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如跳表，使用有序的数据结构加快读写的速度。</p><p>5、Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</p><h2 id="三、Redis基础知识"><a href="#三、Redis基础知识" class="headerlink" title="三、Redis基础知识"></a>三、Redis基础知识</h2><p>Redis采用单线程机制进行工作</p><p>Redis默认拥有16个数据库，数据库编号从0开始，默认使用0号数据库</p><p>使用select 数据库编号 可以切换使用的数据库</p><p>dbsize 命令查看当前数据库key的数量</p><p>keys * 命令查看当前数据库所有的key</p><p>flushdb 命令清空当前数据库</p><p>flushall 命令清空所有数据库</p><p>Redis中所有数据库使用同一个密码，默认没有密码，Redis认为安全层面应该由Linux来保证</p><p>Redis中所有索引都是从0开始</p><p>Redis默认端口是6379</p>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文数</title>
      <link href="/2022/04/10/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
      <url>/2022/04/10/%E5%9B%9E%E6%96%87%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>例如，121 是回文，而 123 不是。</p><pre><code>输入：x = 121输出：true</code></pre><pre><code>输入：x = -121输出：false解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</code></pre><p>解法一：</p><p>利用StringBuffer </p><p>思路 ： 负数肯定不是回文数 直接返回false </p><p>创建 StringBuff对象 进行比较 </p><p>通过String.valueof 方法 转成一个字符串进行 比较 </p><pre class="line-numbers language-java"><code class="language-java">     <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        StringBuffer s<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解法二：<br>数学（推荐）</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>num<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            cur <span class="token operator">=</span> cur<span class="token operator">*</span><span class="token number">10</span> <span class="token operator">+</span>num<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>            num <span class="token operator">/=</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cur<span class="token operator">==</span>x<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scala的伴生对象</title>
      <link href="/2022/04/06/scala%E7%9A%84%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1/"/>
      <url>/2022/04/06/scala%E7%9A%84%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h1><p>​    一个class和object具有同样的名字。这个object称为<strong>伴生对象</strong>，这个class称为<strong>伴生类</strong></p><ul><li>伴生对象必须要和伴生类一样的名字；</li><li>伴生对象和伴生类在同一个scala源文件中；</li><li>伴生对象和伴生类可以互相访问<strong>private</strong>属性。</li></ul><p>作用 ：让伴生类更好访问到伴生对象的私有属性和方法</p><p>一旦私有 main方法直接不能调  严格的权限控制</p><h2 id="1-单例对象-object"><a href="#1-单例对象-object" class="headerlink" title="1.单例对象(object)"></a>1.单例对象(object)</h2><p>scala中是没有static关键字的，要想定义类似于Java中的static变量、static方法，就要使用到scala中的单例对象了, 也就是object。</p><h2 id="2-定义单例对象"><a href="#2-定义单例对象" class="headerlink" title="2.定义单例对象"></a>2.定义单例对象</h2><p>object 单例对象名{ } &#x2F;&#x2F; 定义一个单例对象 也可以解释为什么main方法是静态的了</p><p>网上说的什么伴生对像之间可以互相访问跟情侣一样同生死 只有伴生类能够访问伴生对象中的私有属性和对象  我尝试了 一下 明明只有类可以访问到 对象访问不到类的东西。</p><p>但后来慢慢发现我放了一个错误</p><p>伴生对象不实例化类的对象，怎么访问伴生类中定义的私有属性？不实例化 伴生对象是类的一个傀儡</p><p>就是必须要在伴生对象的中定义个方法去实例化它</p><h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><p>class Person{</p><p>}</p><p> var op ：person &#x3D;  new Person（）实例化后才能调用</p><p>但我们一般都是在main方法中实例化的 （java的思维） 真的sorry</p><h2 id="3-案例1-2-3"><a href="#3-案例1-2-3" class="headerlink" title="3.案例1 2 3"></a>3.案例1 2 3</h2><p>ps：可以试着运行下</p><p>可以尝试着把伴生对象理解 成用static 修饰的类</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>atiguigu<span class="token punctuation">.</span>prc<span class="token comment" spellcheck="true">/** * @author lyc * @date 2022/4/10 20:50   * @version V1.0.0 */</span>object Logger <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//单例对象 不能带参数 不能实例化 没有机会向单例对象传参</span>  <span class="token comment" spellcheck="true">//在第一次调用的时候进行 初始化</span>  <span class="token comment" spellcheck="true">//静态方法 一加上private就没办法访问了</span>    def <span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token operator">:</span>String<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token string">"info:$msg"</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>  def <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span><span class="token punctuation">{</span>    Logger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"林杰"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//为什么要有 object定义main方法 因为static 被scala完全给隔绝了</span><span class="token comment" spellcheck="true">//scala是高度化的面向对象语言 不允许静态和非静态属性和方法 糅杂在一起 所以就用一个</span><span class="token comment" spellcheck="true">//object 单例对象</span><span class="token comment" spellcheck="true">//程序入口</span>object LoggerTest<span class="token punctuation">{</span>  def <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span>String<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span>    Logger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"林杰1"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//类名.方法名</span>    val obj <span class="token operator">:</span>Test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    obj<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>atiguigu<span class="token punctuation">.</span>prc<span class="token comment" spellcheck="true">/** * @author lyc * @date 2022/4/10 20:56   * @version V1.0.0 */</span><span class="token keyword">class</span> <span class="token class-name">AccountInfo</span> <span class="token punctuation">{</span>  var id <span class="token operator">=</span><span class="token number">0</span>  id <span class="token operator">=</span> AccountInfo<span class="token punctuation">.</span><span class="token function">newUniqueNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//之间的特点 互相访问对方的私有属性和方法</span><span class="token comment" spellcheck="true">//称为类的伴生对象</span>object AccountInfo<span class="token punctuation">{</span>  <span class="token keyword">private</span> var last_num <span class="token operator">=</span><span class="token number">0</span>  <span class="token keyword">private</span>  def <span class="token function">newUniqueNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">{</span>    last_num <span class="token operator">+=</span><span class="token number">2</span>    last_num  <span class="token punctuation">}</span><span class="token punctuation">}</span>object  compannionTest<span class="token punctuation">{</span>  def <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span>String<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span>    var obj <span class="token operator">:</span>AccountInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AccountInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>id<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>atiguigu<span class="token punctuation">.</span>prc<span class="token comment" spellcheck="true">/** * @author lyc * @date 2022/4/10 21:15   * @version V1.0.0 */</span><span class="token comment" spellcheck="true">//类自带无参的构造器 开发者把这些觉得重复的东西全部省略了</span><span class="token comment" spellcheck="true">//set get 底层封装起来了</span><span class="token comment" spellcheck="true">// 有参构造函数 直接 给class（）java中是不允许的！！</span><span class="token comment" spellcheck="true">//scala中的构造器 有两种</span><span class="token comment" spellcheck="true">// 主构造函数 和 辅助构造函数</span><span class="token comment" spellcheck="true">// 记住一点 辅助构造函数是在 类中的  定义必须以this开头 以下是具体例子</span><span class="token comment" spellcheck="true">// 调用辅助构造函数 根据传参来区分是第几个辅助构造函数</span>object Constructorc <span class="token punctuation">{</span>  def <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span>String<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span>    val obj <span class="token operator">:</span>Const <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Const</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>    var obj1 <span class="token operator">:</span>Confuse <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Confuse</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>a<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Const</span><span class="token punctuation">{</span>  var a <span class="token operator">=</span> <span class="token number">10</span>  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1调用无参的构造函数"</span><span class="token punctuation">)</span>  <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  def <span class="token keyword">this</span><span class="token punctuation">(</span>a1<span class="token operator">:</span>Int<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//调用主构造函数 必须的一步！！！</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2调用有参的构造函数"</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a1  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//有参的构造函数</span><span class="token comment" spellcheck="true">//如果用 var就是放在类里面的一个属性 不带则为参数 注意一下</span><span class="token comment" spellcheck="true">//class Confuse{</span><span class="token comment" spellcheck="true">// int a</span><span class="token keyword">class</span> <span class="token class-name">Confuse</span><span class="token punctuation">(</span>a <span class="token operator">:</span>Int<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2022/04/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/04/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><pre><code>输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4</code></pre><pre class="line-numbers language-java"><code class="language-java">   <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span><span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// // 当left==right，区间[left, right]依然有效，所以用 &lt;=</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left<span class="token operator">+</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 防止溢出 等同于(left + right)/2</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//target 在左区间，所以[left, mid - 1]</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>                left <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// target 在右区间，所以[mid + 1, right]</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//数组中找到目标值，直接返回下标</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组去重</title>
      <link href="/2022/04/05/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
      <url>/2022/04/05/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<p>数组去重也是比经典的一个算法 这里演示了三种不同的数组去重操作</p><p>1.利用Hashset本身无序的特性进行去重</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test04</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span>arr<span class="token punctuation">)</span><span class="token punctuation">{</span>            set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.利用ArrayList进行去重</p><pre><code>    public void remove() &#123;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        int[] arr = &#123;1, 2, 3, 4, 5, 6, 2, 3, 4&#125;;        for (int i :arr)&#123;            if (!list.contains(i))&#123;                list.add(i);            &#125;        &#125;        System.out.println(list);    &#125;&#125;</code></pre><p>3.双重for循环</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> Arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>x<span class="token operator">&lt;</span>temp<span class="token punctuation">.</span>length<span class="token punctuation">;</span>x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">boolean</span> flag<span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> y<span class="token operator">=</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>y<span class="token operator">&lt;</span>temp<span class="token punctuation">.</span>length<span class="token punctuation">;</span>y<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">==</span>temp<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    flag<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span>               Arr<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>temp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除LinkedList中的重复项</title>
      <link href="/2022/04/02/%E5%88%A0%E9%99%A4LinkedList%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/2022/04/02/%E5%88%A0%E9%99%A4LinkedList%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="CHARACTER"><a href="#CHARACTER" class="headerlink" title="CHARACTER"></a>CHARACTER</h1><p>Q:LinkedList 去除重复元素</p><p>阿牛最近在学习 <code>LinkedList</code> 的知识，现在他想要测试一下自己究竟学会了多少，他成功的发现了自己并没有掌握相关知识点，现在需要你帮助他完成这道题目，给定六个字符串，将这些字符串存放在 <code>LinkedList</code> 中，然后将 <code>LinkedList</code> 中重复的元素删除，最后将 <code>LinkedList</code> 中所有元素用迭代器方式打印在标准输出流（控制台）中，请你帮助她完成这道题目。</p><p>挺简单的一道题 代码如下 </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Iterator<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>LinkedList<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//解法一</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Permanent</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> LinkedList<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">Weighting</span><span class="token punctuation">(</span>LinkedList<span class="token operator">&lt;</span>String<span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LinkedList<span class="token operator">&lt;</span>String<span class="token operator">></span>linkedList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> iterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            String str <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>linkedList<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                linkedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> linkedList<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//解法二</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Permanent</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> LinkedList<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">Weighting</span><span class="token punctuation">(</span>LinkedList<span class="token operator">&lt;</span>String<span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            HashSet set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Iterator iter <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                String str <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    iter<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> list<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala中的Map集合</title>
      <link href="/2022/03/31/Scala%E4%B8%AD%E7%9A%84Map%E9%9B%86%E5%90%88/"/>
      <url>/2022/03/31/Scala%E4%B8%AD%E7%9A%84Map%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="不可变MAP"><a href="#不可变MAP" class="headerlink" title="不可变MAP"></a>不可变MAP</h1><p>Map(映射)是一种可迭代的键值对（key&#x2F;value）结构。<br>所有的值都可以通过键来获取。<br>Map 中的键都是唯一的。<br>Map 也叫哈希表（Hash tables）。<br>Map 有两种类型，可变与不可变，区别在于可变对象可以修改它，而不可变对象不可以。<br>默认情况下 Scala 使用不可变 Map。如果你需要使用可变集合，你需要显式的引入 import scala.collection.mutable.Map 类<br>在Scala中你可以同时使用可变与不可变 Map,不可变的直接使用 Map,可变的使用 mutable.Map.以下实例演示了不可变 Map 的应用：</p><pre class="line-numbers language-java"><code class="language-java">def <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span>String<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span> val p<span class="token operator">:</span> Map<span class="token punctuation">[</span>String<span class="token punctuation">,</span> Int<span class="token punctuation">]</span> <span class="token operator">=</span> Map<span class="token punctuation">[</span>String<span class="token punctuation">,</span> Int<span class="token punctuation">]</span><span class="token punctuation">(</span>   <span class="token string">"CK"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">15</span><span class="token punctuation">,</span>   <span class="token string">"PH"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">25</span><span class="token punctuation">,</span>   <span class="token string">"PW"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">35</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两种获取值的方式</p><pre class="line-numbers language-java"><code class="language-java">   val values<span class="token operator">:</span> Option<span class="token punctuation">[</span>Int<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"PH"</span><span class="token punctuation">)</span>   <span class="token function">println</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span>get<span class="token punctuation">)</span>          val age <span class="token operator">:</span>Int  <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span><span class="token string">"PW"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">println</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span>         <span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>keys<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//返回所有的key;</span>  <span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>values<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//返回所有的value;</span>  <span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>isEmpty<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//当map为空时,返回true;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="可变MAP"><a href="#可变MAP" class="headerlink" title="可变MAP"></a>可变MAP</h1><p>​    </p><pre><code>  def main(args: Array[String]): Unit = &#123;    val personalMap  = scala.collection.mutable.Map[String,Int](      &quot;kw&quot; -&gt;7,      &quot;dk&quot;-&gt;20    )    for(kb&lt;-personalMap)&#123;      val key =kb._1;      val value = kb._2      println(key+value)    &#125;    personalMap.foreach(x=&gt;println(x))  &#125;</code></pre><pre class="line-numbers language-java"><code class="language-java">def <span class="token function">map3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//不可变Map+var关键词修饰例子</span>  var a<span class="token operator">:</span>scala<span class="token punctuation">.</span>collection<span class="token punctuation">.</span>mutable<span class="token punctuation">.</span>Map<span class="token punctuation">[</span>String<span class="token punctuation">,</span>Int<span class="token punctuation">]</span><span class="token operator">=</span>scala<span class="token punctuation">.</span>collection<span class="token punctuation">.</span>mutable<span class="token punctuation">.</span><span class="token function">Map</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"k2"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//初始化构造函数</span>  a <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token string">"k3"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//添加元素</span>  a <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token string">"k4"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//添加元素</span>  a <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">100</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//已经存在添加元素会覆盖</span>  a <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">100</span><span class="token punctuation">,</span><span class="token string">"k9"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">9</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//添加多个元素</span>  a <span class="token operator">-=</span> <span class="token punctuation">(</span><span class="token string">"k2"</span><span class="token punctuation">,</span><span class="token string">"k1"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//删除元素</span>  a <span class="token operator">++</span><span class="token operator">=</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token string">"CA"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token string">"CO"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//追加集合</span>  a <span class="token operator">--</span><span class="token operator">=</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token string">"AL"</span><span class="token punctuation">,</span> <span class="token string">"AZ"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//删除集合</span>   a<span class="token punctuation">.</span><span class="token function">retain</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> k<span class="token operator">==</span><span class="token string">"k1"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//只保留等于k1元素，其他的删除</span>  a<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"put1"</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//put</span>  a<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"k2"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//remove</span>  a<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//清空</span>  <span class="token function">a</span><span class="token punctuation">(</span><span class="token string">"k3"</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">100</span><span class="token comment" spellcheck="true">//支持</span>   <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"k6"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//是否包含某元素</span>  <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//打印大小</span>  <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//根据key读取元素，不存在就替换成默认值</span>  a<span class="token punctuation">.</span>foreach<span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span>i<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//遍历打印1</span>  <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>k<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">-</span>a <span class="token punctuation">)</span> <span class="token function">println</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>v<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//遍历打印2</span>  <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>isEmpty<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//判断是否为空</span>  a<span class="token punctuation">.</span>keys<span class="token punctuation">.</span><span class="token function">foreach</span><span class="token punctuation">(</span>println<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//只打印key</span>  a<span class="token punctuation">.</span>values<span class="token punctuation">.</span><span class="token function">foreach</span><span class="token punctuation">(</span>println<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//只打印value</span>  a<span class="token operator">=</span>scala<span class="token punctuation">.</span>collection<span class="token punctuation">.</span>mutable<span class="token punctuation">.</span><span class="token function">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//引用能变</span>  <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>size<span class="token punctuation">)</span>  a<span class="token punctuation">.</span>toSeq<span class="token punctuation">.</span><span class="token function">sortBy</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>_1<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//排序 key</span>  a<span class="token punctuation">.</span>toSeq<span class="token punctuation">.</span><span class="token function">sortBy</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>_2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//排序 value</span>  a<span class="token punctuation">.</span>toSeq<span class="token punctuation">.</span><span class="token function">sortWith</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>_1<span class="token operator">></span>_<span class="token punctuation">.</span>_1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//降序排序 key</span>  a<span class="token punctuation">.</span>toSeq<span class="token punctuation">.</span><span class="token function">sortWith</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>_2<span class="token operator">></span>_<span class="token punctuation">.</span>_2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//降序排序 value</span>        <span class="token comment" spellcheck="true">//下面自定义按英文字母或数字排序</span>  implicit  val KeyOrdering<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Ordering</span><span class="token punctuation">[</span>String<span class="token punctuation">]</span> <span class="token punctuation">{</span>    override def <span class="token function">compare</span><span class="token punctuation">(</span>x<span class="token operator">:</span> String<span class="token punctuation">,</span> y<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token punctuation">{</span>      x<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>toSeq<span class="token punctuation">.</span>sorted<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于StringBuider的使用</title>
      <link href="/2022/03/30/%E5%85%B3%E4%BA%8EStringBuider%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/03/30/%E5%85%B3%E4%BA%8EStringBuider%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="String与StringBuilder的区别"><a href="#String与StringBuilder的区别" class="headerlink" title="String与StringBuilder的区别"></a>String与StringBuilder的区别</h1><h2 id="1-String"><a href="#1-String" class="headerlink" title="1.String"></a>1.String</h2><p>String类位于Java的lang包下 无需导包即可调用</p><p>String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间</p><p>每创建一个String对象就要在栈中 开辟空间 当修改String的值的时候 会在堆中新开辟一块空间 造成空间的浪费</p><h4 id="用String类创建对象通常有两种形式："><a href="#用String类创建对象通常有两种形式：" class="headerlink" title="用String类创建对象通常有两种形式："></a>用String类创建对象通常有两种形式：</h4><p>1、String str &#x3D; “abc”</p><p>2、String str1 &#x3D; new String(“abc”);</p><p>方法1：通过字面量直接给字符串进行赋值，在栈中创建字符串str时，会先在字符串常量池中检查是否已有该字符串，如果没有则创建并存入字符串常量池中，如果已存在则直接从常量池中获取。</p><p>方法2：创建的字符串，不管内存有没有为“abc”字符串分配内存，都会在内存中重新分配一个内存区域存放“abc”，然后用str1指向它，相当于内存中有两个“abc”，只是存放的地址不一样。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>1、public String();</p><p>String类的无参构造方法，用来创建空字符串的String类；</p><p>案例：String str &#x3D; new String();</p><p>2、public String(String value);</p><p>用已知的字符串value值来创建一个字符串对象；</p><p>案例：String str1 &#x3D; new String(“aaa”);</p><p>3、public String(char[] value)</p><p>用字符数组value创建一个String对象。</p><p>案例：char[] value &#x3D; {“ab”,”cd”,”efg”};</p><h2 id="2-StringBuffer"><a href="#2-StringBuffer" class="headerlink" title="2. StringBuffer"></a>2. StringBuffer</h2><p> StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量 </p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/20180411092328691"></p><p><img src="C:\Users\lyc\AppData\Roaming\Typora\typora-user-images\image-20220330183450896.png"></p><p>我们调用equals方法  显而易见结果是false</p><p>一些常用的方法 看参数 你应该就知道如何使用  无非就是增删改查 类型转换 多练即可掌握</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220330183812261.png"></p><p> (1) String中的是常量(final)数组，只能被赋值一次。<br>   比如：new String(“abc”)使得value[]&#x3D;{‘a’,’b’,’c’}(查看jdk String 就是这么实现的)，之后这个String对象中的value[]再也不能改变了。这也正是大家常说的，String是不可变的原因 。<br>   注意：这个对初学者来说有个误区，有人说String str1&#x3D;new String(“abc”); str1&#x3D;new String(“cba”);不是改变了字符串str1吗？那么你有必要先搞懂对象引用和对象本身的区别。这里我简单的说明一下，对象本身指的是存放在堆空间中的该对象的实例数据(非静态非常量字段)。而对象引用指的是堆中对象本身所存放的地址，一般方法区和Java栈中存储的都是对象引用，而非对象本身的数据。</p><p>   (2) StringBuffer中的value[]就是一个很普通的数组，而且可以通过append()方法将新字符串加入value[]末尾。这样也就改变了value[]的内容和大小了。</p><p>   比如：new StringBuffer(“abc”)使得value[]&#x3D;{‘a’,’b’,’c’,’’,’’…}(注意构造的长度是str.length()+16)。如果再将这个对象append(“abc”)，那么这个对象中的value[]&#x3D;{‘a’,’b’,’c’,’a’,’b’,’c’,’’….}。这也就是为什么大家说 StringBuffer是可变字符串 的涵义了。从这一点也可以看出，StringBuffer中的value[]完全可以作为字符串的缓冲区功能。其累加性能是很不错的</p><p>   总结，讨论String和StringBuffer可不可变。本质上是指对象中的value[]字符数组可不可变，而不是对象引用可不可变。 </p><h2 id="3-StringBuilder"><a href="#3-StringBuilder" class="headerlink" title="3.StringBuilder"></a>3.StringBuilder</h2><p>程序开发过程中，我们常常碰到字符串连接的情况，方便和直接的方式是通过”+”符号来实现，但是这种方式达到目的的效率比较低，且每执行一次都会创建一个String对象，即耗时，又浪费空间。使用<a href="https://so.csdn.net/so/search?q=StringBuilder%E7%B1%BB&spm=1001.2101.3001.7020">StringBuilder类</a>就可以避免这种问题的发生，下面就Stringbuilder的使用做个简要的总结：</p><p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&spm=1001.2101.3001.7020">线程安全</a>的（不能同步访问）。</p><p>由于 StringBuilder 相较于 StringBuffer 有速度优势，<strong>所以多数情况下建议使用 StringBuilder 类</strong>。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p><h3 id="String和StringBuilder的区别："><a href="#String和StringBuilder的区别：" class="headerlink" title="String和StringBuilder的区别："></a>String和StringBuilder的区别：</h3><p>   ●String：内容不可变   </p><p>   ●StringBuilder：内容是可变的</p><p>好处：效率高   但线程不安全</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1.无参数  stringBuilder  s&#x3D;new stringBuilder();</p><p>实例化时会有一个默认的16字符的空间，当追加字符超过16个字符时，会新开一个翻倍的空间，而原油空间会浪费掉</p><p>2.有参数：stringBulider s&#x3D;new stringBuilder(20);</p><p>可以在实例化的时候创建一个固定大小的空间，避免资源的浪费。</p><p>常见的方法：</p><p>StringBuilder的常见用法。</p><p>1、初始化一个StringBuilder。</p><pre><code>StringBuilder sb = new StringBuilder()；</code></pre><p>2、填充：使用append() 来追加字符串填充到sb中：</p><pre><code>  sb.append(&quot;xxxx&quot;).append(&quot; xxx&quot;)....可继续延伸</code></pre><p>3、删除sb里面的已有的内容：</p><pre><code>  sb.delete(0,sb.length());将删除sb里面从0开始到结尾的所有内容，也可以自己定义区间</code></pre><p>4、sb里面的内容要显示时需要转换成String类型</p><pre><code>  System.out.println(sb.toString());r reverse() 返回相反的字符序列</code></pre><p>5.reverse 可以反转</p><h2 id="4-从源码出发（进阶）吊打面试官"><a href="#4-从源码出发（进阶）吊打面试官" class="headerlink" title="4.从源码出发（进阶）吊打面试官"></a>4.从源码出发（进阶）吊打面试官</h2><p>stringbuffer和stringbuild区别<br>1、StringBuffer 与 StringBuilder 是长度可变得。<br>2、只是StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。<br>3、在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全。而StringBuffer则每次都需要判断锁，效率相对更低。</p><p>public final class String implements java.io.Serializable, Comparable<String>, CharSequence {<br>    &#x2F;** The value is used for character storage. *&#x2F;<br>    private final char value[];</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** Cache the hash code for the string */</span><span class="token keyword">private</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Default to 0</span><span class="token comment" spellcheck="true">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span>6849794470754667710L<span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">&lt;=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Note: offset or count might be near -1>>>1.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">></span> value<span class="token punctuation">.</span>length <span class="token operator">-</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>offset <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> offset<span class="token operator">+</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个被final关键字修饰的char[]数组，所以实现细节上也是不允许改变，这就是String类的Immutable（不可变）属性(你知道String类为什么不能被继承吗？)，导致每次对String的操作都会生成新的String对象导致每次对String的操作都会生成新的String对象，这样不仅效率低下，而且大量浪费有限的内存空间。<br>2、StringBuffer和StringBuild</p><p>public final class StringBuilder    extends AbstractStringBuilder    implements java.io.Serializable, CharSequence {}</p><p>public final class StringBuffer    extends AbstractStringBuilder    implements java.io.Serializable, CharSequence {}</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>    <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span><span class="token punctuation">,</span> Comparable<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** The value is used for character storage. */</span><span class="token comment" spellcheck="true">//final修饰的char数组</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractStringBuilder</span> <span class="token keyword">implements</span> <span class="token class-name">Appendable</span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * The value is used for character storage.     */</span>    <span class="token comment" spellcheck="true">//stringbuilder和stringbuffer都继承了AbstractStringBuilder 但AbstractStringBuilder 中的     </span><span class="token comment" spellcheck="true">//char数组没有使用final修饰，这就是为什么string是不可变，但stringbuffer和stringbuilder是可变的</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/**     * The count is the number of characters used.     */</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/**     * This no-arg constructor is necessary for serialization of subclasses.     */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过Stringbuffer和Stringbuilder的源码和类结构图，可以发现Stringbuilder和Stringbuffer都是继承了abstractStringbuilder这个抽象类，然后实现了Serializable, CharSequence接口。其次Stringbuilder和Stringbuffer的内部实现其实跟String是一样的，都是通过一个char类型的数组进行存储字符串的，但是是String类中的char数组是final修饰的，是不可变的，而StringBuilder和StringBuffer中的char数组没有被final修饰，是可变的。这就是StringBuilder和StringBuffer和String的区别。</p><p>在多线程编程中有个概念叫原子操作，原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有切换到任何的一个其他的线程）。上述代码中的count+&#x3D;len就不是一个原子操作，它等同于count&#x3D;count+len，比如在上诉代码中，执行到count的值为99998的时候，新建一个len长度为1，但是当有两个线程同时执行到了count+&#x3D;len的时候，他们的count的值都是99998，然后分别各自都执行了count+&#x3D;len，则执行完之后的值都是99999，然后将值赋给count，则count最后的结果是99999，不是正确的100000，所以在多线程中执行stringbuilder的值始终会小于正确的结果。但是StringBuilder和stringbuffer都是继承了abstractstringbuilder为什么结果不一样呢。既然abstractstringbuilder中的append方法肯定都是一样的,再来看看stringbuffer中的</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token comment" spellcheck="true">//append操作被synchronized 关键字修饰了</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> StringBuffer <span class="token function">append</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        toStringCache <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>   <span class="token comment" spellcheck="true">//append操作被synchronized 关键字修饰了</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> StringBuffer <span class="token function">append</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        toStringCache <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现stringbuffer中的append操作被synchronized关键字修饰了。这个关键字肯定不会陌生，主要用来保证多线程中的线程同步和保证数据的准确性。所以再多线程中使用stringbuffer是线程安全的。在AbstractStringBuilder的append方法中有这样的两个个操作:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>count <span class="token operator">+</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//1</span>str<span class="token punctuation">.</span><span class="token function">getChars</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> value<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>转到第一个操作方法的源码，可以发现这是一个是检查StringBuilder对象的原数组的大小是否能装下新的字符串的方法，如果装不下了就new一个新的数组，新的数组的容量是原来char数组的两倍，再通过CopyOf()方法将原数组的内容复制到新数组。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * For positive values of {@code minimumCapacity}, this method     * behaves like {@code ensureCapacity}, however it is never     * synchronized.     * If {@code minimumCapacity} is non positive due to numeric     * overflow, this method throws {@code OutOfMemoryError}.     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minimumCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// overflow-conscious code</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minimumCapacity <span class="token operator">-</span> value<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            value <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span>                    <span class="token function">newCapacity</span><span class="token punctuation">(</span>minimumCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后第二步操作是将String对象里面char数组里面的内容拷贝到StringBuilder对象的char数组里面。getchars源码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getChars</span><span class="token punctuation">(</span><span class="token keyword">int</span> srcBegin<span class="token punctuation">,</span> <span class="token keyword">int</span> srcEnd<span class="token punctuation">,</span> <span class="token keyword">char</span> dst<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> dstBegin<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//1       </span> <span class="token keyword">if</span> <span class="token punctuation">(</span>srcBegin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>srcBegin<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//2   </span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>srcEnd <span class="token operator">></span> value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>srcEnd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//3   </span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>srcBegin <span class="token operator">></span> srcEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>srcEnd <span class="token operator">-</span> srcBegin<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> srcBegin<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> dstBegin<span class="token punctuation">,</span> srcEnd <span class="token operator">-</span> srcBegin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到原来在这里会抛出StringIndexOutOfBoundsException的异常。假设前面的代码中有两个线程a和线程b同时执行了append方法，并且都执行完了ensureCapacityInternal()方法，这个时候count的值为99997，如果当线程a执行完了，则轮到线程2继续执行，线程b执行完了append方法之后，count变成了99998，这个时候如果线程a执行到了上面的getchars方法的时候线程a得到的count的值就是99998了，而它本来的值应该是99997，所以在这个时候就会抛出ArrayIndexOutOfBoundsException的异常了。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建mybatis指南</title>
      <link href="/2022/03/27/%E6%90%AD%E5%BB%BAmybatis%E6%8C%87%E5%8D%97/"/>
      <url>/2022/03/27/%E6%90%AD%E5%BB%BAmybatis%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="一、搭建MyBatis"><a href="#一、搭建MyBatis" class="headerlink" title="一、搭建MyBatis"></a>一、<strong>搭建</strong>MyBatis</h1><h2 id="1-开发环境"><a href="#1-开发环境" class="headerlink" title="1.开发环境"></a>1.开发环境</h2><p>IDEA version : 2021.2.2</p><p>mysql version ：8.0.23</p><p>mybatis version : 3.5.2</p><p>maven version : 3.5.7</p><h2 id="2-创建maven工程"><a href="#2-创建maven工程" class="headerlink" title="2.创建maven工程"></a>2.创建maven工程</h2><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220327134903258.png"></p><p>next-&gt;Name(存放路径)-&gt;groupID(com.lyc.mybatis)-&gt;finish</p><p>加入依赖</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.11<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.5.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>8.0.25<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.13.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-创建数据库连接信息配置文件"><a href="#3-创建数据库连接信息配置文件" class="headerlink" title="3.创建数据库连接信息配置文件"></a>3.创建数据库连接信息配置文件</h2><p>在项目中的src&#x2F;main&#x2F;resources目录下创建db.properties</p><pre class="line-numbers language-sql"><code class="language-sql">driver <span class="token operator">=</span> com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>cj<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>Driverurl <span class="token operator">=</span> jdbc:mysql:<span class="token comment" spellcheck="true">//localhost:3306/mybatis?serverTimezone=UTC&amp;\</span>            characterEncoding<span class="token operator">=</span>utf8<span class="token operator">&amp;</span>useUnicode<span class="token operator">=</span><span class="token boolean">true</span><span class="token operator">&amp;</span>useSSL<span class="token operator">=</span><span class="token boolean">false</span>username <span class="token operator">=</span> rootpassword <span class="token operator">=</span> <span class="token number">123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-创建MyBatis的核心配置文件"><a href="#4-创建MyBatis的核心配置文件" class="headerlink" title="4.创建MyBatis的核心配置文件"></a>4.创建MyBatis的核心配置文件</h2><p>在项目中的src&#x2F;main&#x2F;resources目录下创建MyBatis的核心配置文件</p><p>用于项目的环境配置，如数据库连接相关配置等。建议命名为mybatis-config.xml</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?></span> <span class="token doctype">&lt;!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>db.properties<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!--设置连接数据库的环境--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environments</span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environment</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManager</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POOLED<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driver<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${driver}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${url}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${username}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${password}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataSource</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environment</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environments</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--引入映射文件--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mappers/UserMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数详细：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?></span>  xml的版本号<span class="token doctype">&lt;!DOCTYPE configuration  mybatis中的约束  dtd文件        PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"></span>configuration 根标签environments 可嵌套多个单数标签 <span class="token comment" spellcheck="true">&lt;!--设置连接数据库的环境--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--引入映射文件--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManager</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> 事务的管理方式以jdbc的方式进行管理<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POOLED<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> 数据库连接池 下一次使用直接调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-创建POJO实体"><a href="#5-创建POJO实体" class="headerlink" title="5.创建POJO实体"></a>5.创建POJO实体</h2><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220327143310015.png"></p><p>这是我们的表中的数据 跟实体类的属性要一致（默认的映射规则）-&gt;为属性名赋值</p><p>在src&#x2F;main&#x2F;java 目录下创建com.lyc.mybatis.pojo包 在pojo包下创建User类 该类用于封装User对象的属性 如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> uid<span class="token punctuation">;</span>    <span class="token keyword">private</span> String uname<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> uage<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getUid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> uid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUid</span><span class="token punctuation">(</span><span class="token keyword">int</span> uid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>uid <span class="token operator">=</span> uid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getUname</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> uname<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUname</span><span class="token punctuation">(</span>String uname<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>uname <span class="token operator">=</span> uname<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getUage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> uage<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUage</span><span class="token punctuation">(</span><span class="token keyword">int</span> uage<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>uage <span class="token operator">=</span> uage<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-创建mapper接口"><a href="#6-创建mapper接口" class="headerlink" title="6.创建mapper接口"></a>6.创建mapper接口</h2><p>MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要</p><p>提供实现类。</p><p>在src&#x2F;main&#x2F;java&#x2F;com.lyc.mybatis下创建mapper文件夹</p><p>在文件夹下创建UserMapper接口</p><pre><code>int insertUser();</code></pre><h2 id="7-创建映射文件UserMapper-xml"><a href="#7-创建映射文件UserMapper-xml" class="headerlink" title="7.创建映射文件UserMapper.xml"></a>7.创建映射文件UserMapper.xml</h2><p>在src&#x2F;main&#x2F;resources下创建一个mappers文件夹 在文件下创建映射文件UserMapper.xml</p><p>用于配置真正的sql与java对象之间的映射  </p><p><strong>1.MyBatis映射文件用于编写SQL，访问以及操作表中的数据</strong></p><p><strong>2、MyBatis中可以面向接口操作数据，要保证两个一致：</strong> </p><p>a&gt;mapper接口的全类名和映射文件的命名空间（namespace）保持一致</p><p>b&gt;mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token comment" spellcheck="true">&lt;!--sql与java之间的映射 --></span><span class="token doctype">&lt;!DOCTYPE mapper        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.lyc.mybatis.mapper.UserMapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>insertUser<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        insert into users values (4,'王五',19)    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>映射文件的命名规则：</p><p>表所对应的实体类的类名+Mapper.xml</p><p>例如：表t_user，映射的实体类为Users，所对应的映射文件为UsersMapper.xml</p><h2 id="8-测试"><a href="#8-测试" class="headerlink" title="8.测试"></a>8.测试</h2><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220327152644515.png"></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> com<span class="token punctuation">.</span>lyc<span class="token punctuation">.</span>mybatis<span class="token punctuation">.</span>mapper<span class="token punctuation">.</span>UserMapper<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Resources<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>session<span class="token punctuation">.</span>SqlSession<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>session<span class="token punctuation">.</span>SqlSessionFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>session<span class="token punctuation">.</span>SqlSessionFactoryBuilder<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStream<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapperTest01</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">TestMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//读取MyBatis的核心配置文件 InputStream is = Resources.g</span>        InputStream resourceAsStream <span class="token operator">=</span>   Resources<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"mybatis-config.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">////通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象</span>        SqlSessionFactoryBuilder sqlSessionFactoryBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SqlSessionFactory sqlSessionFactory <span class="token operator">=</span> sqlSessionFactoryBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>resourceAsStream<span class="token punctuation">)</span><span class="token punctuation">;</span>        SqlSession session <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                UserMapper mapper <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>UserMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配 映射文件中的SQL标            签，并执行标签中的SQL语句</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">insertUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//事务提交</span>        session<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result"</span><span class="token operator">+</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> ORM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql中的聚合函数易混淆的概念</title>
      <link href="/2022/03/20/mysql%E4%B8%AD%E7%9A%84%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/03/20/mysql%E4%B8%AD%E7%9A%84%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h1><p>与其他查询不同，普通的查询做的都是横向查询，它们都是根据条件一行一行的进行判断，而使用聚合函数查询是纵向查询，</p><p>它是对一列的值进行计算，然后返回一个单一的值；另外聚合函数会忽略空值。</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/11.png"></p><h3 id="从案例引出问题："><a href="#从案例引出问题：" class="headerlink" title="从案例引出问题："></a>从案例引出问题：</h3><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220320154124681.png"></p><p>我们基于以上表作为查询：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> product<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 返回18 没有任何问题</span><span class="token keyword">select</span> pid<span class="token punctuation">,</span><span class="token function">min</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span> <span class="token keyword">from</span> product <span class="token punctuation">;</span><span class="token keyword">select</span> pid<span class="token punctuation">,</span><span class="token function">max</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span> <span class="token keyword">from</span> product <span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 此时不报错 pid显示结果都为1  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Q；为什么会产生这种现象？</p><p>因为聚合函数是对列进行操作和pid字段没有产生联系 ，系统pid默认的值全为1</p><p>此时我们可以考虑子查询＋AND 来解决类似hive里的窗口函数的功能</p><pre><code>select pid ,price from product where price = (select min(price) from product);</code></pre><p>聚合函数一般会和分组查询group by 结合使用</p><p>格式：</p><p>select 字段1,字段2… from 表名 group by 分组字段 having 分组条件;</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 1 统计各个分类商品的个数</span><span class="token keyword">select</span> category_id <span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> product <span class="token keyword">group</span> <span class="token keyword">by</span> category_id <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220320160246892.png"></p><p>执行结果如上：</p><p>执行顺序是先分组 再进行count聚合  </p><p>注意：如果要进行分组的话，则SELECT子句之后，只能出现分组的字段和统计函数，其他的字段不能出现</p><h3 id="having与where的区别"><a href="#having与where的区别" class="headerlink" title="having与where的区别"></a>having与where的区别</h3><ul><li><p>分组之后对统计结果进行筛选的话必须使用having，不能使用where</p></li><li><p>where子句用来筛选 FROM 子句中指定的操作所产生的   行 </p></li><li><p>group  by  子句用来分组 WHERE 子句的输出。 </p></li><li><p>having 子句用来从分组的结果中筛选行</p></li></ul><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> category_id <span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> product <span class="token keyword">where</span> price<span class="token operator">></span><span class="token number">300</span> <span class="token keyword">group</span> <span class="token keyword">by</span> category_id <span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">select</span> category_id <span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> product <span class="token keyword">group</span> <span class="token keyword">by</span> category_id <span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 思考以上语句哪条会有问题？</span><span class="token comment" spellcheck="true">-- 答案是都没问题 where首先把不满足的行去掉后进行分组，筛选出特定的组 </span><span class="token comment" spellcheck="true">-- 另一个也是将条件不满足的筛选掉 只不过是分组后进行 顺序问题</span><span class="token comment" spellcheck="true">-- 执行顺序where>group by>count(*) > having </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="一些注意的点"><a href="#一些注意的点" class="headerlink" title="一些注意的点"></a>一些注意的点</h3><p>mysql 5.6环境下除了count(*)为特例（不忽略null值）外，其余聚集函数确实是忽略null值</p><p>聚合函数默认忽略字段为null的记录 要想列值为null的记录也参与计算，必须使用ifnull函数对null值做替换  这里不做过多演示</p><p>使用Group By子句返回的组没有特定的顺序，可以使用Order By子句指定次序。</p><p>group by和order by连用的确会出现问题</p><h4 id="Group-by中子查询order-by排序失效问题分析"><a href="#Group-by中子查询order-by排序失效问题分析" class="headerlink" title="Group by中子查询order by排序失效问题分析"></a>Group by中子查询order by排序失效问题分析</h4><p>依然要考虑执行顺序</p><p><strong>获取sql分组中id最大的记录</strong></p><p>select id,name from (select id,name from tt order by id desc) as t group by name</p><p>从from开始执行顺序   group by的执行顺序&gt; select  每个组默认取了第一条数据。</p><pre><code>// 表数据如下：id,name1,name12,name13,name24,name2select id,name from (select id,name from tt order by id desc) as t group by name// 输出结果如下：id,name1,name13,name2</code></pre><p>这是为什么呢？因为mysql 5.6之后版本对排序的sql解析做了优化，子查询中的排序是会被忽略的，所以上面的order by id desc未起到作用。如果子语句中排序不做优化那不就可以了么，查阅资料发现可以在子语句中加上limit来避免这种优化（加上limit相当于临时表限定了取值范围不会进行优化，如果是全表的话就被优化掉了）。</p><p>正确写法：</p><pre><code>// 加上limitselect id,name from (select id,name from tt order by id desc limit 1024) as t group by name // 输出结果如下：id,name2,name14,name2</code></pre>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 聚合函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList底层结构和源码分析</title>
      <link href="/2022/03/19/ArrayList%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2022/03/19/ArrayList%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h1><p>1）允许添加任意的元素 包括null 多个</p><p>2） ArrayList是由数组来实现数据存储的</p><p>3）Array在多线程中是不安全的 建议使用vector</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>数组是数据结构基本的数据结构 java封装了一系列数组的方法</p><p>数组中存储的内存是连续的 插入和删除困难 查询方便</p><ul><li>ArrayList中维护了一个Object类型的数组elementData</li><li>无参构造器：自动扩容机制 ele-&gt;0（default）-&gt;10（First add）-&gt;15(second add)-&gt;15x1.5-&gt;15x1.5x1.5</li><li>有参构造器：指定大小（size）-&gt;size*1.5(First add) -&gt; sizex1.5X1.5(second add)</li></ul><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><ul><li>Tip：英语对于看源码和理解有一定的帮助</li></ul><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h4><pre class="line-numbers language-java"><code class="language-java">     <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建指定长度的object数组</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//空数组</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>            <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将集合转换成数组</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> ArrayList<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//如果不是object数组类型</span>                elementData <span class="token operator">=</span> a<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> size<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//拷贝一下</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// replace with empty array.</span>            elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * This helper method split out from add(E) to keep method * bytecode size under 35 (the -XX:MaxInlineSize default value), * which helps when add(E) is called in a C1-compiled loop. */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        elementData <span class="token operator">=</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    size <span class="token operator">=</span> s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return {@code true} (as specified by {@link Collection#add}) */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//改进后的直接自增</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException {@inheritDoc} */</span><span class="token comment" spellcheck="true">//指定位置添加</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> s<span class="token punctuation">;</span>    Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> size<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span>elementData <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>elementData<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>        elementData <span class="token operator">=</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将index之后的所有元素移动一位</span>    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                     elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                     s <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>    size <span class="token operator">=</span> s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//扩容的入口方法 DEFAULTCAPACITY_EMPTY_ELEMENTDATA  默认为10</span><span class="token comment" spellcheck="true">//判断是你的值大还是它的值大 就返回你的值</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> elementData<span class="token punctuation">.</span>length            <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA                 <span class="token operator">&amp;&amp;</span> minCapacity <span class="token operator">&lt;=</span> DEFAULT_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            modCount<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//数组扩容方法</span>   <span class="token keyword">private</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> elementData <span class="token operator">!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> ArraysSupport<span class="token punctuation">.</span><span class="token function">newLength</span><span class="token punctuation">(</span>oldCapacity<span class="token punctuation">,</span>                    minCapacity <span class="token operator">-</span> oldCapacity<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* minimum growth */</span>                    oldCapacity <span class="token operator">>></span> <span class="token number">1</span>           <span class="token comment" spellcheck="true">/* preferred growth */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">grow</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//第一次其实是  0*any=0    </span><span class="token comment" spellcheck="true">//用0.5倍来扩容</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>modCount++;用来记录修改的记录</p><pre><code>return elementData = Arrays.copyOf(elementData, newCapacity);</code></pre><p>进行扩容</p><p>使用扩容机制来确定扩容到多大</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper的基本介绍</title>
      <link href="/2022/03/19/zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/03/19/zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Zookeeper："><a href="#Zookeeper：" class="headerlink" title="Zookeeper："></a>Zookeeper：</h1><p>官方文档上这么解释zookeeper，它是一个分布式服务框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：<strong>统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理</strong>。  </p><p>上面的解释有点抽象，简单来说zookeeper&#x3D;文件系统+监听通知机制。  </p><p>每个子目录项如 NameService 都被称作为 znode(目录节点)，和文件系统一样，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode，唯一的不同在于znode是可以存储<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE&spm=1001.2101.3001.7020">数据</a>的。</p><h4 id="四种类型的znode："><a href="#四种类型的znode：" class="headerlink" title="四种类型的znode："></a>四种类型的znode：</h4><ul><li><h5 id="PERSISTENT-持久化目录节点"><a href="#PERSISTENT-持久化目录节点" class="headerlink" title="PERSISTENT-持久化目录节点"></a>PERSISTENT-持久化目录节点</h5></li></ul><p>客户端与zookeeper断开连接后，该节点依旧存在</p><ul><li><h5 id="PERSISTENT-SEQUENTIAL-持久化顺序编号目录节点"><a href="#PERSISTENT-SEQUENTIAL-持久化顺序编号目录节点" class="headerlink" title="PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点"></a>PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点</h5></li></ul><p>客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号</p><ul><li><h5 id="EPHEMERAL-临时目录节点"><a href="#EPHEMERAL-临时目录节点" class="headerlink" title="EPHEMERAL-临时目录节点"></a>EPHEMERAL-临时目录节点</h5></li></ul><p>客户端与zookeeper断开连接后，该节点被删除</p><ul><li><h5 id="EPHEMERAL-SEQUENTIAL-临时顺序编号目录节点"><a href="#EPHEMERAL-SEQUENTIAL-临时顺序编号目录节点" class="headerlink" title="EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点"></a>EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点</h5></li></ul><p>客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</p><h4 id="监听通知机制"><a href="#监听通知机制" class="headerlink" title="监听通知机制"></a>监听通知机制</h4><p>客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。</p><p>就这么简单，下面我们看看Zookeeper能做点什么呢？</p><p>zookeeper功能非常强大，可以实现诸如<a href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F&spm=1001.2101.3001.7020">分布式</a>应用配置管理、统一命名服务、状态同步服务、集群管理等功能，我们这里拿比较简单的分布式应用配置管理为例来说明。</p><p>假设我们的程序是分布式部署在多台机器上，如果我们要改变程序的配置文件，需要逐台机器去修改，非常麻烦，现在把这些配置全部放到zookeeper上去，保存在 zookeeper 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到 zookeeper 的通知，然后从 zookeeper 获取新的配置信息应用到系统中。</p><h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><p>先给自己选票+1；后面再根据myid开始选票；</p><ul><li><p>崩溃恢复：主要就是Leader选举过程。</p></li><li><p>数据同步：Leader服务器与其他服务器进行数据同步。</p></li><li><p>消息广播：Leader服务器将数据发送给其他服务器。</p></li></ul><p>Q:集群中为什么要有主节点</p><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，</p><p>其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点</p><h2 id="leader-选举过程"><a href="#leader-选举过程" class="headerlink" title="leader 选举过程"></a>leader 选举过程</h2><p>有两种情况会发起Leader选举：</p><ol><li><p>服务器启动的时候</p></li><li><p>服务器运行的时候当Leader宕机</p></li></ol><h4 id="第一次选举规则："><a href="#第一次选举规则：" class="headerlink" title="第一次选举规则："></a><strong>第一次选举规则：</strong></h4><p>投票过半数时，id大的胜出</p><h4 id="第二次选举规则："><a href="#第二次选举规则：" class="headerlink" title="第二次选举规则："></a><strong>第二次选举规则：</strong></h4><p>Epoch 大的直接胜出</p><p>若相同 ID 大的直接胜出</p><p>事物id相同 服务器id大的胜出</p><h3 id="Q-生产集群安装多少台zookeeper合适："><a href="#Q-生产集群安装多少台zookeeper合适：" class="headerlink" title="Q:生产集群安装多少台zookeeper合适："></a>Q:生产集群安装多少台zookeeper合适：</h3><p>10台服务器：3台zk;</p><p>20台：5台zk</p><p>100台：11台zk</p><p>服务器台数多的时候，可靠性比较高 坏处：提高通信延时</p><p>paxos算法：一种消息传递且具有高度容错特性的一致性算法</p><h3 id="Q-Zookeeper-怎么保证主从节点的状态同步？"><a href="#Q-Zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="Q:Zookeeper 怎么保证主从节点的状态同步？"></a>Q:Zookeeper 怎么保证主从节点的状态同步？</h3><p>Zookeeper 的核心是原子广播机制，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。</p><p>paxos算法解决的问题：就是如何快速在一个分布式系统中对某一个数据进行达成一致，且保证不论发生任何异常</p><p>都不会破坏系统的一致性</p><p>例如：机器宕机</p>]]></content>
      
      
      <categories>
          
          <category> 大数据生态圈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于super关键字和this的区别</title>
      <link href="/2022/03/17/%E5%85%B3%E4%BA%8Esuper%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8Cthis%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/03/17/%E5%85%B3%E4%BA%8Esuper%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8Cthis%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="一、super-与-this-用法"><a href="#一、super-与-this-用法" class="headerlink" title="一、super 与 this 用法"></a>一、super 与 this 用法</h2><h4 id="关于super"><a href="#关于super" class="headerlink" title="关于super"></a>关于super</h4><ol><li><p>主要存在于子类方法中，用于指向子类对象中父类对象。</p></li><li><p>调用父类的属性和方法</p></li><li><p>访问父类的构造函数</p></li></ol><ul><li><p>关于super你首先需要明白的是，如果父类和子类都有一个同名方法</p><p> 在没有重写的情况下，优先调用的是父类的方法</p></li><li><p>只有重写后才会优先调用子类的 这时候就可以使用super关键字来调用</p></li><li><p>super（形参列表）的使用，必须声明在<a href="https://so.csdn.net/so/search?q=%E5%AD%90%E7%B1%BB&spm=1001.2101.3001.7020">子类</a>构造器的首行。</p></li></ul><p><strong>例子</strong></p><p>我们可以注意到父类和子类都有相同的成员变量age，（super.age）就是访问的是Person类中的age </p><p>如果不加super 就近原则就是Student类的age</p><pre><code>class Person &#123;    int age = 12;&#125;class Student extends Person &#123;    int age = 18;    void display() &#123;        System.out.println(&quot;学生年龄：&quot; + super.age);    &#125;&#125;class Test &#123;    public static void main(String[] args) &#123;        Student stu = new Student();        stu.display();    &#125;&#125;</code></pre><h4 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h4><p>​    1 this相当于是指向当前对象本身</p><p>​    2 形参与成员变量重名，用this来区分</p><p>​    3 this关键字也可以在构造函数中调用其他构造函数 但是必须定义在构造函数的第一行 这一点与super的用法非常相似  this（）调用其他构造函数时，必须放在定义的构造函数第一行。如果随意放在普通方法的第一行，则立马报错</p><p><strong>例子</strong></p><pre><code>class Person&#123;    private String name;    private int age;    Person(String name)    &#123;        //成员变量和局部变量重名，可以用关键字this区分        this.name = name;    &#125;    public void speak()    &#123;        //输出时，会默认为成员增加this关键字，用来代表具体对象的数据        System.out.println(this.name+&quot;：&quot;+this.age);    &#125;&#125;</code></pre><pre><code>class Person&#123;    private String name;    private int age;    Person()    &#123;        name = &quot;baby&quot;;        age = 1;        System.out.println(&quot;Person run&quot;);    &#125;    Person(String name)    &#123;        //成员变量和局部变量重名，可以用关键字this区分        this.name = name;    &#125;    Person(String name,int age)    &#123;        //调用其他构造函数时，只能定义在构造函数的第一行，因为初始化动作要先执行        this();        this.name = name;        this.age = age;    &#125;    public void speak()    &#123;        System.out.println(this.name+&quot;：&quot;+this.age);    &#125; &#125;  class ThisDemo &#123;    public static void main(String[] args)     &#123;        Person p = new Person(&quot;小强&quot;,10);        p.speak();    &#125;&#125;//输出结果Person run 小强：10</code></pre><p> <strong>虽然我们在 Person(String name,int age) 构造函数中调用了 Person() 构造函数，但是最后的输出结果，仅输出了 Person run ，成员变量的内容还是我们在新建对象时，传递进去的参数，并不是 Person() 中初始化的内容。成员变量传进去的参数所被覆盖了</strong></p><h4 id="二、关于一些细节"><a href="#二、关于一些细节" class="headerlink" title="二、关于一些细节"></a>二、关于一些细节</h4><p>为了看的更直观 我们直接用代码进行说明</p><pre><code>public class Animal &#123;    public Animal() &#123;        System.out.println(&quot;Animal类的无参数构造函数执行&quot;);    &#125;&#125;class Cat extends Animal &#123;    public Cat() &#123;        System.out.println(&quot;Cat类的无参数构造函数执行&quot;);        &#125;    &#125;    class Test &#123;        public static void main(String[] args) &#123;            Cat c1 = new Cat();        &#125;    &#125;// 在实例化对象的时候 直接就把构造器的方法全执行了//上面的隐藏了一个super(); 你写不写都行 但为了看的方便我们还是需要在子类的构造器中写一下的</code></pre><p>那么又引出一个问题 父类有多个构造器我们怎么知道super调用的是哪个?</p><p>1.父类是无参构造器 super（）；</p><p>2.父类是有参构造器super(name,age); 调用相同形参的</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于HashList的深入探究</title>
      <link href="/2022/03/15/%E5%85%B3%E4%BA%8EHashList%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6/"/>
      <url>/2022/03/15/%E5%85%B3%E4%BA%8EHashList%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220315223146221.png"></p><h2 id="HashSet本质是HashMap"><a href="#HashSet本质是HashMap" class="headerlink" title="HashSet本质是HashMap"></a>HashSet本质是HashMap</h2><p>HashSet是一个不允许有重复元素的集合。</p><p>它实现了set接口 可以存放null值，但是只能有一个null</p><p>和ArrayList不同的是：HashSet 是无序的，即不会记录插入的顺序。</p><p>HashSet是非同步的。如果多个线程同时访问一个<a href="https://so.csdn.net/so/search?q=%E5%93%88%E5%B8%8C&spm=1001.2101.3001.7020">哈希</a> set，<br>而其中至少一个线程修改了该 set，那么它必须 保持外部同步。这通常是通过对自然封装该 set 的对象执行同步操作来完成的。<br>如果不存在这样的对象，则应该使用 Collections.synchronizedSet 方法来“包装” set。最好在创建时完成这一操作，<br>以防止对该 set 进行意外的不同步访问：</p><pre><code>HashSet set = new HashSet();//1.add方法返回的是一个boolean值 添加成功则为true 失败为false//2.remove的方法指定删除对象</code></pre><h2 id="HASHMAP"><a href="#HASHMAP" class="headerlink" title="HASHMAP"></a>HASHMAP</h2><p>HashMap底层是数组+链表+红黑树</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/20160605101246837.png"></p><h3 id="数组元素Node-lt-K-V-gt-实现了Entry接口"><a href="#数组元素Node-lt-K-V-gt-实现了Entry接口" class="headerlink" title="数组元素Node&lt;K,V&gt;实现了Entry接口"></a>数组元素Node&lt;K,V&gt;实现了Entry接口</h3><pre><code>//Node是单向链表，它实现了Map.Entry接口static class Node&lt;k,v&gt; implements Map.Entry&lt;k,v&gt; &#123;    final int hash;    final K key;    V value;    Node&lt;k,v&gt; next;    //构造函数Hash值 键 值 下一个节点    Node(int hash, K key, V value, Node&lt;k,v&gt; next) &#123;        this.hash = hash;        this.key = key;        this.value = value;        this.next = next;    &#125;     public final K getKey()        &#123; return key; &#125;    public final V getValue()      &#123; return value; &#125;    public final String toString() &#123; return key + = + value; &#125;     public final int hashCode() &#123;        return Objects.hashCode(key) ^ Objects.hashCode(value);    &#125;     public final V setValue(V newValue) &#123;        V oldValue = value;        value = newValue;        return oldValue;    &#125;    //判断两个node是否相等,若key和value都相等，返回true。可以与自身比较为true    public final boolean equals(Object o) &#123;        if (o == this)            return true;        if (o instanceof Map.Entry) &#123;            Map.Entry&lt;!--?,?--&gt; e = (Map.Entry&lt;!--?,?--&gt;)o;            if (Objects.equals(key, e.getKey()) &amp;&amp;                Objects.equals(value, e.getValue()))                return true;        &#125;        return false;    &#125;</code></pre><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><pre><code>//红黑树static final class TreeNode&lt;k,v&gt; extends LinkedHashMap.Entry&lt;k,v&gt; &#123;    TreeNode&lt;k,v&gt; parent;  // 父节点    TreeNode&lt;k,v&gt; left; //左子树    TreeNode&lt;k,v&gt; right;//右子树    TreeNode&lt;k,v&gt; prev;    // needed to unlink next upon deletion    boolean red;    //颜色属性    TreeNode(int hash, K key, V val, Node&lt;k,v&gt; next) &#123;        super(hash, key, val, next);    &#125;     //返回当前节点的根节点    final TreeNode&lt;k,v&gt; root() &#123;        for (TreeNode&lt;k,v&gt; r = this, p;;) &#123;            if ((p = r.parent) == null)                return r;            r = p;        &#125;    &#125;</code></pre><p>HashMap有四个构造函数可供我们使用</p><pre><code>//默认无参构造，指定一个默认的加载因子public HashMap() &#123;    this.loadFactor = DEFAULT_LOAD_FACTOR; &#125;//可指定容量的有参构造，但是需要注意当前我们指定的容量并不一定就是实际的容量，下面会说public HashMap(int initialCapacity) &#123;    //同样使用默认加载因子    this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;//可指定容量和加载因子，但是笔者不建议自己手动指定非0.75的加载因子public HashMap(int initialCapacity, float loadFactor) &#123;    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                           initialCapacity);    if (initialCapacity &gt; MAXIMUM_CAPACITY)        initialCapacity = MAXIMUM_CAPACITY;    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                                           loadFactor);    this.loadFactor = loadFactor;    //这里就是把我们指定的容量改为一个大于它的的最小的2次幂值，如传过来的容量是14，则返回16    this.threshold = tableSizeFor(initialCapacity);&#125;//可传入一个已有的mappublic HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;    this.loadFactor = DEFAULT_LOAD_FACTOR;    putMapEntries(m, false);&#125;//把传入的map里边的元素都加载到当前mapfinal void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;    int s = m.size();    if (s &gt; 0) &#123;        if (table == null) &#123; // pre-size            float ft = ((float)s / loadFactor) + 1.0F;            int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?                     (int)ft : MAXIMUM_CAPACITY);            if (t &gt; threshold)                threshold = tableSizeFor(t);        &#125;        else if (s &gt; threshold)            resize();        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;            K key = e.getKey();            V value = e.getValue();    putVal(hash(key), key, value, false, evict);        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hive的配置</title>
      <link href="/2022/03/10/hive%E4%B8%93%E9%A2%98/"/>
      <url>/2022/03/10/hive%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="认识hive的基本配置"><a href="#认识hive的基本配置" class="headerlink" title="认识hive的基本配置"></a>认识hive的基本配置</h1><h5 id="Metastore"><a href="#Metastore" class="headerlink" title="Metastore"></a>Metastore</h5><ol><li><p>Metastores是元数据服务，元数据的服务组件，这个组件存储着hive的元数据。<br>作用：管理metadata元数据，让客户端通过连接Metastore服务，再由metastore去<br>连接MySQL数据库存取元数据。可以间接保证数据的安全。</p></li><li><p>有了metastore服务，就可以有多个客户端同时连接，而且这些客户端不需要知道<br>MySQL数据库的用户名和密码，只需要连接metastore 服务即可。</p></li></ol><h5 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h5><p>关于数据的数据或者叫做用来描述数据的数据或者叫做信息的信息。可以理解为最小的数据单元。<br>元数据可以为数据说明其元素或属性（名称、大小、数据类型、等），或其结构（长度、字段、数据列）</p><h3 id="Metastore启动方式"><a href="#Metastore启动方式" class="headerlink" title="Metastore启动方式"></a>Metastore启动方式</h3><p>Metastore的启动方式有三种：</p><p><strong>（1）嵌入模式</strong></p><p>内嵌模式使用的是内嵌的Derby数据库来存储元数据，也不需要额外起Metastore服务。<br>数据库和Metastore服务都嵌入在主Hive Server进程中。这个是默认的，配置简单，<br>但是一次只能一个客户端连接，适用于用来实验，不适用于生产环境。</p><p>解压hive安装包 bin&#x2F;hive 启动即可使用</p><p>缺点：不同路径启动hive，每一个hive拥有一套自己的元数据，无法共享。</p><p><strong>（2）本地模式</strong></p><p>本地模式采用外部数据库来存储元数据，目前支持的数据库有：<br>MySQL、Postgres、Oracle、MS SQL Server.在这里我们使用MySQL。</p><p>本地模式不需要单独起metastore服务，用的是跟hive在同一个进程里的metastore服务。<br>也就是说当你启动一个hive 服务，里面默认会帮我们启动一个metastore线程服务。<br>hive根据hive.metastore.uris，如果为空，则为本地模式。</p><p>缺点是：每启动一次hive服务，都内置启动了一个metastore。</p><p><strong>（3）远程模式</strong></p><p>远程模式下，需要单独起metastore服务（hive –service metastore），然后每个客户端</p><p>都在配置文件里配置连接到该metastore服务。</p><p>远程模式的metastore服务和hive运行在不同的进程里。</p><p>在生产环境中，建议用远程模式来配置Hive Metastore。</p><p>在这种情况下，其他依赖hive的软件都可以通过** Metastore访问hive。**</p><p>远程模式下，需要配置hive.metastore.uris 参数来指定metastore服务运行的机器ip和端口，<br>并且需要单独手动启动metastore服务，如有多个metastore服务器，URI之间用逗号分隔。</p><h2 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h2><p>本次安装的hive版本为3.0x 基于Hadoop3.0x进行远程模式的搭建</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p><strong>基本的hadoop集群环境要确保能够正常启动</strong></p><h4 id="1-防火墙管理"><a href="#1-防火墙管理" class="headerlink" title="1.防火墙管理"></a>1.防火墙管理</h4><p><strong>(1)防火墙状态查询</strong>：systemctl status firewalld.service<br><strong>(2)防火墙关闭</strong>：systemctl stop firewalld.service<br><strong>(3)禁止防火墙开机启动</strong>：systemctl disable firewalld.service</p><h4 id="2-mysql安装配置成功"><a href="#2-mysql安装配置成功" class="headerlink" title="2.mysql安装配置成功"></a>2.mysql安装配置成功</h4><p>Mysql安装配置成功并能使用 mysql -uroot -p 进行登入</p><h4 id="3-JAVA-JDK配置"><a href="#3-JAVA-JDK配置" class="headerlink" title="3.JAVA JDK配置"></a>3.JAVA JDK配置</h4><p>JDK安装配置成功，并能查看java 版本信息</p><h4 id="4-Hadoop与hive整合"><a href="#4-Hadoop与hive整合" class="headerlink" title="4.Hadoop与hive整合"></a>4.Hadoop与hive整合</h4><p>因为Hive需要把数据存储在HDFS上，并且通过MapReduce作为执行引擎处理数据；<br>修改Hadoop中core-site.xml，并且Hadoop集群同步配置文件，重启生效。</p><pre><code>&lt;!-- 整合hive --&gt;  &lt;property&gt;    &lt;name&gt;hadoop.proxyuser.root.hosts&lt;/name&gt;    &lt;value&gt;*&lt;/value&gt;  &lt;/property&gt;  &lt;property&gt;    &lt;name&gt;hadoop.proxyuser.root.groups&lt;/name&gt;    &lt;value&gt;*&lt;/value&gt;  &lt;/property&gt;</code></pre><h4 id="5-hive的jar包准备"><a href="#5-hive的jar包准备" class="headerlink" title="5.hive的jar包准备"></a>5.hive的jar包准备</h4><p>地址：<a href="http://archive.apache.org/dist/hive/hive-3.1.0/">http://archive.apache.org/dist/hive/hive-3.1.0/</a><br>选择apache-hive-3.1.0-bin.tar.gz 进行下载</p><h2 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h2><h5 id="上传解压安装包"><a href="#上传解压安装包" class="headerlink" title="上传解压安装包"></a>上传解压安装包</h5><ol><li>解压hive安装包<pre><code>tar -zxvf apache-hive-3.1.0-bin.tar.gz  -C mv apache-hive-3.1.0-bin hive</code></pre></li><li>解决hadoop、hive之间guava版本差异</li></ol><p>进入hive目录 将guava-27.0-jre.jar 拷贝至lib目录下</p><pre><code>rm -rf lib/guava-19.0.jarcp /export/server/hadoop-3.1.3/share/hadoop/common/lib/guava-27.0-jre.jar ./lib/</code></pre><ol start="3"><li>添加mysql jdbc驱动到hive安装包lib&#x2F;文件下<br>下载地址：<a href="https://maven.ityuan.com/maven2/mysql/mysql-connector-java/5.1.32">https://maven.ityuan.com/maven2/mysql/mysql-connector-java/5.1.32</a></li></ol><h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><p>可参照自己的文件存放的位置进行修改<br>cd &#x2F;export&#x2F;server&#x2F;hive&#x2F;conf&#x2F;<br>mv hive-env.sh.template hive-env.sh<br>vim hive-env.sh<br>export HADOOP_HOME&#x3D;&#x2F;export&#x2F;server&#x2F;hadoop-3.1.0<br>export HIVE_CONF_DIR&#x3D;&#x2F;export&#x2F;server&#x2F;hive&#x2F;conf<br>export HIVE_AUX_JARS_PATH&#x3D;&#x2F;export&#x2F;server&#x2F;hive&#x2F;lib</p><p>修改conf路径下的hive-site.xml</p><p>vim hive-site.xml (配置路径与mysql)</p><pre><code>&lt;configuration&gt;    &lt;!-- 存储元数据mysql相关配置 --&gt;    &lt;property&gt;        &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;        &lt;value&gt; jdbc:mysql://hadoop102:3306/hive?createDatabaseIfNotExist=true&amp;amp;useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;        &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;        &lt;value&gt;root&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;        &lt;value&gt;hadoop&lt;/value&gt;    &lt;/property&gt;    &lt;!-- H2S运行绑定host --&gt;    &lt;property&gt;        &lt;name&gt;hive.server2.thrift.bind.host&lt;/name&gt;        &lt;value&gt;hadoop102&lt;/value&gt;    &lt;/property&gt;    &lt;!-- 远程模式部署metastore 服务地址 --&gt;    &lt;property&gt;        &lt;name&gt;hive.metastore.uris&lt;/name&gt;        &lt;value&gt;thrift://hadoop102:9083&lt;/value&gt;    &lt;/property&gt;    &lt;!-- 关闭元数据存储授权  --&gt;    &lt;property&gt;        &lt;name&gt;hive.metastore.event.db.notification.api.auth&lt;/name&gt;        &lt;value&gt;false&lt;/value&gt;    &lt;/property&gt;    &lt;!-- 关闭元数据存储版本的验证 --&gt;    &lt;property&gt;        &lt;name&gt;hive.metastore.schema.verification&lt;/name&gt;        &lt;value&gt;false&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><h3 id="初始化metadata"><a href="#初始化metadata" class="headerlink" title="初始化metadata"></a>初始化metadata</h3><p>cd &#x2F;export&#x2F;server&#x2F;hive<br>bin&#x2F;schematool -initSchema -dbType mysql -verbos<br>初始化成功会在mysql中创建74张表</p><h2 id="hiveserver2"><a href="#hiveserver2" class="headerlink" title="hiveserver2"></a>hiveserver2</h2><p>Hive发展至今，总共历经了两代客户端工具。</p><ol><li><p>第一代客户端（deprecated不推荐使用）：$HIVE_HOME&#x2F;bin&#x2F;hive, 是一个 shellUtil。<br>主要功能：一是可用于以交互或批处理模式运行Hive查询；二是用于Hive相关服务的启动，比如metastore服务。</p></li><li><p>第二代客户端（recommended 推荐使用）：$HIVE_HOME&#x2F;bin&#x2F;beeline，是一个JDBC客户端，<br>是官方强烈推荐使用的Hive命令行工具，和第一代客户端相比，性能加强安全性提高。</p></li></ol><p>Q:为什么我们要使用hiveserver2？</p><p>HiveServer2支持多客户端的并发和身份认证，旨在为开放API客户端如JDBC、ODBC提供更好的支持。</p><p>HiveServer2通过Metastore服务读写元数据。所以在远程模式下，启动HiveServer2之前<strong>必须先首先启动metastore服务</strong></p><h3 id="配置bin-x2F-hive-客户端（可选）"><a href="#配置bin-x2F-hive-客户端（可选）" class="headerlink" title="配置bin&#x2F;hive 客户端（可选）"></a>配置bin&#x2F;hive 客户端（可选）</h3><p>上传hive安装包到另一个机器上，比如node3<br>cd &#x2F;export&#x2F;server&#x2F;tar zxvf apache-hive-3.1.0-bin.tar.gzmv apache-hive-3.1.0-bin hive#</p><pre><code># 解决hadoop、hive之间guava版本差异cd /export/server/hive/rm -rf lib/guava-19.0.jarcp /export/server/hadoop-3.1.3/share/hadoop/common/lib/guava-27.0-jre.jar ./lib/# 修改hive环境变量文件 添加Hadoop_HOMEcd /export/server/hive/confmv hive-env.sh.template hive-env.shvim hive-env.shexport HADOOP_HOME=/export/server/hadoop-3.1.4# 添加metastore服务地址cd /export/server/hive/conf/vim  hive-site.xml&lt;configuration&gt;&lt;property&gt;    &lt;name&gt;hive.metastore.uris&lt;/name&gt;    &lt;value&gt;thrift://hadoop102:9083&lt;/value&gt; &lt;/property&gt;  &lt;/configuration&gt;</code></pre><p>hive经过发展，推出了第二代客户端beeline，但是beeline客户端不是直接访问metastore服务的，而是需要单独启动hiveserver2服务。<br>在hive安装的服务器上，首先启动metastore服务，然后启动hiveserver2服务。</p><h2 id="hive的使用"><a href="#hive的使用" class="headerlink" title="hive的使用"></a>hive的使用</h2><p>后台挂起 可使用jps命令查看是否开启 正常的话就是runjar<br>注意hivesever2开启后要等一段时间才可以使用 </p><pre><code>nohup /export/servers/hive/bin/hive --service metastore &amp;nohup /export/servers/hive/bin/hive --service hiveserver2 &amp;</code></pre><p>cd 到hive的bin目录下</p><pre><code>! connect jdbc:hive2://hadoop:10000Enter username for jdbc:hive2://hadoop102:10000: rootEnter password for jdbc:hive2://node1:10000: Connected to: Apache Hive (version 3.1.0)</code></pre><p>创建一个数据库<br>如果可以创建则表明成功，后续自行使用idea连接hive即可</p><h3 id="一些BUG解决方案"><a href="#一些BUG解决方案" class="headerlink" title="一些BUG解决方案"></a>一些BUG解决方案</h3><ol><li>User: root is not allowed to impersonate root(state&#x3D;08S01,code&#x3D;0)<pre><code>&lt;property&gt; &lt;name&gt;hadoop.proxyuser.root.hosts&lt;/name&gt; &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hadoop.proxyuser.root.groups&lt;/name&gt; &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;</code></pre></li></ol><p>在hive的conf下修改配置文件hive-site.xml</p><pre><code>&lt;property&gt;&lt;name&gt;hive.server2.enable.doAs&lt;/name&gt;&lt;value&gt;false&lt;/value&gt;&lt;/property&gt;端口号&lt;property&gt;&lt;name&gt;hive.server2.thrift.port&lt;/name&gt;&lt;value&gt;10000&lt;/value&gt;&lt;/property&gt;</code></pre><p>hdfs dfs -chmod -R 777 &#x2F;tmp</p><ol start="2"><li>Permission denied: user&#x3D;root, access&#x3D;WRITE, inode&#x3D;”&#x2F;user”:hdfs:supergroup:drwxr-xr-x</li></ol><p>众所周知，HDFS文件系统的目录基本都属于supergroup用户组，<br>所以我们就把就把用户添加到该用户组，即可解决很多权限问题，<br>例如连接Hive却无法操作的创建库、表的问题…</p><p><strong>解决hive中root权限不能写的问题</strong></p><p>1、在Linux执行如下命令增加supergroup<br>sudo groupadd supergroup</p><p>2、将用户增加到supergroup中<br>sudo usermod -a -G supergroup root</p><p>3、同步系统的权限信息到HDFS文件系统<br>hdfs dfsadmin -refreshUserToGroupsMappings</p><p>4、查看属于supergroup用户组的用户<br>grep ‘supergroup:’ &#x2F;etc&#x2F;group</p><p>重新连接 发现问题解决！</p>]]></content>
      
      
      <categories>
          
          <category> 大数据生态圈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HIVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的基本运用</title>
      <link href="/2022/03/10/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%94%A8/"/>
      <url>/2022/03/10/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="认识单链表"><a href="#认识单链表" class="headerlink" title="认识单链表"></a>认识单链表</h1><p>单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。<br>链表中的数据是以节点来表示的，每个节点的构成：data域（数据元素）+next域（下一个结点的存储位置）。<br>单链表与数组相比的最大差别是：单链表的数据元素存放在内存空间的地址是不连续的，<br>而数组的数据元素存放的地址在内存空间中是连续的，<br>这也是为什么根据索引无法像数组那样直接就能查询到数据元素。</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/109.png" alt="109"></p><h2 id="基本操作如下"><a href="#基本操作如下" class="headerlink" title="基本操作如下"></a>基本操作如下</h2><pre><code>public class LinkList &#123;    private static final LinkNode NULL = null;private LinkNode Head = new LinkNode();//先初始化一个头结点，头结点为空    LinkList() &#123;        Init_LinkNode();&#125;//内部类节点LinkNode    class LinkNode &#123;        int data;        LinkNode next=null;        LinkNode()&#123;        &#125;        LinkNode(int elem)&#123;            data=elem;        &#125;        LinkNode(int elem,LinkNode nextval)&#123;            data=elem;            next=nextval;        &#125;        LinkNode(LinkNode nextval)&#123;            next=nextval;        &#125;    &#125;        //1.单链表的初始化    public void Init_LinkNode() &#123;        LinkNode head = null;    &#125;//2.    判断表是否为空 public boolean isEmpty() &#123;//通过判断头结点的下一结点地址是否为空，即可判断单链表是否为空        if(this.Head.next == null) &#123;           return true;         &#125;        return false;    &#125;    //3.返回单链表的长度    public int Length_LinkList() &#123;        int j=0;        LinkNode tmp=Head; //head节点不能动，需要一个tmp辅助遍历        while(tmp != null) &#123;            j++;            tmp=tmp.next;        &#125;        return j;    &#125;        //4.返回第i个元素        public LinkNode Get_LinkList(int i) &#123;            LinkNode p = Head;            int a = 0;            while (p.next != null &amp;&amp; a &lt; i) &#123;                p = p.next;                a++;            &#125;            if (a == i) &#123;                return p;            &#125; else &#123;                return null;            &#125;        &#125;       //5.删除第i个元素        public int Delete_LinkList(int i) &#123;                LinkNode p;                LinkNode s;            p=Get_LinkList(i-1);            if(p==null)&#123;                System.out.println(&quot;第i-1个结点不存在&quot;);                return -1;            &#125;else if (p.next==null)&#123;                System.out.println(&quot;第i个结点不存在&quot;);                return 0;            &#125;else&#123;                s=p.next;                p.next=s.next;                return 1;            &#125;        &#125; //6.在第i个位置插入元素        public int  Insert_LinkList(int i,int x) &#123;        LinkNode p,s;        p=Get_LinkList(i-1);            if(p==null)&#123;                System.out.println(&quot;参数i错误&quot;);                return 0;            &#125;else &#123;                s=new LinkNode();                s.data=x;                s.next=p.next;                p.next=s;                return 1;            &#125;&#125;        //7.把表中的元素打印出来            public void display()&#123;                LinkNode tmp=Head;                while (tmp!=null) &#123;                    System.out.println(tmp.data+&quot;  &quot;);                    tmp=tmp.next;                &#125;                System.out.println();            &#125;&#125;</code></pre><h1 id="顺序表与单链表的比较"><a href="#顺序表与单链表的比较" class="headerlink" title="顺序表与单链表的比较"></a>顺序表与单链表的比较</h1><h2 id="顺序表的优点："><a href="#顺序表的优点：" class="headerlink" title="顺序表的优点："></a>顺序表的优点：</h2><p>其存储结构为随机存取结构，逻辑关系可直接用数组元素下标表示。</p><h2 id="顺序表的缺点："><a href="#顺序表的缺点：" class="headerlink" title="顺序表的缺点："></a>顺序表的缺点：</h2><p>①线性表的长度不确定，难以事先确定数组长度。<br>②存储空间必须是连续的，易造成存储空间的“碎片”现象。③插入和删除操作需要移动大量元素。</p><h2 id="单链表的优点："><a href="#单链表的优点：" class="headerlink" title="单链表的优点："></a>单链表的优点：</h2><p>①元素的存储单元是任意的，可连续也可不连续。②不需要限定长度。</p><h2 id="单链表的缺点"><a href="#单链表的缺点" class="headerlink" title="单链表的缺点"></a>单链表的缺点</h2><p>：①其查找时间复杂度为O(n)。②存放元素时需要另外开辟一个指针域的空间。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
