<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hive性能优化方案</title>
      <link href="/2022/07/21/hive%E8%A1%A8%E6%95%B0%E6%8D%AE%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
      <url>/2022/07/21/hive%E8%A1%A8%E6%95%B0%E6%8D%AE%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2> <br/><h2 id="1-1-文件存储格式"><a href="#1-1-文件存储格式" class="headerlink" title="1.1 文件存储格式"></a>1.1 文件存储格式</h2><p>Hive数据存储的本质还是HDFS，所有的<strong>数据读写</strong>都基于HDFS的文件来实现，为了提高对HDFS文件读写的性能，Hive中提供了多种文件存储格式：TextFile、SequenceFile、RCFile、ORC、Parquet等。</p><p><img src="https://img-blog.csdnimg.cn/c9509edc68654948b64afb3886792c06.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6LW15bm_6ZmG,size_20,color_FFFFFF,t_70,g_se,x_16"></p><br/><h3 id="1-1-2-TextFIle"><a href="#1-1-2-TextFIle" class="headerlink" title="1.1.2 TextFIle"></a>1.1.2 TextFIle</h3><p>是Hive中默认的文件格式，存储形式为<strong>按行存储</strong>。工作中最常见的数据文件格式就是<br>TextFile文件，几乎所有的原始数据生成都是TextFile格式，所以Hive设计时考虑到为了<strong>避免各种编</strong><br><strong>码及数据错乱的问题</strong>，选用了TextFile作为默认的格式。建表时不指定存储格式即为textfile，导入<br>数据时把数据文件拷贝至hdfs不进行处理。</p><p> <strong>适合于小量数据的存储查询</strong></p><h4 id="TextFile的优点"><a href="#TextFile的优点" class="headerlink" title="TextFile的优点"></a>TextFile的优点</h4><ul><li>最简单的数据格式，不需要经过处理，可以直接cat查看</li><li>可以使用任意的分隔符进行分割</li><li>便于和其他工具（Pig, grep, sed, awk）共享数据</li><li>可以搭配Gzip、Bzip2、Snappy等压缩一起使用</li></ul><h4 id="TextFile的缺点"><a href="#TextFile的缺点" class="headerlink" title="TextFile的缺点"></a>TextFile的缺点</h4><ul><li>耗费存储空间，I&#x2F;O性能较低</li><li>结合压缩时Hive不进行数据切分合并，不能进行并行操作，查询效率低</li><li>按行存储，读取列的性能差</li></ul><br/><ul><li>TextFile的应用场景</li><li>适合于小量数据的存储查询</li><li>一般用于做第一层数据加载和测试使用</li></ul><h3 id="1-1-3-SequenceFile"><a href="#1-1-3-SequenceFile" class="headerlink" title="1.1.3  SequenceFile"></a>1.1.3  SequenceFile</h3><p>SequenceFile 是 Hadoop提供的一种对二进制文件的支持。 二进制文件直接将&lt;Key， Value&gt;对序列化到文件中。</p><p>HDFS文件系统是适合存储大文件的，很小的文件如果很多的话对于 Namenode 的压力会非常大，因为每个文件都会有一条元数据信息存储在 Namenode上， 当小文件非常多也就意味着在 Namenode上存储的元数据信息就非常多。</p><p>Hadoop是适合存储大数据的，所以我们可以通过 SequenceFile 将小文件合并起来，可以获得更高效率的存储和计算。</p><p>SequenceFile 中的 key 和 value 可以是任意类型的 Writable 或者自定义 Writable 类型。</p><p><img src="C:/Users/lyc/Desktop/1.png"></p><p><strong>适合于小量数据，但是查询列比较多的场景</strong></p> <br/><p>使用方式：在建表的时候在末行填上<strong>stored as</strong> sequencefile即可;</p><h4 id="SequenceFIle的优点"><a href="#SequenceFIle的优点" class="headerlink" title="SequenceFIle的优点"></a>SequenceFIle的优点</h4><ul><li>以二进制的KV形式存储数据，与底层交互更加友好，性能更快</li><li>可压缩、可分割，优化磁盘利用率和I&#x2F;O</li><li>可并行操作数据，查询效率高</li><li>SequenceFile也可以用于存储多个小文件</li></ul> <br/><h4 id="SequenceFIle的缺点"><a href="#SequenceFIle的缺点" class="headerlink" title="SequenceFIle的缺点"></a>SequenceFIle的缺点</h4><ul><li><p><strong>存储空间消耗最大</strong>!!</p></li><li><p>与非Hadoop生态系统之外的工具不兼容</p></li><li><p>构建SequenceFile需要通过TextFile文件转化加载。</p></li><li><p>SequenceFIle的应用</p> <br/><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><p>（读）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>shockang<span class="token punctuation">.</span>study<span class="token punctuation">.</span>bigdata<span class="token punctuation">.</span>hdfs<span class="token punctuation">.</span>sequencefile<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>fs<span class="token punctuation">.</span>FileSystem<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>fs<span class="token punctuation">.</span>Path<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOUtils<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span>SequenceFile<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Writable<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ReflectionUtils<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URI<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SequenceFileReadDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        String uri <span class="token operator">=</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        Configuration conf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        FileSystem fs <span class="token operator">=</span> FileSystem<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>URI<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">,</span> conf<span class="token punctuation">)</span><span class="token punctuation">;</span>        Path path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>        SequenceFile<span class="token punctuation">.</span>Reader reader <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SequenceFile<span class="token punctuation">.</span>Reader</span><span class="token punctuation">(</span>fs<span class="token punctuation">,</span> path<span class="token punctuation">,</span> conf<span class="token punctuation">)</span><span class="token punctuation">;</span>            Writable key <span class="token operator">=</span> <span class="token punctuation">(</span>Writable<span class="token punctuation">)</span>                    ReflectionUtils<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">getKeyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> conf<span class="token punctuation">)</span><span class="token punctuation">;</span>            Writable value <span class="token operator">=</span> <span class="token punctuation">(</span>Writable<span class="token punctuation">)</span>                    ReflectionUtils<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">getValueClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> conf<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> position <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">getPosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                String syncSeen <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">syncSeen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"*"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%s%s]\t%s\t%s\n"</span><span class="token punctuation">,</span> position<span class="token punctuation">,</span> syncSeen<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>                position <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">getPosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            IOUtils<span class="token punctuation">.</span><span class="token function">closeStream</span><span class="token punctuation">(</span>reader<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（写）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>shockang<span class="token punctuation">.</span>study<span class="token punctuation">.</span>bigdata<span class="token punctuation">.</span>hdfs<span class="token punctuation">.</span>sequencefile<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>fs<span class="token punctuation">.</span>FileSystem<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>fs<span class="token punctuation">.</span>Path<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOUtils<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IntWritable<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span>SequenceFile<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Text<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URI<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SequenceFileWriteDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> DATA <span class="token operator">=</span> <span class="token punctuation">{</span>            <span class="token string">"One, two, buckle my shoe"</span><span class="token punctuation">,</span>            <span class="token string">"Three, four, shut the door"</span><span class="token punctuation">,</span>            <span class="token string">"Five, six, pick up sticks"</span><span class="token punctuation">,</span>            <span class="token string">"Seven, eight, lay them straight"</span><span class="token punctuation">,</span>            <span class="token string">"Nine, ten, a big fat hen"</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        String uri <span class="token operator">=</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        Configuration conf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        FileSystem fs <span class="token operator">=</span> FileSystem<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>URI<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">,</span> conf<span class="token punctuation">)</span><span class="token punctuation">;</span>        Path path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>        IntWritable key <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Text value <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SequenceFile<span class="token punctuation">.</span>Writer writer <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            writer <span class="token operator">=</span> SequenceFile<span class="token punctuation">.</span><span class="token function">createWriter</span><span class="token punctuation">(</span>fs<span class="token punctuation">,</span> conf<span class="token punctuation">,</span> path<span class="token punctuation">,</span>                    key<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                key<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                value<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>DATA<span class="token punctuation">[</span>i <span class="token operator">%</span> DATA<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%s]\t%s\t%s\n"</span><span class="token punctuation">,</span> writer<span class="token punctuation">.</span><span class="token function">getLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>                writer<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            IOUtils<span class="token punctuation">.</span><span class="token function">closeStream</span><span class="token punctuation">(</span>writer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="1-1-4Parquet"><a href="#1-1-4Parquet" class="headerlink" title="1.1.4Parquet"></a>1.1.4Parquet</h3><p>Parquet是Hadoop生态圈中主流的列式存储格式，并且行业内流行这样一句话流传：如果说<br>HDFS是大数据时代文件系统的事实标准，Parquet 就是大数据时代存储格式的事实标准。Hive中<br>也同样支持使用Parquet格式来实现数据的存储，并且是工作中主要使用的存储格式之一。<br><img src="C:/Users/lyc/AppData/Roaming/Typora/typora-user-images/image-20220721162935839.png"></p><p><img src="D:/pirc/aa.png"></p><h2 id="1-2-orc格式"><a href="#1-2-orc格式" class="headerlink" title="1.2 orc格式"></a>1.2 orc格式</h2><p><strong>ORC（OptimizedRC File）</strong>文件格式也是一种Hadoop生态圈中的<strong>列式存储</strong>格式，源自于RC（RecordColumnar File），它的产生早在2013年初，最初产生自Apache Hive，用于降低Hadoop数据存储空间和加速Hive查询速度。它并不是一个单纯的列式存储格式，仍然是首先根据行组分割整个表，在每一个行组内进行<strong>按列存储</strong>。ORC文件是自描述的，它的元数据使用Protocol Buffers序列化，并且文件中的数据尽可能的压缩以降低存储空间的消耗，目前也被Hive、Spark SQL、Presto等查询引擎支持。2015年ORC项目被Apache项目基金会提升为Apache顶级项目。</p><p>ORC文件也是以二进制方式存储的，所以是不可以直接读取，ORC文件也是自解析的，它包含许多的元数据，这些元数据都是同构ProtoBuffer进行序列化的。其中涉及到如下的概念：</p><p>ORC文件：保存在文件系统上的普通二进制文件，一个ORC文件中可以包含多个stripe，每一个stripe包含多条记录，这些记录按照列进行独立存储，对应到Parquet中的row group的概念。</p><p>文件级元数据：包括文件的描述信息PostScript、文件meta信息（包括整个文件的统计信息）、所有stripe的信息和文件schema信息。</p><p>stripe：一组行形成一个stripe，每次读取文件是以行组为单位的，一般为HDFS的块大小，保存了每一列的索引和数据。</p><p>stripe元数据：保存stripe的位置、每一个列的在该stripe的统计信息以及所有的stream类型和位置。</p><p>row group：索引的最小单位，一个stripe中包含多个row group，默认为10000个值组成。</p><p>stream：一个stream表示文件中一段有效的数据，包括索引和数据两类。索引stream保存每一个row group的位置和统计信息，数据stream包括多种类型的数据，具体需要哪几种是由该列类型和编码方式决定。</p><p>ORC文件中保存了三个层级的统计信息，分别为<strong>文件级别、stripe级别和row group级别</strong>的，他们都可以用来根据Search ARGuments（谓词下推条件）判断是否可以跳过某些数据，在统计信息中都包含成员数和是否有null值，并且对于不同类型的数据设置一些特定的统计信息。</p><p>l 性能测试：</p><p>原始Text格式，未压缩 : 38.1 G</p><p>ORC格式，默认压缩（ZLIB）: 11.5 G</p><p> Parquet格式，默认压缩（Snappy）：14.8 G</p><p> 测试对比：复杂数据Join关联测试</p><p><img src="C:/Users/lyc/AppData/Roaming/Typora/typora-user-images/image-20220721163302320.png"></p><h4 id="ORC的优点"><a href="#ORC的优点" class="headerlink" title="ORC的优点"></a><strong>ORC的优点</strong></h4><p> 列式存储，存储效率非常高</p><p> 可压缩，高效的列存取</p><p> 查询效率较高，支持索引</p><p> 支持矢量化查询</p>  <br/><h4 id="ORC的缺点"><a href="#ORC的缺点" class="headerlink" title="ORC的缺点"></a><strong>ORC的缺点</strong></h4><p> 加载时性能消耗较大</p><p> 需要通过text文件转化生成</p><p> 读取全量数据时性能较差</p> <br/><h2 id="1-3-数据压缩"><a href="#1-3-数据压缩" class="headerlink" title="1.3 数据压缩"></a>1.3 数据压缩</h2><p><img src="C:/Users/lyc/AppData/Roaming/Typora/typora-user-images/image-20220721163406280.png"></p><p>要想在Hive中使用压缩，需要对MapReduce和Hive进行相应的配置</p><p>• 原始日志BZ2压缩</p><p>• MR中间输出LZO压缩</p><p>• 中间表SEQUENCEFILE、RCFILE格式</p><p><img src="C:/Users/lyc/AppData/Roaming/Typora/typora-user-images/image-20220721164754619.png"></p><h4 id="临时配置"><a href="#临时配置" class="headerlink" title="临时配置"></a>临时配置</h4><p>配置MapReduce开启输出压缩及配置压缩类型</p><p>  –开启输出压缩  </p><p><strong>set</strong>  mapreduce.output.fileoutputformat.compress&#x3D;<strong>true</strong>;  </p><p>–配置压缩类型为Snappy   </p><p><strong>set</strong> mapreduce.output.fileoutputformat.compress.codec&#x3D;org.apache.hadoop.io.compress.SnappyCodec;  </p><p>配置Hive开启中间结果压缩和输出压缩及配置压缩类型</p><p>  <em>–</em> *中间结果压缩 *  </p><p><strong>set</strong> hive.exec.compress.intermediate&#x3D;**true;   **</p><p><strong>set</strong> hive.intermediate.compression.codec&#x3D;org.apache.hadoop.io.compress.SnappyCodec; </p><p>  <em>–</em> *输出结果压缩 *</p><p><strong>set</strong> hive.exec.compress.output&#x3D;<strong>true</strong>;  </p><h4 id="永久配置"><a href="#永久配置" class="headerlink" title="永久配置"></a>永久配置</h4><p>1、将以上MapReduce的配置写入mapred-site.xml中，重启Hadoop</p><p> 2、将以上Hive的配置写入hive-site.xml中，重启Hive</p><br/><h2 id="1-4-存储优化"><a href="#1-4-存储优化" class="headerlink" title="1.4  存储优化"></a>1.4  存储优化</h2><h4 id="预处理端"><a href="#预处理端" class="headerlink" title="预处理端"></a>预处理端</h4><p>由于hdfs不利用小文件存储 每个小文件会产生一条元数据信息，每对一个小文件处理就会生成一个MapTask。需要避免这种情况发生</p><p>若默认引擎是mr 可以采取以下的解决方案</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">set</span> hive<span class="token punctuation">.</span><span class="token keyword">merge</span><span class="token punctuation">.</span>mapfiles<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">#如果hive的程序，有Map和ReduceTask,将ReduceTask产生的所有小文件进行合并</span><span class="token keyword">set</span> hive<span class="token punctuation">.</span><span class="token keyword">merge</span><span class="token punctuation">.</span>mapredfiles<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 每一个合并的文件的大小</span><span class="token keyword">set</span> hive<span class="token punctuation">.</span><span class="token keyword">merge</span><span class="token punctuation">.</span>size<span class="token punctuation">.</span>per<span class="token punctuation">.</span>task<span class="token operator">=</span><span class="token number">256000000</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">#平均每个文件的大小，如果小于这个值就会进行合并</span><span class="token keyword">set</span> hive<span class="token punctuation">.</span><span class="token keyword">merge</span><span class="token punctuation">.</span>smallfiles<span class="token punctuation">.</span>avgsize<span class="token operator">=</span><span class="token number">16000000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="读取端"><a href="#读取端" class="headerlink" title="读取端"></a>读取端</h4><pre class="line-numbers language-python"><code class="language-python">set hive<span class="token punctuation">.</span>input<span class="token punctuation">.</span>format<span class="token operator">=</span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>hive<span class="token punctuation">.</span>ql<span class="token punctuation">.</span>io<span class="token punctuation">.</span>CombineHiveInputFormat<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-5MR优化"><a href="#1-5MR优化" class="headerlink" title="1.5MR优化"></a>1.5MR优化</h2><p>Hive在实现HQL计算运行时，会解析为多个Stage，有时候Stage彼此之间有依赖关系，</p><p>只能挨个执行，但是在一些别的场景下，很多的Stage之间是没有依赖关系的，例如Union语句，</p><p>Join语句等等，这些Stage没有依赖关系，但是Hive依旧默认挨个执行每个Stage，</p><p>这样会导致性能非常差，我们可以通过修改参数，开启并行执行，当多个Stage之间没有依赖关系时</p><p>，允许多个Stage并行执行，提高性能。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 开启Stage并行化，默认为false</span><span class="token keyword">SET</span> hive<span class="token punctuation">.</span><span class="token keyword">exec</span><span class="token punctuation">.</span>parallel<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 指定并行化线程数，默认为8</span><span class="token keyword">SET</span> hive<span class="token punctuation">.</span><span class="token keyword">exec</span><span class="token punctuation">.</span>parallel<span class="token punctuation">.</span>thread<span class="token punctuation">.</span>number<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">;</span> 注意：线程数越多，程序运行速度越快，但同样更消耗CPU资源<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-5-1mapred-reduce-tasks"><a href="#1-5-1mapred-reduce-tasks" class="headerlink" title="1.5.1mapred.reduce.tasks"></a>1.5.1mapred.reduce.tasks</h4><p>直接设置 • num_reduce_tasks</p><p>大小影响参数 – hive.exec.reducers.max 默认：999 </p><p>– hive.exec.reducers.bytes.per.reducer 默认：1G • </p><p>切割算法 – numRTasks &#x3D; min[maxReducers,input.size&#x2F;perReducer] • maxReducers &#x3D; ${hive.exec.reducers.max} • perReducer &#x3D;  {hive.exec.reducers.bytes.per.reducer} </p><p>Shuffle阶段优化 • 压缩中间数据 – 减少磁盘操作 – 减少网络传输数据量 </p><p>• 配置方法  mapred.compress.map.output 设为true</p><p> – mapred.compress.output.compression.codec </p><p>• org.apache.hadoop.io.compress.LzoCodec </p><p>• org.apache.hadoop.io.compress.SnappyCodec </p><h4 id="1-5-2Shuffle参数-Map端参数"><a href="#1-5-2Shuffle参数-Map端参数" class="headerlink" title="1.5.2Shuffle参数 Map端参数"></a>1.5.2<strong>Shuffle参数 Map端参数</strong></h4><p>• io.sort.mb</p><p> • io.sort.spill.percent </p><p>• min.num.spill.for.combine</p><p> • io.sort.factor</p><p> • io.sort.record.percent Reduce端参数 </p><p>•mapred.reduce.parallel.copies </p><p>•mapred.reduce.copy.backoff </p><p>• io.sort.factor </p><p>•mapred.job.shuffle.input.buffer.percent </p><p>•mapred.job.shuffle.input.buffer.percent </p><p>•mapred.job.reduce.input.buffer.percent </p><h4 id="1-5-3map阶段优化"><a href="#1-5-3map阶段优化" class="headerlink" title="1.5.3map阶段优化"></a>1.5.3map阶段优化</h4><p>充分利用Combiner<br>Combiner在Map端提前进行了一次Reduce处理。<br>可减少Map Task中间输出的结果，从而减少各个Reduce Task的远程拷贝数据量，最终表现为Map Task和Reduce Task执行时间缩短。</p><p>选择合理的Writable类型<br>为应用程序处理的数据选择合适的Writable类型可大大提升性能。</p><p>比如处理整数类型数据时，直接采用IntWritable比先以Text类型读入在转换为整数类型要高效。</p><p>如果输出整数的大部分可用一个或两个字节保存，那么直接采用VIntWritable或者VLongWritable，它们采用了变长整型的编码方式，可以大大减少输出数据量。</p><p>增加输入文件的副本数，就是充分利用本地读<br>假设集群有1个Namenode+8个Datanode节点，HDFS默认的副本数为3 ，那么map端读取数据的时候，在启动map task的机器上读取本地的数据为3&#x2F;8，一部分数据是通过网络从其他节点拿到的<br>那么如果副本数设置为8会是什么情况？<br>相当于每个子节点上都会有一份完整的数据，map读取的时候直接从本地拿，不需要通过网络这一层了，但是在实际情况中设置副本数为8是不可行的，因为数据本身非常庞大，副本数超过5对集群的磁盘就非常有压力了，所以这项设置需要酌情处理</p><p>提前合并map小文件，减少map 数量<br>map阶段的第一步，从磁盘读取数据并切片，每个分片由一个map task处理，当输入的是海量的小文件的时候，会启动大量的map task，效率及其之慢，有效的解决方式是使用CombineInputFormat自定义分片策略对小文件进行合并处理 ，从而减少map task的数量，减少map过程使用的时间</p><p>map task的启动数量也和下面这几个参数有关系：</p><pre><code>mapred.min.split.size：Input Split的最小值 默认值1当mapred.min.split.size小于dfs.block.size的时候，一个block会被分为多个分片，也就是对应多个map task当mapred.min.split.size大于dfs.block.size的时候，一个分片可能对应多个block，也就是一个map task读取多个block数据mapred.max.split.size：Input Split的最大值dfs.block.size：HDFS 中一个block大小，默认值128MB</code></pre><p>提高block大小<br>集群的网络、IO等性能很好的时候，建议调高dfs.block.size<br>根据数据源的特性，主要调整mapred.min.split.size来控制map task的数量</p><h4 id="1-5-4提高map输出的Buffer"><a href="#1-5-4提高map输出的Buffer" class="headerlink" title="1.5.4提高map输出的Buffer"></a>1.5.4提高map输出的Buffer</h4><p>该阶段是map side中将结果输出到磁盘之前的一个处理方式，通过对其进行设置的话可以减少map任务的IO开销，从而提高性能。</p><p>由于map任务运行时中间结果首先存储在buffer中,默认当缓存的使用量达到80%的时候就开始写入磁盘,这个过程叫做spill(溢出)</p><p>这个buffer默认的大小是100M可以通过设定io.sort.mb的值来进行调整<br>当map产生的数据非常大时，如果默认的buffer大小不够看，那么势必会进行非常多次的spill，进行spill就意味着要写磁盘，产生IO开销 ，这时候就可以把io.sort.mb调大，那么map在整个计算过程中spill的次数就势必会降低，map task对磁盘的操作就会变少</p><p>如果map tasks的瓶颈在磁盘上，这样调整就会大大提高map的计算性能，但是如果将io.sort.mb调的非常大的时候，对机器的配置要求就非常高，因为占用内存过大，所以需要根据情况进行配置</p><p>map并不是要等到buffer全部写满时才进行spill，因为如果全部写满了再去写spill，势必会造成map的计算部分等待buffer释放空间的情况。</p><p>所以，map其实是当buffer被写满到一定程度（比如80%）时，才开始进行spill<br>可以通过设置io.sort.spill.percent的值来调整这个阈值</p><p>这个参数同样也是影响spill频繁程度，进而影响map task运行周期对磁盘的读写频率，但是通常情况下只需要对io.sort.mb进行调整即可</p><h4 id="1-5-5合理配置map的Merge参数"><a href="#1-5-5合理配置map的Merge参数" class="headerlink" title="1.5.5合理配置map的Merge参数"></a>1.5.5合理配置map的Merge参数</h4><p>该阶段是map产生spill之后，对spill进行处理的过程，通过对其进行配置也可以达到优化IO开销的目的，map产生spill之后必须将些spill进行合并,这个过程叫做merge ，merge过程是并行处理spill的,每次并行多少个spill是由参数io.sort.factor指定的,默认为10个，如果产生的spill非常多，merge的时候每次只能处理10个spill，那么还是会造成频繁的IO处理 ，适当的调大每次并行处理的spill数有利于减少merge数因此可以影响map的性能，但是如果调整的数值过大，并行处理spill的进程过多会对机器造成很大压力</p><p>Combine的使用策略<br>我们知道如果map side设置了Combiner，那么会根据设定的函数对map输出的数据进行一次类reduce的预处理</p><p>但是和分组、排序分组不一样的是，combine发生的阶段可能是在merge之前，也可能是在merge之后</p><p>这个时机可以由一个参数控制：min.num.spill.for.combine，默认值为3<br>当job中设定了combiner，并且spill数最少有3个的时候，那么combiner函数就会在merge产生结果文件之前运行</p><p>例如，产生的spill非常多，虽然我们可以通过merge阶段的io.sort.factor进行优化配置，但是在此之前我们还可以通过先执行combine对结果进行处理之后再对数据进行merge ，这样一来，到merge阶段的数据量将会进一步减少，IO开销也会被降到最低输出中间数据到磁盘</p><p>这个阶段是map side的最后一个步骤，在这个步骤中也可以通过压缩选项的配置来得到任务的优化</p><p>合理的开启map压缩<br>其实无论是spill的时候，还是最后merge产生的结果文件，都是可以压缩的<br>压缩的好处在于，通过压缩减少写入读出磁盘的数据量。对中间结果非常大，磁盘速度成为map执行瓶颈的job，尤其有用<br>控制输出是否使用压缩的参数是mapred.compress.map.output，值为true或者false<br>启用压缩之后，会牺牲CPU的一些计算资源，但是可以节省IO开销，非常适合IO密集型的作业（如果是CPU密集型的作业不建议设置）</p><p>设置压缩的时候，我们可以选择不同的压缩算法<br>Hadoop默认提供了GzipCodec，LzoCodec，BZip2Codec，LzmaCodec等压缩格式<br>通常来说，想要达到比较平衡的cpu和磁盘压缩比，LzoCodec比较合适，但也要取决于job的具体情况<br>如果想要自行选择中间结果的压缩算法，可以设置配置参数：<br>mapred.map.output.compression.codec&#x3D;org.apache.hadoop.io.compress.DefaultCodec</p><p>Map side tuning总结<br>map端调优的相关参数：</p><pre><code>mapred.min.split.size    int    1    Input Split的最小值mapred.max.split.size    int    -    Input Split的最大值io.sort.mb    int    100    map缓冲区大小io.sort.spill.percent    float    0.8    缓冲区阈值io.sort.factor    int    10    并行处理spill的个数min.num.spill.for.combine    int    3    最少有多少个spill的时候combine在merge之前进行mapred.compress.map.output    boolean    false    map中间数据是否采用压缩mapred.map.output.compression.codec    String    -    压缩算法</code></pre><h4 id="1-5-6Shuffle阶段优化"><a href="#1-5-6Shuffle阶段优化" class="headerlink" title="1.5.6Shuffle阶段优化"></a>1.5.6Shuffle阶段优化</h4><p>Copy数据阶段<br>由于job的每一个map都会根据reduce(n)数将数据分成map 输出结果分成n个partition，所以map的中间结果中是有可能包含每一个reduce需要处理的部分数据的</p><p>为了优化reduce的执行时间，hadoop中等第一个map结束后，所有的reduce就开始尝试从完成的map中下载该reduce对应的partition部分数据</p><p>在这个shuffle过程中，由于map的数量通常是很多个的，而每个map中又都有可能包含每个reduce所需要的数据</p><p>所以对于每个reduce来说，去各个map中拿数据也是并行的，可以通过mapred.reduce.parallel.copies这个参数来调整，默认为5</p><p>当map数量很多的时候，就可以适当调大这个值，减少shuffle过程使用的时间<br>还有一种情况是：reduce从map中拿数据的时候，有可能因为中间结果丢失、网络等其他原因导致map任务失败</p><p>而reduce不会因为map失败就永无止境的等待下去，它会尝试去别的地方获得自己的数据（这段时间失败的map可能会被重跑）</p><p>所以设置reduce获取数据的超时时间可以避免一些因为网络不好导致无法获得数据的情况</p><p>mapred.reduce.copy.backoff，默认300s<br>一般情况下不用调整这个值，因为生产环境的网络都是很流畅的</p><p>Merge阶段<br>由于reduce是并行将map结果下载到本地，所以也是需要进行merge的，所以io.sort.factor的配置选项同样会影响reduce进行merge时的行为</p><p>和map一样，reduce下载过来的数据也是存入一个buffer中而不是马上写入磁盘的，所以我们同样可以控制这个值来减少IO开销<br>控制该值的参数为：<br>mapred.job.shuffle.input.buffer.percent，默认0.7，这是一个百分比，意思是reduce的可用内存中拿出70%作为buffer存放数据</p><p>reduce的可用内存通过mapred.child.java.opts来设置，比如置为-Xmx1024m，该参数是同时设定map和reduce task的可用内存，一般为map buffer大小的两倍左右</p><p>归并排序Sort<br>sort的过程一般非常短，因为是边copy边merge边sort的，后面就直接进入真正的reduce计算阶段了</p><p>Reduce<br>之前我们说过reduc端的buffer，默认情况下，数据达到一个阈值的时候，buffer中的数据就会写入磁盘，然后reduce会从磁盘中获得所有的数据</p><p>也就是说，buffer和reduce是没有直接关联的，中间多个一个写磁盘-&gt;读磁盘的过程，既然有这个弊端，那么就可以通过参数来配置<br>使得buffer中的一部分数据可以直接输送到reduce，从而减少IO开销：mapred.job.reduce.input.buffer.percent，默认为0.0</p><p>当值大于0的时候，会保留指定比例的内存读buffer中的数据直接拿给reduce使用<br>这样一来，设置buffer需要内存，读取数据需要内存，reduce计算也要内存，所以要根据作业的运行情况进行调整</p><p>reduce调优主要参数：</p><pre><code>mapred.reduce.parallel.copies    int    5    每个reduce去map中拿数据的并行数mapred.reduce.copy.backoff    int    300    获取map数据最大超时时间mapred.job.shuffle.input.buffer.percent    float    0.7    buffer大小占reduce可用内存的比例mapred.child.java.opts    String    -    -Xmx1024m设置reduce可用内存为1gmapred.job.shuffle.merge.percent    float    0.66    buffer中的数据达到多少比例开始写入磁盘mapred.job.reduce.input.buffer.percent    float    0.0    指定多少比例的内存用来存放buffer中的数据</code></pre><h2 id="1-6join优化"><a href="#1-6join优化" class="headerlink" title="1.6join优化"></a>1.6join优化</h2><h4 id="1-6-1-Reduce-Join"><a href="#1-6-1-Reduce-Join" class="headerlink" title="1.6.1 Reduce Join"></a>1.6.1 Reduce Join</h4><p> 应用场景</p><p>适合于大表Join大表</p><p><img src="C:/Users/lyc/AppData/Roaming/Typora/typora-user-images/image-20220721165442871.png"></p><p><strong>原理</strong>                     </p><p> 将两张表的数据在shuffle阶段利用shuffle的分组来将数据按照关联字段进行合并</p><p> 必须经过shuffle，利用Shuffle过程中的分组来实现关联l<strong>使用</strong></p><p> Hive会自动判断是否满足Map Join，如果不满足Map Join，则自动执行Reduce Join</p> <br/><h4 id="1-6-2-Bucket-Join"><a href="#1-6-2-Bucket-Join" class="headerlink" title="1.6.2  Bucket Join"></a>1.6.2  Bucket Join</h4><p> 将两张表按照相同的规则将数据划分，根据对应的规则的数据进行join，减少了比较次数，提高了性能</p><p> <strong>使用</strong></p><p><strong>Bucket Join</strong></p><p><img src="C:/Users/lyc/AppData/Roaming/Typora/typora-user-images/image-20220721165504304.png"></p><p><strong>clustered by colName</strong></p><p>  <em>–</em> <em>开启分桶join</em>**   set** hive.optimize.bucketmapjoin &#x3D; <strong>true</strong>;  </p><p>分桶字段 &#x3D; Join字段 ，桶的个数相等或者成倍数</p><p><strong>Sort Merge Bucket Join（SMB）</strong>：基于有序的数据Join</p><p><strong>clustered by colName sorted by (colName)</strong></p><pre class="line-numbers language-sql"><code class="language-sql"> <span class="token comment" spellcheck="true">--开启分桶SMB join  </span><span class="token keyword">set</span> hive<span class="token punctuation">.</span><span class="token keyword">optimize</span><span class="token punctuation">.</span>bucketmapjoin <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">set</span> hive<span class="token punctuation">.</span>auto<span class="token punctuation">.</span><span class="token keyword">convert</span><span class="token punctuation">.</span>sortmerge<span class="token punctuation">.</span><span class="token keyword">join</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>   <span class="token keyword">set</span> hive<span class="token punctuation">.</span><span class="token keyword">optimize</span><span class="token punctuation">.</span>bucketmapjoin<span class="token punctuation">.</span>sortedmerge  <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">set</span> hive<span class="token punctuation">.</span>auto<span class="token punctuation">.</span><span class="token keyword">convert</span><span class="token punctuation">.</span>sortmerge<span class="token punctuation">.</span><span class="token keyword">join</span><span class="token punctuation">.</span>noconditionaltask<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>满足条件</p><p>分桶字段 &#x3D; Join字段 &#x3D; 排序字段 ，桶的个数相等或者成倍数</p><h2 id="1-7优化器"><a href="#1-7优化器" class="headerlink" title="1.7优化器"></a>1.7优化器</h2><h4 id="1-7-1关联优化"><a href="#1-7-1关联优化" class="headerlink" title="1.7.1关联优化"></a>1.7.1关联优化</h4><p>在使用Hive的过程中经常会遇到一些特殊的问题，例如当一个程序中如果有一些操作彼此之间有关联性，</p><p>是可以放在一个MapReduce中实现的，但是Hive会不智能的选择，Hive会使用两个MapReduce来完成这两个操作。</p><p>例如：当我们执行以下SQL语句：</p><p>select …… from table group by id order by id desc;</p><p>​     该SQL语句转换为MapReduce时，我们可以有两种方案来实现：</p><ul><li><strong>方案一</strong></li></ul><p>第一个MapReduce做group by，经过shuffle阶段对id做分组</p><p> 第二个MapReduce对第一个MapReduce的结果做order by，经过shuffle阶段对id进行排序</p><ul><li><strong>方案二</strong></li></ul><p> 因为都是对id处理，可以使用一个MapReduce的shuffle既可以做分组也可以排序</p><p>在这种场景下，Hive会默认选择用第一种方案来实现，这样会导致性能相对较差，</p><p>我们可以在Hive中开启关联优化，对有关联关系的操作进行解析时，可以尽量放在同一个MapReduce中实现。</p><p><strong>配置</strong></p><pre class="line-numbers language-sql"><code class="language-sql">  <span class="token keyword">set</span> hive<span class="token punctuation">.</span><span class="token keyword">optimize</span><span class="token punctuation">.</span>correlation<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-7-2-CBO优化器引擎"><a href="#1-7-2-CBO优化器引擎" class="headerlink" title="1.7.2  CBO优化器引擎"></a>1.7.2  CBO优化器引擎</h4><p>  在使用MySQL或者Hive等工具时，我们经常会遇到一个问题，默认的优化器在底层解析一些聚合统计类的处理的时候，</p><p>底层解析的方案有时候不是最佳的方案。</p><br/><p>例如：当前有一张表【共1000条数据】，id构建了索引，id &#x3D;100值有900条，我们现在的需求是查</p><p>询所有id &#x3D; 100的数据，所以SQL语句为：select * from table where id &#x3D; 100;</p><br/><p>由于id这一列构建了索引，索引默认的优化器引擎RBO，会选择先从索引中查询id &#x3D; 100的值所在的</p><p>位置，再根据索引记录位置去读取对应的数据，但是这并不是最佳的执行方案。有id&#x3D;100的值有900条，</p><p>占了总数据的90%，这时候是没有必要检索索引以后再检索数据的，可以直接检索数据返回，这样的效率会更高，更节省资源，这</p><p>种方式就是CBO优化器引擎会选择的方案。使用Hive时，Hive中也支持RBO与CBO这两种引擎，默</p><p>认使用的是RBO优化器引擎。</p><p>l <strong>RBO</strong></p><p>n rule basic optimise：基于规则的优化器</p><p>n 根据设定好的规则来对程序进行优化</p><p>l <strong>CBO</strong></p><p>n cost basic optimise：基于代价的优化器</p><p>n 根据不同场景所需要付出的代价来合适选择优化的方案</p><p>n 对数据的分布的信息【数值出现的次数，条数，分布】来综合判断用哪种处理的方案是最佳方案</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">set</span> hive<span class="token punctuation">.</span>cbo<span class="token punctuation">.</span><span class="token keyword">enable</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">set</span> hive<span class="token punctuation">.</span><span class="token keyword">compute</span><span class="token punctuation">.</span>query<span class="token punctuation">.</span><span class="token keyword">using</span><span class="token punctuation">.</span>stats<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">set</span> hive<span class="token punctuation">.</span>stats<span class="token punctuation">.</span><span class="token keyword">fetch</span><span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">.</span>stats<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">set</span> hive<span class="token punctuation">.</span>stats<span class="token punctuation">.</span><span class="token keyword">fetch</span><span class="token punctuation">.</span><span class="token keyword">partition</span><span class="token punctuation">.</span>stats<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>满足条件</strong></p><p>要想使用CBO引擎，必须构建数据的元数据【表行数、列的信息、分区的信息……】</p><p>提前获取这些信息，CBO才能基于代价选择合适的处理计划</p><p>所以CBO引擎一般搭配analyze分析优化器一起使用</p><h4 id="1-7-3-Analyze分析优化器"><a href="#1-7-3-Analyze分析优化器" class="headerlink" title="1.7.3  Analyze分析优化器"></a>1.7.3  Analyze分析优化器</h4><p>l功能</p><p>用于提前运行一个MapReduce程序将表或者分区的信息构建一些</p><p>元数据【表的信息、分区信息、列的信息】，搭配CBO引擎一起使用</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 构建分区信息元数据</span><span class="token keyword">ANALYZE</span> <span class="token keyword">TABLE</span> tablename  <span class="token punctuation">[</span><span class="token keyword">PARTITION</span><span class="token punctuation">(</span>partcol1<span class="token punctuation">[</span><span class="token operator">=</span>val1<span class="token punctuation">]</span><span class="token punctuation">,</span> partcol2<span class="token punctuation">[</span><span class="token operator">=</span>val2<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token keyword">COMPUTE</span> <span class="token keyword">STATISTICS</span> <span class="token punctuation">[</span>noscan<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 构建列的元数据</span><span class="token keyword">ANALYZE</span> <span class="token keyword">TABLE</span> tablename  <span class="token punctuation">[</span><span class="token keyword">PARTITION</span><span class="token punctuation">(</span>partcol1<span class="token punctuation">[</span><span class="token operator">=</span>val1<span class="token punctuation">]</span><span class="token punctuation">,</span> partcol2<span class="token punctuation">[</span><span class="token operator">=</span>val2<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token keyword">COMPUTE</span> <span class="token keyword">STATISTICS</span> <span class="token keyword">FOR</span> <span class="token keyword">COLUMNS</span> <span class="token punctuation">(</span> <span class="token keyword">columns</span> name1<span class="token punctuation">,</span> <span class="token keyword">columns</span> name2<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>noscan<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 查看元数据</span><span class="token keyword">DESC</span> FORMATTED <span class="token punctuation">[</span>tablename<span class="token punctuation">]</span> <span class="token punctuation">[</span>columnname<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> HIVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全排列</title>
      <link href="/2022/07/19/%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2022/07/19/%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,1,2]<br>输出：<br>[[1,1,2],<br> [1,2,1],<br> [2,1,1]]<br>示例 2：</p><p>输入：nums &#x3D; [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p><p><strong>解题思路：去重一定要对元素进行排序，这样才能通过相邻节点来判断是否重复使用过</strong><br>class Solution {<br>    &#x2F;&#x2F;存放结果<br>    List&lt;List<Integer>&gt; result &#x3D; new ArrayList&lt;&gt;();<br>    &#x2F;&#x2F;暂存结果<br>    List<Integer> path &#x3D; new ArrayList&lt;&gt;();</p><pre><code>public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;    boolean[] used = new boolean[nums.length];    Arrays.fill(used, false);    Arrays.sort(nums);    backTrack(nums, used);    return result;&#125;private void backTrack(int[] nums, boolean[] used) &#123;    if (path.size() == nums.length) &#123;        result.add(new ArrayList&lt;&gt;(path));        return;    &#125;    for (int i = 0; i &lt; nums.length; i++) &#123;        // used[i - 1] == true，说明同⼀树⽀nums[i - 1]使⽤过        // used[i - 1] == false，说明同⼀树层nums[i - 1]使⽤过        // 如果同⼀树层nums[i - 1]使⽤过则直接跳过        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == false) &#123;            continue;        &#125;        //如果同⼀树⽀nums[i]没使⽤过开始处理        if (used[i] == false) &#123;            used[i] = true;//标记同⼀树⽀nums[i]使⽤过，防止同一树支重复使用            path.add(nums[i]);            backTrack(nums, used);            path.remove(path.size() - 1);//回溯，说明同⼀树层nums[i]使⽤过，防止下一树层重复            used[i] = false;//回溯        &#125;    &#125;&#125;</code></pre><p>}</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive中的随机抽样函数详解</title>
      <link href="/2022/07/08/Hive%E4%B8%AD%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%8A%BD%E6%A0%B7%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/07/08/Hive%E4%B8%AD%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%8A%BD%E6%A0%B7%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="抽样函数"><a href="#抽样函数" class="headerlink" title="抽样函数"></a>抽样函数</h1><p>前言</p><p>当数据量特别大时，对全体数据进行处理存在困难时，抽样就显得尤其重要了。抽样可以从被抽取的数据中估计和推断出整体的特性，是科学实验、质量检验、社会调查普遍采用的一种经济有效的工作和研究方法。</p><p><strong><br/></strong></p><p>Hive提供了数据取样（SAMPLING）的功能，能够根据一定的规则进行数据抽样，目前支持数据块抽样，分桶抽样和随机抽样，下面结合具体例子分别学习</p><h3 id="1-rand（）函数"><a href="#1-rand（）函数" class="headerlink" title="1.rand（）函数"></a>1.rand（）函数</h3><p>rand函数前的distribute和sort关键字可以保证数据在mapper和reducer阶段是随机分布的，</p><p>因为order by 是全局的，所以可以做到<strong>随机抽样</strong></p><p>目的:可以提供真正的随机抽样用limit限制返回的条数，但是需要在单个 reducer 中进行总排序</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><ul><li><p>DISTRIBUTE BY rand() SORT BY rand()</p></li><li><p>ORDER BY rand() </p></li><li><p>cluster by rand()</p></li></ul><p>但是缺点是执行效率太低了</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> studentDISTRIBUTE <span class="token keyword">BY</span> rand<span class="token punctuation">(</span><span class="token punctuation">)</span> SORT <span class="token keyword">BY</span> rand<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">LIMIT</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> rand<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">LIMIT</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> studentcluster <span class="token keyword">by</span>  rand<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">LIMIT</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="2-数据块取样（Block-Sampling）"><a href="#2-数据块取样（Block-Sampling）" class="headerlink" title="2.数据块取样（Block Sampling）"></a>2.<strong>数据块取样（Block Sampling）</strong></h3><p><strong>根据行，百分比，数据大小来抽</strong></p><p>优点：速度快。<br>缺点：<strong>不随机</strong>，该方法实际上是按照文件中的顺序返回数据，对分区表从头开始抽取，可能造成只有前面几个分区的数据。如下：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">---block抽样</span><span class="token comment" spellcheck="true">--根据行数抽样</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student TABLESAMPLE<span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">ROWS</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">--根据数据大小百分比抽样</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student TABLESAMPLE<span class="token punctuation">(</span><span class="token number">50</span> <span class="token keyword">PERCENT</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">--根据数据大小抽样</span><span class="token comment" spellcheck="true">--支持数据单位 b/B, k/K, m/M, g/G</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student TABLESAMPLE<span class="token punctuation">(</span>1k<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="3-分桶表取样（Sampling-Bucketized-Table）"><a href="#3-分桶表取样（Sampling-Bucketized-Table）" class="headerlink" title="3.分桶表取样（Sampling Bucketized Table）"></a>3.分桶表取样（Sampling Bucketized Table）</h3><p> 实现原理：Hive中的分桶表（Bucket Table），根据某一个字段Hash取模，放入指定数据的桶中，比如将表table1按照ID分成100个桶，其算法是hash(id) % 100，这样，hash(id) % 100 &#x3D; 0的数据被放到第一个桶中，hash(id) % 100 &#x3D; 1的记录被放到第二个桶中。</p><p>优点：<strong>随机</strong>，测试发现，速度比的rand()快。</p><p>不一定非要分桶表才可以实现哦</p><p>该sql语句表示将表table1随机分成10个桶，抽样第一个桶的数据，出来的结果基本上是原表的十分之一，</p><p>注意：这个结果每次运行是不一样的，是按照随机数进行分桶取样的</p><pre class="line-numbers language-sql"><code class="language-sql">table_sample: TABLESAMPLE <span class="token punctuation">(</span>BUCKET x <span class="token keyword">OUT</span> <span class="token keyword">OF</span> y <span class="token punctuation">[</span><span class="token keyword">ON</span> colname<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">SELECT</span> <span class="token function">count</span><span class="token punctuation">(</span>county<span class="token punctuation">)</span> <span class="token keyword">FROM</span> t_usa_covid19_bucket TABLESAMPLE<span class="token punctuation">(</span>BUCKET <span class="token number">1</span> <span class="token keyword">OUT</span> <span class="token keyword">OF</span> <span class="token number">10</span> <span class="token keyword">ON</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> HIVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的锁机制</title>
      <link href="/2022/07/06/mysql%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/07/06/mysql%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h1><p>并发事务访问，分为以下几种</p><p>1.读-读 允许</p><p>2.写-写 对相同的数据进行写入 可能出现脏写</p><p>一条事务加一个锁？ 三个事务开三把锁 等待执行is_waitting </p><p>如果为true 就让下一个事务等它执行完再继续执行操作。</p><p>3.读-写</p><p>脏读，不可重复读，幻读</p><p>脏读</p><p>指事务A读取到了事务B更新了但是未提交的数据，然后事务B由于某种错误发生回滚，那么事务A读取到的就是脏数据。</p><p><strong>举个例子</strong> </p><p>我查要这个人的salary原本应该是10000，记为线程A(read)，另一个线程B（write)在这个线程A之前 把salary修改了5000，此时事务还未提交，还没来得及进行回滚，然后我就查到了线程B的数据 5000。 结果线程B内部错误，导致整个事务回滚，回溯到10000。线程A继续执行命令 将这个人的脏读的salary加上10000</p><p>脏读的数据：5000+10000</p><p>实际的应该的数据：10000+10000</p><p>不可重复读</p><p>两次读发现结果不一样。线程A最开始查一次 中间插进来一个线程B 直接把你查的东西改掉，可能是木马病毒，导致你这个任务最后再读的时候发现这个查的和第一次不一样。</p><p>幻读：</p><p>两次读发现结果多了几条。直接将你查的东西数据乱插入几条。导致你这个任务最后再读的时候发现这个查的和第一次不一样。</p><p>并发问题解决方案1：MVCC </p><p>MVCC生成一个ReadView 读操作只能查到ReadView生成之前已提交事务所做的更改 未提交的事务都是看不到的，写操作枷锁</p><p>ReadView的存在保证了事务不可以读取到未提交的事务所做的更改。</p><p>并发问题解决方案2：读写都加锁</p><p>性能：w，r 彼此不冲突。MVCC方案效率高</p><p>MYSQL:</p><p>1.对数据的操作类型进行划分</p><p>读锁&#x2F;写锁 通常被称为共享锁&#x2F;排他锁 S锁 X锁</p><p>旧版本加S锁 SELECT….. LOCK IN SHARE MODE</p><p>8.0       FOR SHARE</p><p>X锁 FOR UPDATE</p><h2 id="1-表锁"><a href="#1-表锁" class="headerlink" title="1.表锁"></a>1.表锁</h2><p>S锁  X锁</p><p>对某个表进行增删改查的时候 innodb存储引擎是不会为这个表上锁的</p><p>当如果在其他线程中又想来执行DDL语句也会发生阻塞 SELECT、INSERT、DELETE、UPDATE</p><p>也会统统阻塞</p><p>LOCK TABLES t READ ：InnoDB存储引擎会对表 t 加表级别的 S锁 。 </p><p>LOCK TABLES t WRITE ：InnoDB存储引擎会对表 t 加表级别的 X锁 。</p><p>InnoDB的厉害之处还是实现了更细粒度的 行锁 表锁不推荐使用</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/025sn2_SetwD85riH8hH7FYo2_u46cCMjweYHqtfi48.png" alt="img"></p><p>Innodb支持多粒度锁，允许行锁和表锁共存，意向锁就是其中的一种</p><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>意义： </p><p>当我们向一张表加入表级锁的时候，这时候我们必须去表中每一行去遍历，看看对应的行是否已经用到对应的锁，这时候如果数据库中的数据海量的话，想要完成这个认为的难度就非常的大，难道没有一个好的方法？</p><p>如果另一个任务试图在该表级别上应用共享或排它锁，则受到由第一个任务控制的表级别意向锁的阻塞。第二个任务在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。</p><p>意向共享锁（intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁）</p><p>SELECT column FROM table … FOR UPDATE;</p><p>意向排他锁（intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁）</p><p>SELECT column FROM table … FOR UPDATE;</p><p>DBA对某行上X锁 那么InooDB就会为这个表上IX锁 </p><p>由于意向锁是由InooDB维护的，我们并不能去更改它</p><p>并发性：</p><p>意向锁不会与行级的共享 &#x2F; 排他锁互斥！正因为如此，意向锁并不会影响到多个事务对不同数据行加排 他锁时的并发性。</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/lcM5HW2AMERlh9pf97RN1dPFryG11KHGsCexUXhk0Yw.png" alt="img"></p><p>从上图我们可以看见</p><p>提示：如果我们对表加锁，机器是不知道你哪行是上了锁的 ！！它只能从头到尾遍历 效率极低</p><p>才引出意向锁</p><p>第一种情况 事务A 查询id &#x3D;5 并上S锁。事务B 也查询id&#x3D;6 并上X锁 是被允许的</p><p>(X1) IX  (X2) IX 都不冲突</p><p>那么事务A、B同时修改你这条记录呢？ 那么就跟你这个意向锁没什么关系 直接被行X锁 X锁之间阻塞了</p><p>第二种情况流程：<br>事务A在执行 对某行进行查询并上了X锁 默认表就会有一个意向排他锁IX  </p><p>事务B插进来 想要将表上X锁 首先它要拿到这个表的IX锁 才可以上锁</p><p>但是IX锁还在事务A中 事务B就抢不过来 就没有权限，直接阻塞。</p><p>等你A执行完 然后执行B </p><p>commit提交后事务结束 就释放这个锁</p><h4 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h4><p>插入数据的三种模式</p><p>简单操作</p><p>AUTO-INC:就是可以不用对其进行赋值操作 自增</p><ol><li><p>“Simple inserts” （简单插入） 可以 预先确定要插入的行数 （当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行 INSERT…VALUES() 和 REPLACE 语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行 数。</p></li><li><p>“Bulk inserts” （批量插入） 事先不知道要插入的行数 （和所需自动递增值的数量）的语句。比如 INSERT … SELECT ， REPLACE … SELECT 和 LOAD DATA 语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列 分配一个新值。</p></li><li><p>“Mixed-mode inserts” （混合模式插入） 这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如 INSERT INTO teacher (id,name) VALUES (1,’a’), (NULL,’b’), (5,’c’), (NULL,’d’); 只是指定了部分id的值。</p></li></ol><p>所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有 AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个 表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证 master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的 时候，对于AUTO-INC锁的争夺会 限制并发 能力。 </p><p>（2）innodb_autoinc_lock_mode &#x3D; 1(“连续”锁定模式) 在 MySQL 8.0 之前，连续锁定模式是 默认 的。 在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT … SELECT，REPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。 对于“Simple inserts”（要插入的行数事先已知），则通过在 mutex（轻量锁） 的控制下获得所需数量的 自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用 表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。</p><p> （3）innodb_autoinc_lock_mode &#x3D; 2(“交错”锁定模式) 从 MySQL 8.0 开始，交错锁模式是 默认 设置。 在此锁定模式下，自动递增值 保证 在所有并发执行的所有类型的insert语句中是 唯一 且 单调递增 的。但 是，由于多个语句可以同时生成数字（即，跨语句交叉编号），为任何给定语句插入的行生成的值可能 不是连续的。</p><p>④ 元数据锁（MDL锁）（表级别 自动的）</p><p>mysql5.5版本后</p><p>当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写 锁。</p><p>x s x x s x 互斥 排队等待</p><p>自动的加锁</p><h2 id="2-行锁"><a href="#2-行锁" class="headerlink" title="2.行锁"></a>2.行锁</h2><p>三、行级锁</p><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p><p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。</p><p>对于行级锁，主要分为以下三类：</p><ol><li><p>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</p></li><li><p>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</p></li><li><p>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</p></li></ol><p>优点：锁定力度小，发生的冲突概率低，可以实现的并发度高</p><p>缺点：对于锁的开销比较大，加锁会比较慢，容易出现死锁的情况</p><p>临键锁：</p><p>临键锁可以理解为锁住的是索引本身以及索引之前的间隙，是一个左开右闭的区间。当 SQL 执行按照<strong>非唯一索引</strong>进行数据的检索时，会给匹配到行上加上临键锁。</p><p>就是说 MySQL 默认隔离级别是RR，在这种级别下，如果你使用 select in share mode 或者 select for update 语句，那么InnoDB会使用临键锁(记录锁 + 间隙锁)，因而可以防止幻读；</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql中的表空间</title>
      <link href="/2022/06/18/mysql%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4/"/>
      <url>/2022/06/18/mysql%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql表空间"><a href="#mysql表空间" class="headerlink" title="mysql表空间"></a>mysql表空间</h1><p>查看是否开启：show variables like ‘%innodb_file_per_table%’ ;</p><p>SHOW VARIABLES LIKE ‘datadir’;</p><p>0 代表系统 1代表独立</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/SO6Ld1GtjHNlSJIV-bQF-YPiXg71ITxP7Wmk0qi8tVw.png"></p><h3 id="1-独立表空间"><a href="#1-独立表空间" class="headerlink" title="1. 独立表空间"></a>1. 独立表空间</h3><p>底层的存储是怎么存储的？那么多表mysql是如何管理和维护数据和索引的？那么要搞清楚这个概念，你需要知道的是表空间的相关知识。</p><p>对于 InnoDB 存储引擎，它可以将每张表存放于独立的表空间（1-&gt;1），即 <code>tablename.ibd</code> 文件；也可以将数据存放于 <code>ibdata</code> 的共享表空间，一般命名是 <code>ibdataX</code>，后面的 X 是一个具体的数字。</p><ul><li><strong>需要注意的是，**<strong>innodb_file_per_table</strong></strong> 要在创建表之前修改，创建表之后再去修改，是不会影响已有的表结构。**</li><li>每张表的数据和索引都会存储在自己的表空间中。</li></ul><ol><li>可以实现单表在不同的数据库中移动（因为每张表都有独立的数据表文件）。</li><li>空间可以回收（通过 optimize table 等命令实现）。</li></ol><h2 id="2-系统表空间"><a href="#2-系统表空间" class="headerlink" title="2.系统表空间"></a>2.系统表空间</h2><p>默认情况下，InnoDB会在数据目录下创建一个名为 ibdata1 、大小为 12M 的文件，这个文件就是对应</p><p>的 系统表空间 在文件系统上的表示。怎么才12M？注意这个文件是 自扩展文件 ，当不够用的时候它会自己增加文件大小。</p><h2 id="3-版本变动"><a href="#3-版本变动" class="headerlink" title="3.版本变动"></a>3.版本变动</h2><p>在MySQL5.6.6以及之后的版本中，innodb为每一个表建立一个独立表空间 ，也就是说我们创建了多少个表，就有多少个独立表空间。使用 独立表空间 来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同，只不过添加了一个 .ibd 的扩展名而已。</p><p>MySQL5.7 中会在data&#x2F;a的目录下生成 db.opt 文件用于保存数据库的相关配置</p><p>在8.0中 frm 和 ibd -&gt; ibd  db.opt也不再提供</p><p>扩展：</p><p>如果采取MyISAM引擎 ，data\a中会产生3个文件：</p><p>MySQL5.7 中： b.frm ：描述表结构文件，字段长度等。</p><p>MySQL8.0 中 b.xxx.sdi ：描述表结构文件，字段长度等</p><p>b.MYD (MYData)：数据信息文件，存储数据信息(如果采用独立表存储模式)</p><p>b.MYI (MYIndex)：存放索引信息文件</p><h2 id="4-共享表空间和独立表空间的优缺点"><a href="#4-共享表空间和独立表空间的优缺点" class="headerlink" title="4.共享表空间和独立表空间的优缺点"></a>4.共享表空间和独立表空间的优缺点</h2><p>共享表空间<br>Innodb的所有数据保存在一个单独的表空间里面，共享表空间可以由多个文件组成，当表使用共享表空间时，表数据可以分布在多个文件中，从而不受Innodb单表不超过64TB的限制。<br>默认的共享表空间的文件路径在data目录下，默认文件名为ibdata1，初始化为10M。</p><p>优点：<br>可以放表空间分成多个文件存放到各个磁盘上，没有单表不超过64TB的限制。</p><p>缺点：<br>由于多表共用一个共享表空间，当某些表进行大量删除后，共享表空间存在大量碎片，但MySQL暂未提供对共享表空间收缩的方法。<br>表空间中的空间只能被这个表使用<br>fsync操作必须在每个表上都运行一遍<br>mysqld必须保持一个打开的文件句柄，表太多会影响性能。(消耗很多 fd)</p><p>通过innodb_file_per_table参数将innodb表的数据和索引存放到其自己的表空间中，不再使用共享表空间，独立表空间的默认目录为innodb_data_file<br>独立表空间<br>优点：<br>1、 每个表有自己独立的表空间，数据和索引存放到其独立的表空间中。<br>2、可以轻松实现表在不同数据库之间移动<br>3、DROP TABLE后，表使用的空间立即被释放<br>4、当表中数据被大量删除后，可以使用alter table TableName engine&#x3D;innodb;来进行收缩<br>5、表空间存在碎片时不会影响其他表的使用。</p><p>缺点：<br>1、使用独立表空间后，无法再将表数据分散到不同的多个文件中，如果单个存储无法提供该表所需的全部空间时，无法通过增加新存储来解决<br>2、innodb_file_per_table开启后，不会影响已经使用共享表空间的表。<br>3、单表数据较大时，导致其对于的数据文件过大而不利于维护</p><h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p>系统表空间<br>使用系统表空间的话，会在该表所在数据库对应的子目录下创建一个名为”表名.frm”的文件，表中的数据会存储在对应的文件中。</p><p>独立表空间<br>会在该表所在数据库对应的子目录下创建一个名为”表名.frm”和一个名为”表名.ibd”的文件，表中的数据会存储在这个ibd的文件中。8.0只有ibd 默认独立</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/SUDMhXOXWIhr6oebk0RvPtICdaepVV4TXzA7J77UACs.png"></p><p>Q:有什么用？为什么要提出namespace的概念？</p><p>对于<code>InnoDB</code>存储引擎来说，每一个<a href="https://so.csdn.net/so/search?q=%E8%A1%A8%E7%A9%BA%E9%97%B4&spm=1001.2101.3001.7020">表空间</a>可被划分成很多个页，表数据存放在表空间下的某些页中。表空间分为几种不同的类型。</p><p>这里谈到了区和段的概念</p><h3 id="区"><a href="#区" class="headerlink" title="区"></a>区</h3><p>表空间中的页实在是太多了，为了更好的管理这些页面，所以提出了区（extent）的概念。对于16KB的页来说，<strong>连续的64个页就是一个区</strong>，也就是说一个区默认占用1MB的空间。无论是系统表空间还是独立表空间，都可以看作由若干个连续的区组成，每256个区被划分为一组。</p><p>其中extent0-extent255为一组，extent256-extent511为一组，依此类推，可以划分更多的组。</p><ul><li>FREE-空闲的区</li><li>FREE_FRAG-有剩余空闲页面的碎片区</li><li>FULL_FRAG-没有剩余空闲页面的碎片区</li><li>FSEG-附属某个段的区</li></ul><h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><p>段是一些零散页的页面以及一些完整的区的集合。</p><p>为了尽量使用顺序I&#x2F;O，提升磁盘的性能，作者不仅提出了区的概念，有提出了段的概念。上面说的256个区为一个组，其实这个组就是段。 每一个索引都对应2个段，一个叶子节点段，一个非叶子节点段。</p><h3 id="组"><a href="#组" class="headerlink" title="组"></a>组</h3><ul><li>每256个区分为一组</li><li>每个组的最开始的几个页面类型是固定的</li></ul><p>我们每向表中插入一条记录，本质上就是向该表的聚簇索引以及所有二级索引代表的B+树的节点中插入数据。而B+树每一层中的页都会形成一个双向链表，如果以页尾单位来分配存储空间，双向链表相邻的两个页之间的物理位置可能离的非常远。前面提到使用B+树来减少存储记录的扫描行数的过程是通过一些搜索条件到B+树的叶子节点中定位到第一条符合该条件的记录，然后沿着由该记录组成的单向链表以及数据页组成的双向链表一直向后扫描就可以了。</p><p>如果双向链表中相邻的两个页的物理位置不连续，对于传统的机械硬盘来说，需要重新定位磁头位置，也就是会产生随机I&#x2F;O，这样会影响磁盘的性能，所以我们应该尽量让页面链表中相邻的页的物理位置页尽量相邻，这样在扫描叶子节点中大量的记录时才可以使用顺序I&#x2F;O。</p><p>所以才引入了区的概念，一个区就是在物理位置上连续的64个页。在表中的数据量很大时，为某个索引分配空间的时候就不再按照页尾单位分配了。而是按照区为单位进行分配。甚至在表中的数据非常非常多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费，但是可以消除很多随机I&#x2F;O。</p><p>我们在使用B+树执行查询时，只是在扫描叶子节点的记录，如果不区分叶子节点和非叶子节点，而是统统把节点代表的页面放到申请到的区里，扫描效果就大打折扣了，所以这里对叶子节点和非叶子节点进行了区分，也就是说，叶子节点和非叶子节点都有自己独立的区。存放叶子节点的区的集合就是一个段（segment），存放非叶子节点的区的集合也是一个段。也就是说一个索引会生成两个段，一个叶子节点段，一个非叶子节点段。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql8.0的新特性-窗口函数</title>
      <link href="/2022/06/13/mysql8-0%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/"/>
      <url>/2022/06/13/mysql8-0%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h1><h4 id="1-1简介"><a href="#1-1简介" class="headerlink" title="1.1简介"></a>1.1简介</h4><p>窗口函数可以分为</p><p><strong>静态、动态</strong></p><p>静态窗口函数的窗口大小是固定的, 不会因为记录的不同而不同;</p><p>动态窗口函数的窗口大小会随着记录的不同而变化;优点：减少了重复繁琐的子查</p><h4 id="1-2语法结构"><a href="#1-2语法结构" class="headerlink" title="1.2语法结构"></a>1.2语法结构</h4><p>OVER 关键字指定窗口的范围,通常配合嵌套查询使用;</p><pre><code>函数 OVER ([PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]</code></pre><p><strong>窗口函数</strong> MySQL 8开始支持窗口函数。在之前的版本中已存在的大部分 聚合函数 在MySQL 8中也可以</p><p>作为窗口函数来使用。学过大数据的应该都知道这玩意跟hive中的窗口函数类似，简单来说窗口函数就是不进行</p><p>内部的聚合，而是将所聚合的字段的结果全部保留。刚开始理解可能有点困难，我们就根据案例来进行理解。</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220613181134589.png"></p><h4 id="2-案例需求：查询每种商品分类下，价格前3大的信息"><a href="#2-案例需求：查询每种商品分类下，价格前3大的信息" class="headerlink" title="2.案例需求：查询每种商品分类下，价格前3大的信息"></a><strong>2.案例需求：查询每种商品分类下，价格前3大的信息</strong></h4><p>数据准备</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> goods<span class="token punctuation">(</span> id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span> category_id <span class="token keyword">INT</span><span class="token punctuation">,</span> category <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">,</span> NAME <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span> price <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stock <span class="token keyword">INT</span><span class="token punctuation">,</span> upper_time <span class="token keyword">DATETIME</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> goods<span class="token punctuation">(</span>category_id<span class="token punctuation">,</span>category<span class="token punctuation">,</span>NAME<span class="token punctuation">,</span>price<span class="token punctuation">,</span>stock<span class="token punctuation">,</span>upper_time<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'女装/女士精品'</span><span class="token punctuation">,</span> <span class="token string">'T恤'</span><span class="token punctuation">,</span> <span class="token number">39.90</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'女装/女士精品'</span><span class="token punctuation">,</span> <span class="token string">'连衣裙'</span><span class="token punctuation">,</span> <span class="token number">79.90</span><span class="token punctuation">,</span> <span class="token number">2500</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'女装/女士精品'</span><span class="token punctuation">,</span> <span class="token string">'卫衣'</span><span class="token punctuation">,</span> <span class="token number">89.90</span><span class="token punctuation">,</span> <span class="token number">1500</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'女装/女士精品'</span><span class="token punctuation">,</span> <span class="token string">'牛仔裤'</span><span class="token punctuation">,</span> <span class="token number">89.90</span><span class="token punctuation">,</span> <span class="token number">3500</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'女装/女士精品'</span><span class="token punctuation">,</span> <span class="token string">'百褶裙'</span><span class="token punctuation">,</span> <span class="token number">29.90</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'女装/女士精品'</span><span class="token punctuation">,</span> <span class="token string">'呢绒外套'</span><span class="token punctuation">,</span> <span class="token number">399.90</span><span class="token punctuation">,</span> <span class="token number">1200</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'户外运动'</span><span class="token punctuation">,</span> <span class="token string">'自行车'</span><span class="token punctuation">,</span> <span class="token number">399.90</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'户外运动'</span><span class="token punctuation">,</span> <span class="token string">'山地自行车'</span><span class="token punctuation">,</span> <span class="token number">1399.90</span><span class="token punctuation">,</span> <span class="token number">2500</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'户外运动'</span><span class="token punctuation">,</span> <span class="token string">'登山杖'</span><span class="token punctuation">,</span> <span class="token number">59.90</span><span class="token punctuation">,</span> <span class="token number">1500</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'户外运动'</span><span class="token punctuation">,</span> <span class="token string">'骑行装备'</span><span class="token punctuation">,</span> <span class="token number">399.90</span><span class="token punctuation">,</span> <span class="token number">3500</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'户外运动'</span><span class="token punctuation">,</span> <span class="token string">'运动外套'</span><span class="token punctuation">,</span> <span class="token number">799.90</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'户外运动'</span><span class="token punctuation">,</span> <span class="token string">'滑板'</span><span class="token punctuation">,</span> <span class="token number">499.90</span><span class="token punctuation">,</span> <span class="token number">1200</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需求分析：需要根据表中category分类或者根据id分类,取每个分类中的价格前3的价格信息。考虑使用子查询或者窗口函数</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220613182339418.png"></p><p>普通的嵌套查询：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id<span class="token punctuation">,</span>category<span class="token punctuation">,</span>name<span class="token punctuation">,</span>price<span class="token punctuation">,</span>stock <span class="token keyword">from</span> goods <span class="token keyword">where</span> category_id <span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">order</span> <span class="token keyword">by</span> price <span class="token keyword">desc</span> <span class="token keyword">limit</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">as</span> t<span class="token keyword">union</span> <span class="token keyword">all</span> <span class="token keyword">select</span> <span class="token operator">*</span><span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id<span class="token punctuation">,</span>category<span class="token punctuation">,</span>name<span class="token punctuation">,</span>price<span class="token punctuation">,</span>stock <span class="token keyword">from</span> goods <span class="token keyword">where</span> category_id <span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">order</span> <span class="token keyword">by</span> price <span class="token keyword">desc</span> <span class="token keyword">limit</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">as</span> t1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>窗口函数查询：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> row_number<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">over</span> <span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> category_id <span class="token keyword">order</span> <span class="token keyword">by</span> price <span class="token keyword">desc</span> <span class="token punctuation">)</span> <span class="token keyword">as</span> row_id<span class="token punctuation">,</span> id<span class="token punctuation">,</span>category_id<span class="token punctuation">,</span>NAME<span class="token punctuation">,</span>price<span class="token punctuation">,</span>stock <span class="token keyword">from</span> goods <span class="token punctuation">)</span> k <span class="token keyword">where</span> row_id<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>相比之下，窗口函数的执行效率更高，且简洁易懂</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqoop的配置和使用</title>
      <link href="/2022/05/31/sqoop%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/05/31/sqoop%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="sqoop"><a href="#sqoop" class="headerlink" title="sqoop"></a>sqoop</h1><p>Apache Sqoop(TM) 是一种工具，设计用于在 <a href="http://hadoop.apache.org/">Apache Hadoop</a>和结构化数据存储（如关系数据库）之间高效传输批量数据。</p><p>Sqoop是一款开源的工具，主要用于在Hadoop(Hive)与传统的数据库(mysql、postgresql…)间进行数据的传递，可以将一个关系型数据库（例如 ： MySQL ,Oracle ,Postgres等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。</p><h2 id="一、sqoop的安装"><a href="#一、sqoop的安装" class="headerlink" title="一、sqoop的安装"></a>一、sqoop的安装</h2><p>下载地址:<a href="http://archive.apache.org/dist/sqoop/1.4.7/">http://archive.apache.org/dist/sqoop/1.4.7/</a></p><p>官方文档:<a href="https://sqoop.apache.org/docs/1.4.7/SqoopUserGuide.html#_introduction">https://sqoop.apache.org/docs/1.4.7/SqoopUserGuide.html#_introduction</a></p><p>1.4.7版本支持hadoop2.6及以上的版本 </p><p><strong>部署环境</strong>：hadoop3.0x mysql5.7.29</p><p><strong>需要的驱动</strong>：mysql-connector-java-8.0.23.jar （5.0x版本会报错）</p><h4 id="1-解压对应的包到指定目录"><a href="#1-解压对应的包到指定目录" class="headerlink" title="1.解压对应的包到指定目录"></a>1.解压对应的包到指定目录</h4><p>$ tar -zxvf sqoop-1.4.7.bin__hadoop-2.6.0.tar.gz -C &#x2F;opt&#x2F;module&#x2F;</p><h4 id="2-重命名配置文件"><a href="#2-重命名配置文件" class="headerlink" title="2.重命名配置文件"></a>2.重命名配置文件</h4><p>mv sqoop-env-template.sh sqoop-env.sh</p><h4 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3.修改配置文件"></a>3.修改配置文件</h4><p>export HADOOP_COMMON_HOME&#x3D;&#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3</p><p>export HADOOP_MAPRED_HOME&#x3D;&#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3</p><p>export HIVE_HOME&#x3D;&#x2F;opt&#x2F;module&#x2F;hive</p><p>export ZOOKEEPER_HOME&#x3D;&#x2F;opt&#x2F;module&#x2F;zookeeper-3.5.7</p><p>export ZOOCFGDIR&#x3D;&#x2F;opt&#x2F;module&#x2F;zookeeper-3.5.7</p><p>export HBASE_HOME&#x3D;&#x2F;opt&#x2F;module&#x2F;hbase-2.1.0</p><h4 id="4-拷贝jdbc驱动"><a href="#4-拷贝jdbc驱动" class="headerlink" title="4.拷贝jdbc驱动"></a>4.拷贝jdbc驱动</h4><p>cp mysql-connector-java-8.0.23.jar &#x2F;opt&#x2F;module&#x2F;sqoop&#x2F;lib&#x2F;</p><h4 id="5-验证Sqoop"><a href="#5-验证Sqoop" class="headerlink" title="5.验证Sqoop"></a>5.验证Sqoop</h4><p>bin&#x2F;sqoop help</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220531163501934.png"></p><h4 id="6-验证是否可以连接数据库"><a href="#6-验证是否可以连接数据库" class="headerlink" title="6.验证是否可以连接数据库"></a>6.验证是否可以连接数据库</h4><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220531163614604.png"></p><h4 id="7-配置HIVE相关参数（可选）"><a href="#7-配置HIVE相关参数（可选）" class="headerlink" title="7.配置HIVE相关参数（可选）"></a>7.配置HIVE相关参数（可选）</h4><p>修改环境变量  配置hive相关参数</p><p>#HIVE<br>export HIVE_HOME&#x3D;&#x2F;opt&#x2F;module&#x2F;hive<br>export PATH&#x3D;$PATH:$HIVE_HOME&#x2F;bin<br>export HIVE_CONF_DIR&#x3D;$HIVE_HOME&#x2F;conf</p><h2 id="二、Sqoop的快速上手"><a href="#二、Sqoop的快速上手" class="headerlink" title="二、Sqoop的快速上手"></a>二、Sqoop的快速上手</h2><p>参数介绍</p><p><strong>公用参数：数据库连接</strong></p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220531164514437.png"><strong>公用参数：import</strong></p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220531164541462.png"><strong>公用参数：export</strong></p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220531164607565.png"><strong>公用参数：hive</strong></p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220531164642597.png"></p><p><strong>其余参数：</strong></p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220531164713135.png"></p><h4 id="2-1全表导入"><a href="#2-1全表导入" class="headerlink" title="2.1全表导入"></a>2.1全表导入</h4><p>mysql密码要保证正确  集群已启动</p><pre class="line-numbers language-sql"><code class="language-sql"> bin<span class="token operator">/</span>sqoop <span class="token keyword">import</span> \<span class="token comment" spellcheck="true">--connect jdbc:mysql://hadoop102:3306/company \</span><span class="token comment" spellcheck="true">--username root \</span><span class="token comment" spellcheck="true">--password hadoop \</span><span class="token comment" spellcheck="true">--table staff \</span><span class="token comment" spellcheck="true">--target-dir /opt/spw \</span><span class="token comment" spellcheck="true">--num-mappers 1 \</span><span class="token comment" spellcheck="true">--fields-terminated-by "\t"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220531164129423.png"></p><h4 id="2-2查询导入"><a href="#2-2查询导入" class="headerlink" title="2.2查询导入"></a>2.2查询导入</h4><pre class="line-numbers language-sql"><code class="language-sql">bin<span class="token operator">/</span>sqoop <span class="token keyword">import</span> \<span class="token comment" spellcheck="true">--connect jdbc:mysql://hadoop102:3306/company \</span><span class="token comment" spellcheck="true">--username root \</span><span class="token comment" spellcheck="true">--password hadoop \</span><span class="token comment" spellcheck="true">--target-dir /user/company1 \</span><span class="token comment" spellcheck="true">--num-mappers 1 \</span><span class="token comment" spellcheck="true">--fields-terminated-by "\t" \</span><span class="token comment" spellcheck="true">--query "select name,sex from staff where id = 1 and \$CONDITIONS;" </span><span class="token punctuation">(</span>反斜杠 不用加表<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3导入指定的列"><a href="#2-3导入指定的列" class="headerlink" title="2.3导入指定的列"></a>2.3导入指定的列</h4><pre class="line-numbers language-sql"><code class="language-sql">bin<span class="token operator">/</span>sqoop <span class="token keyword">import</span> \<span class="token comment" spellcheck="true">--connect jdbc:mysql://hadoop102:3306/company \</span><span class="token comment" spellcheck="true">--username root \</span><span class="token comment" spellcheck="true">--password hadoop \</span><span class="token comment" spellcheck="true">--target-dir /user/company \</span><span class="token comment" spellcheck="true">--delete-target-dir \</span><span class="token comment" spellcheck="true">--num-mappers 1 \</span><span class="token comment" spellcheck="true">--fields-terminated-by "\t" \</span><span class="token comment" spellcheck="true">--columns id,sex \</span><span class="token comment" spellcheck="true">--table staff</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4导入至hive"><a href="#2-4导入至hive" class="headerlink" title="2.4导入至hive"></a>2.4导入至hive</h4><pre class="line-numbers language-sql"><code class="language-sql">bin<span class="token operator">/</span>sqoop <span class="token keyword">import</span> \<span class="token comment" spellcheck="true">--connect jdbc:mysql://hadoop102:3306/company \</span><span class="token comment" spellcheck="true">--username root \</span><span class="token comment" spellcheck="true">--password hadoop \</span><span class="token comment" spellcheck="true">--table staff \</span><span class="token comment" spellcheck="true">--num-mappers 1 \</span><span class="token comment" spellcheck="true">--hive-import \</span><span class="token comment" spellcheck="true">--fields-terminated-by "\t" \</span><span class="token comment" spellcheck="true">--hive-overwrite \</span><span class="token comment" spellcheck="true">--hive-database itheima \</span><span class="token comment" spellcheck="true">--hive-table staff_hive</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 大数据生态圈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题-回溯法</title>
      <link href="/2022/05/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
      <url>/2022/05/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="0-1背包问题是子集选取问题。"><a href="#0-1背包问题是子集选取问题。" class="headerlink" title="0-1背包问题是子集选取问题。"></a><strong>0-1背包问题是子集选取问题。</strong></h3><p>一般情况下，0-1背包问题是NP完全问题。0-1背包问题的解空间可以用子集树表示。解0-1背包问题的回溯法与解装载问题的回溯法十分相似。在搜索解空间树时，只要其左儿子节点是一个可行的节点，搜索就进入其左子树;而当右子树中有可能包含最优解时才进入右子树搜索，否则将右子树剪去。设r是当前剩余物品价值总和；cp是当前价值；bestp是当前最优价值。当cp+r&lt;&#x3D;bestp时，可剪去右子树。计算右子树中解的上界的更好的办法是，将剩余物品依其单位重量价值排序，然后依次装入物品，直至装不下时，再装入该物品的一部分而装满背包，由此得到的价值是右子树的上界。  </p><p>0–1背包的一个实例：n&#x3D;5, c&#x3D;10, w&#x3D;{2, 2, 6, 5, 4}, v(p)&#x3D;{6, 3, 5, 4, 6}的0-1背包问题的最优解和最优值。&lt;w为重量，v为价值量，n为物品个数，c为背包容量&gt;</p><h2 id="回溯法基本思想"><a href="#回溯法基本思想" class="headerlink" title="回溯法基本思想"></a>回溯法基本思想</h2><p>确定了解空间的组织结构后，【回溯法从开始节点（根节点）出发，以深度优先搜索整个解空间。这个开始的节点为活节点，同时成为当前的扩展节点。在当前的扩展节点处，搜素向纵深方向移至一个新节点。这个新节点就成为新的活节点，并成为当前扩展节点。如果当前节点处不能再向纵深方向移动，则当前扩展节点为死节点。此时，应往回移动到最近的一个活节点处。回溯法以这种方式递归的在解空间中搜素，直至找到所有符合要求的解或解空间中已无活节点。】（即深度优先搜素）</p><p>回溯法的典型实例——0-1背包问题<br>为了方便理解回溯法运算的流程，以0-1背包问题为例进行分析；</p><p>问题：<br>给定n种物品和一背包。物品i的重量是wi，其价值为vi，背包的容量为C。问:应如何选择装入背包的物品，使得装入背包中物品的总价值最大?</p><p>首先考虑贪心法，为了得到最大的价值，将所有物品按照单位价值（Vi&#x2F;Wi）降序排列（例如采用希尔排序，时间复杂度为），在放入物品时优先考虑单位价值更高的物品。在搜索到空间树中的某个结点P时，已经确定了P及其前面的结点取值，进而判断从P继续扩展下去是否获得更大的价值，如果不能，该结点无需扩展，可以进行回溯了。下面的函数结合了贪心法判断从某一点扩展开去可能获得的最大的价值。</p><pre><code>int Bound(int *Values, int *Weights,int n,int maxWeight,int num,int current_Weight,int current_profit)&#123;    int i = num + 1;    for (; i &lt; n; i++)    &#123;        if (current_Weight + Weights[i] &lt; maxWeight)        &#123;            current_profit += Values[i];            current_Weight += Weights[i];        &#125;        else        &#123;            current_profit += (Values[i] / Weights[i])*(maxWeight - current_Weight);            current_Weight = maxWeight;            return current_profit;        &#125;    &#125;     return current_profit;&#125;int *Knapsack(int *Values,int *Weights,int n,int maxWeight)&#123;    int *X = new int[n];    int *Y = new int[n];    int Weight = 0;    int Profit = 0;     int current_weight=0, current_profit=0;     int i = 0;    while (1)    &#123;        while (i&lt;n&amp;&amp;t_weight + Weights[i] &lt;= maxWeight)        &#123;            X[i] = SELECT;            current_profit += Values[i];            current_weight += Weights[i];            i++;        &#125;        //---上面的循环中，如果是由于i=n结束的，那么说明深度搜索已经搜索到了最底层        if (i &gt;= n)        &#123;            Weight = current_weight;            Profit = current_profit;            i = n;            for (int j = 0; j &lt; n; j++)                 //------------把数组X挪给Y；            &#123;                Y[j] = X[j];            &#125;        &#125;        //否则就是由于第i个物品在当前情况下无法放入背包        else        &#123;            X[i] = UNSELECT;        &#125;                 while (Bound(Values, Weights, n, maxWeight, i, current_weight, current_profit) &lt;= Profit)//如果不可能获得更大的价值，那么这个点就不需要进行扩展了；        &#123;            while (i != 0 &amp;&amp; X[i] != SELECT)//进行回溯            &#123;                i--;            &#125;            if (i == 0)   //当回溯到i=0时候，所有情况都遍历了            &#123;                return Y;            &#125;             X[i] = UNSELECT;            current_profit -= Values[i];            current_weight -= Weights[i];        &#125;        i++;    &#125;    &#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka快速入门</title>
      <link href="/2022/05/21/kafka%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2022/05/21/kafka%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1事件流"><a href="#1-1事件流" class="headerlink" title="1.1事件流"></a>1.1事件流</h2><p>事件流是人体中枢神经系统的数字等效物。它是“永远在线”世界的技术基础，在这个世界中，企业越来越多地由软件定义和自动化，并且软件的用户更多地是软件。</p><p>从技术上讲，事件流是从事件源（如数据库、传感器、移动设备、云服务和软件应用程序）以事件流的形式实时捕获数据的实践；持久存储这些事件流以供以后检索；实时和回顾性地操作、处理和响应事件流；并根据需要将事件流路由到不同的目标技术。因此，事件流确保了数据的连续流动和解释，以便正确的信息在正确的时间出现在正确的位置。</p><h4 id="我可以将事件流用于什么？"><a href="#我可以将事件流用于什么？" class="headerlink" title="我可以将事件流用于什么？"></a><a href="https://kafka.apache.org/30/documentation.html#intro_usage">我可以将事件流用于什么？</a></h4><p>事件流应用于 众多行业和组织的<a href="https://kafka.apache.org/powered-by">各种用例。</a>它的许多例子包括：</p><ul><li>实时处理支付和金融交易，例如在证券交易所、银行和保险中。</li><li>实时跟踪和监控汽车、卡车、车队和货运，例如在物流和汽车行业。</li><li>持续捕获和分析来自物联网设备或其他设备的传感器数据，例如工厂和风电场。</li><li>收集并立即响应客户互动和订单，例如零售、酒店和旅游行业以及移动应用程序。</li><li>监测住院病人，预测病情变化，确保在紧急情况下及时治疗。</li><li>连接、存储和提供公司不同部门产生的数据。</li><li>作为数据平台、事件驱动架构和微服务的基础。</li></ul><h4 id="Apache-Kafka®-是一个事件流平台。这意味着什么？"><a href="#Apache-Kafka®-是一个事件流平台。这意味着什么？" class="headerlink" title="Apache Kafka® 是一个事件流平台。这意味着什么？"></a><a href="https://kafka.apache.org/30/documentation.html#intro_platform">Apache Kafka® 是一个事件流平台。这意味着什么？</a></h4><p>Kafka 结合了三个关键功能，因此您可以 通过一个经过实战考验的解决方案实现端到端的事件流 <a href="https://kafka.apache.org/powered-by">用例：</a></p><ol><li><strong>发布</strong>（写入）和<strong>订阅</strong>（读取）事件流，包括从其他系统持续导入&#x2F;导出数据 。</li><li>根据需要持久可靠地 <strong>存储事件流。</strong></li><li>在事件发生时或回顾性 地<strong>处理事件流。</strong></li></ol><h2 id="1-2基础架构"><a href="#1-2基础架构" class="headerlink" title="1.2基础架构"></a>1.2基础架构</h2><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/8d2ee577801a71b81bb42e2af6a8e0f9.png" alt="1"></p><p>Kafka像其他Mq一样，也有自己的基础架构，主要存在生产者Producer、Kafka集群Broker、消费者Consumer、注册消息Zookeeper.</p><p><strong>Produce</strong>r：消息生产者<br><strong>Consumer：消息消费者</strong><br><strong>Consumer Group</strong>：</p><p>consumer group是kafka提供的可扩展且具有容错性的消费者机制。既然是一个组，那么组内必然可以有多个消费者或消费者实例(consumer instance)，它们共享一个公共的ID，即group ID。组内的所有消费者协调在一起来消费订阅主题(subscribed topics)的所有分区(partition)。当然，每个分区只能由同一个消费组内的一个consumer来消费。<br><strong>Broker</strong>：一台服务器就是一个Broker，一个集群由多个Broker组成，一个Broker可以容纳多个Topic。<br><strong>Topic</strong>：主题，生产者和消费者都是面向一个Topic<br><strong>Partition</strong>：分区，为了实现扩展性，一个非常大的Topic可以分布到多个Broker上，一个Topic可以分为多个Partition，每个Partition是一个有序的队列(分区有序，不能保证全局有序)  切成3片 每片都存着零散的信息</p><p><strong>Replica</strong>：</p><p>副本Replication，为保证集群中某个节点发生故障，节点上的Partition数据不丢失，Kafka提供了副本机制，一个Topic的每个分区有若干个副本，一个Leader和多个Follower<br><strong>Leader</strong>：每个分区多个副本的主角色，生产者发送数据的对象，以及消费者消费数据的对象都是Leader。<br><strong>Follower</strong>：</p><p>每个分区多个副本的从角色，实时的从Leader中同步数据，保持和Leader数据的同步，Leader发生故障的时候，某个Follower会成为新的Leader。</p><p><strong>ISR and AR</strong>:</p><p>所有副本统称为 AR (Assigned Replicas)</p><p> ISR 集合是 AR 集合的一个子集。消息会先发送到leader副本，然后follower副本才能从leader中拉取消息进行同步。同步期间，follow副本相对于leader副本而言会有一定程度的滞后。</p><p>滞后性：所有与leader副本保持一定程度同步的副本（包括leader副本在内）组成 ISR (In Sync Replicas)</p><p>&amp;ensp;</p><h2 id="1-3发送原理"><a href="#1-3发送原理" class="headerlink" title="1.3发送原理"></a>1.3发送原理</h2><p>1.创建producer对象调用方法send</p><p>2.拦截器</p><p>3.序列化器（自带的 跨节点处理）</p><p>4.分区器</p><p>5.发送到缓冲队列里 一个分区创建一个队列（在内存中完成的）32M 16k</p><p>6.sender线程（读取数据）</p><p>batch.size只有数据累积到batch.size的时候，sender才会发送数据 16k</p><p>linger.ms 数据如果未达到batch.size 设置等待时间（默认0ms）</p><p>应答机制acks </p><p>0的话就你就不用管 继续传</p><p>1的话leader要收到后 然后才继续传</p><p>-1（all）所有节点都收集 </p><p>Q:如果失败怎么办</p><p>会有一个重试的机制 retries</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/20dqGk_grrkJWS4dtjRQAO1P8Qaz8jjxC-yDev8dc2U.png"></p><h2 id="1-4kafka的分区"><a href="#1-4kafka的分区" class="headerlink" title="1.4kafka的分区"></a>1.4kafka的分区</h2><p>Kafka可以将主题划分为多个分区（Partition），会根据分区规则选择把消息存储到哪个分区中，只要 如果分区规则设置的合理，那么所有的消息将会被均匀的分布到不同的分区中，这样就实现了负载均衡 和水平扩展。另外，多个订阅者可以从一个或者多个分区中同时消费数据，以支撑海量数据处理能力。</p><p>由于消息是以追加到分区中的，多个分区顺序写磁盘的总效率要比随机写内存还要高（引 用Apache Kafka – A High Throughput Distributed Messaging System的观点），是Kafka高吞吐率的 重要保证之一。</p><h4 id="副本机制"><a href="#副本机制" class="headerlink" title="副本机制"></a>副本机制</h4><p>由于Producer和Consumer都只会与Leader角色的分区副本相连，所以kafka需要以集群的组织形式提 供主题下的消息高可用。kafka支持主备复制，所以消息具备高可用和持久性。</p><p>一个分区可以有多个副本，这些副本保存在不同的broker上。每个分区的副本中都会有一个作为 Leader。当一个broker失败时，Leader在这台broker上的分区都会变得不可用，kafka会自动移除 Leader，再其他副本中选一个作为新的Leader。</p><p>在通常情况下，增加分区可以提供kafka集群的吞吐量。然而，也应该意识到集群的总分区数或是单台 服务器上的分区数过多，会增加不可用及延迟的风险。</p><h4 id="分区Leader选举"><a href="#分区Leader选举" class="headerlink" title="分区Leader选举"></a>分区Leader选举</h4><p>可以预见的是,如果某个分区的Leader挂了,那么其它跟随者将会进行选举产生一个新的leader,之后所有 的读写就会转移到这个新的Leader上</p><p>在kafka中,其不是采用常见的多数选举的方式进行副本的Leader 选举,而是会在Zookeeper上针对每个Topic维护一个称为ISR（in-sync replica，已同步的副本）的集合, 显然还有一些副本没有来得及同步。只有这个ISR列表里面的才有资格成为leader(先使用ISR里面的第一 个，如果不行依次类推，因为ISR里面的是同步副本，消息是最完整且各个节点都是一样的)。<br>通过 ISR,kafka需要的冗余度较低，可以容忍的失败数比较高。假设某个topic有f+1个副本，kafka可以容忍f 个不可用,当然,如果全部ISR里面的副本都不可用,也可以选择其他可用的副本,只是存在数据的不一致。</p><p>☆分区重新分配☆<br>我们往已经部署好的Kafka集群里面添加机器是最正常不过的需求，而且添加起来非常地方便，我们需 要做的事是从已经部署好的Kafka节点中复制相应的配置文件，然后把里面的broker id修改成全局唯一 的，最后启动这个节点即可将它加入到现有Kafka集群中。</p><h4 id="创建集群和主题"><a href="#创建集群和主题" class="headerlink" title="创建集群和主题"></a>创建集群和主题</h4><p>首先创建一个有三个节点的集群</p><p>创建主题 (topic-cluster) 3个分区 , 副本数为 3</p><p>主题的副本数。每个主题可以有多个副本，副本位于集群中不同的broker上，也就是说副本的数量不能超过broker的数量，否则创建主题时会失败。</p><h2 id="1-5发送模式"><a href="#1-5发送模式" class="headerlink" title="1.5发送模式"></a>1.5发送模式</h2><p><a href="https://so.csdn.net/so/search?q=kafka&spm=1001.2101.3001.7020">kafka</a>有同步（sync）、异步（async）以及oneway这三种发送方式，某些概念上区分也可以分为同步和异步两种，同步和异步的发送方式通过“producer.type”参数指定，而oneway由“request.require.acks”参数指定。</p><ul><li><p>同步方式，一定是逐条发送的，第一条响应到达后，才会请求第二条</p></li><li><p>异步方式，可以发送一条，也可以批量发送多条，特性是不需等第一次(注意这里单位是次，因为单次可以是单条，也可以是批量数据)响应，就立即发送第二次</p></li></ul><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/4TAs4ZYMh37r5mqRkBJ_nCtWggukC10OFR1zyYtrfoc.png"></p><h2 id="1-6Kafka副本"><a href="#1-6Kafka副本" class="headerlink" title="1.6Kafka副本"></a>1.6<strong>Kafka</strong>副本</h2><p>1.Kafka 默认副本 1 个，生产环境一般配置为 2 个，保证数据可靠性；太多副本会</p><p>增加磁盘存储空间，增加网络上数据传输，降低效率。</p><p>2.Kafka 中副本分为：Leader 和 Follower。Kafka 生产者只会把数据发往 Leader，</p><p>然后 Follower 找 Leader 进行同步数据。</p><p>3.Kafka 分区中的所有副本统称为 AR（Assigned Repllicas）。</p><p>AR &#x3D; ISR + OSR</p><p><strong>ISR</strong>，表示和 Leader 保持同步的 Follower 集合。如果 Follower 长时间未向 Leader 发送 </p><p>4.通信请求或同步数据，则该 Follower 将被踢出 ISR。该时间阈值由 <strong>replica.lag.time.max.ms</strong></p><p>参数设定，默认 30s。Leader 发生故障之后，就会从 ISR 选举新的 Leader。</p><p><strong>OSR****，</strong>表示 Follower 与 Leader 副本同步时，延迟过多的副本。</p>]]></content>
      
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的RDD算子（分组）</title>
      <link href="/2022/05/16/%E8%A7%A3%E6%9E%90RDD%E7%AE%97%E5%AD%90%EF%BC%88%E5%88%86%E7%BB%84%E7%AF%87%EF%BC%89/"/>
      <url>/2022/05/16/%E8%A7%A3%E6%9E%90RDD%E7%AE%97%E5%AD%90%EF%BC%88%E5%88%86%E7%BB%84%E7%AF%87%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="RDD常见转换算子解析"><a href="#RDD常见转换算子解析" class="headerlink" title="RDD常见转换算子解析"></a>RDD常见转换算子解析</h1><h2 id="1-groupBy和groupBykey"><a href="#1-groupBy和groupBykey" class="headerlink" title="1.groupBy和groupBykey"></a>1.groupBy和groupBykey</h2><p><strong>groupBy</strong></p><p>def groupBy[K](f: T &#x3D;&gt; K)(implicit kt: ClassTag[K]): RDD[(K, Iterable[T])]</p><p>  函数f接收参数类型为一个<a href="https://so.csdn.net/so/search?q=%E8%A1%A8%E8%BE%BE%E5%BC%8F&spm=1001.2101.3001.7020">表达式</a>，将T转化为K，结果中就以表达式的结果为key，即泛型K与入参保持一致，value为输入类型的列表，即泛型T对应入参T。</p><p><strong>作用：根据指定的条件进行分组</strong>   </p><p>属性 或 逻辑运算</p><p>返回分组后的RDD。每个组由一个键和一系列映射到该键的元素组成。不能保证每组中元素的顺序，因为要经过shuffle操作。</p><p>groupby后组元素会保留key值</p><pre class="line-numbers language-scala"><code class="language-scala">    <span class="token keyword">val</span> conf<span class="token operator">:</span> SparkConf <span class="token operator">=</span> <span class="token keyword">new</span> SparkConf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setMaster<span class="token punctuation">(</span><span class="token string">"local[*]"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setAppName<span class="token punctuation">(</span><span class="token string">"Control3"</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> SparkContext<span class="token punctuation">(</span>conf<span class="token punctuation">)</span>        <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token string">"spark"</span><span class="token punctuation">,</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token string">"spark"</span><span class="token punctuation">,</span><span class="token string">"scala"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        rdd<span class="token punctuation">.</span>groupBy<span class="token punctuation">(</span>x<span class="token keyword">=></span>x<span class="token punctuation">)</span><span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 结果为</span><span class="token comment" spellcheck="true">//(spark,CompactBuffer(spark, spark))</span><span class="token comment" spellcheck="true">//(scala,CompactBuffer(scala))</span><span class="token comment" spellcheck="true">//(hello,CompactBuffer(hello, hello))</span>            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分组聚合 返回的是一个对偶元组</p><p>CompactBuffe 继承自序列，因此它很容易进行遍历和迭代，可以把它理解为一个类表</p><p><strong>groupBykey</strong> </p><p>def groupByKey(): RDD[(K, Iterable[V])]</p><p>def groupByKey(numPartitions: Int): RDD[(K, Iterable[V])]</p><p>def groupByKey(partitioner: Partitioner): RDD[(K, Iterable[V])]</p><p>适合处理k-v类型的数据</p><p><strong>功能：将数据源中的数据，相同的key分在一个组中，形成一个对偶元组</strong></p><p>key， u</p><p>搭配map 和 sum可以求出数据</p><pre class="line-numbers language-scala"><code class="language-scala"> <span class="token keyword">val</span> conf<span class="token operator">:</span> SparkConf <span class="token operator">=</span> <span class="token keyword">new</span> SparkConf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setMaster<span class="token punctuation">(</span><span class="token string">"local[*]"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setAppName<span class="token punctuation">(</span><span class="token string">"Control3"</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> SparkContext<span class="token punctuation">(</span>conf<span class="token punctuation">)</span>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> value<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> Iterable<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>groupByKey<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//(a,CompactBuffer(1, 5))(b,CompactBuffer(3))(c,CompactBuffer(4))</span>    <span class="token keyword">val</span> data<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">.</span>map<span class="token punctuation">(</span>      op <span class="token keyword">=></span> <span class="token punctuation">(</span>op<span class="token punctuation">.</span>_1<span class="token punctuation">,</span> op<span class="token punctuation">.</span>_2<span class="token punctuation">.</span>sum<span class="token punctuation">)</span>    <span class="token punctuation">)</span>    data<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">/*(a,6)(b,3)(c,4)*/</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1.红色RDD是数据源，包含两个分区的(word,1)数据</p><p>2.Shuffle过程（都知道Shuffle过程是需要磁盘IO的）</p><p>3.groupByKey后的RDD，根据key分组对Value进行聚合</p><p>4.Map操作计算WordCount</p><p>总结：groupbykey 会导致数据打乱重组，存在shuffle操作。</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220517133723606.png"></p><h2 id="2-reduce、reduceByKey"><a href="#2-reduce、reduceByKey" class="headerlink" title="2.reduce、reduceByKey"></a>2.reduce、reduceByKey</h2><p><strong>reduce</strong>将RDD中元素前两个传给输入函数，产生一个新的return值，新产生的return值与RDD中下一个元素（第三个元素）组成两个元素，再被传给输入函数，直到最后只有一个值为止。</p><pre class="line-numbers language-scala"><code class="language-scala"><span class="token keyword">val</span> c <span class="token operator">=</span> sc<span class="token punctuation">.</span>parallelize<span class="token punctuation">(</span><span class="token number">1</span> to <span class="token number">10</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>reduce<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token keyword">=></span> x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//结果55</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>reducebykey</strong>:def reduceByKey(partitioner: Partitioner, func: (V, V) &#x3D;&gt; V): RDD[(K, V)]</p><p>def reduceByKey(func: (V, V) &#x3D;&gt; V, numPartitions: Int): RDD[(K, V)]</p><p><strong>功能：reduceByKey可以将数据按照相同的 Key 对 Value 进行两两聚合，这个聚合的方式是需要指定的。</strong></p><p>reduceByKey支持分区内预聚合功能，可以有效减少Shuffle时落盘的数据量，提升Shuffle的性能。 </p><pre class="line-numbers language-scala"><code class="language-scala"><span class="token keyword">val</span> conf<span class="token operator">:</span> SparkConf <span class="token operator">=</span> <span class="token keyword">new</span> SparkConf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setMaster<span class="token punctuation">(</span><span class="token string">"local[*]"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setAppName<span class="token punctuation">(</span><span class="token string">"Control3"</span><span class="token punctuation">)</span><span class="token keyword">val</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> SparkContext<span class="token punctuation">(</span>conf<span class="token punctuation">)</span><span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>rdd<span class="token punctuation">.</span>reduceByKey<span class="token punctuation">(</span>_<span class="token operator">+</span>_<span class="token punctuation">)</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>println<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-、foldByKey、aggregateByKey、combineByKey"><a href="#3-、foldByKey、aggregateByKey、combineByKey" class="headerlink" title="3.、foldByKey、aggregateByKey、combineByKey"></a>3.、foldByKey、aggregateByKey、combineByKey</h2><p><strong>aggregateByKey</strong></p><p>def aggregateByKey[U: ClassTag](zeroValue: U)(seqOp: (U, V) &#x3D;&gt; U,</p><p> combOp: (U, U) &#x3D;&gt; U): RDD[(K, U)]</p><p>将数据根据不同的规则进行分区内计算和分区间计算</p><pre class="line-numbers language-scala"><code class="language-scala">  <span class="token keyword">val</span> conf<span class="token operator">:</span> SparkConf <span class="token operator">=</span> <span class="token keyword">new</span> SparkConf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setMaster<span class="token punctuation">(</span><span class="token string">"local[*]"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setAppName<span class="token punctuation">(</span><span class="token string">"Control3"</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> SparkContext<span class="token punctuation">(</span>conf<span class="token punctuation">)</span>    <span class="token keyword">val</span> rdd <span class="token operator">=</span>      sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span>        <span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span>      <span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> result<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>aggregateByKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">(</span>      <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token keyword">=></span> math<span class="token punctuation">.</span>max<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token keyword">=></span> <span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span>    <span class="token punctuation">)</span>    result<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span>    sc<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>foldByKey</strong></p><p>def foldByKey(zeroValue: V, partitioner: Partitioner)(func: (V, V) &#x3D;&gt; V): RDD[(K, V)]</p><p>当分区内计算规则和分区间计算规则相同时，aggregateByKey 就可以简化为 foldByKey</p><pre class="line-numbers language-scala"><code class="language-scala"><span class="token keyword">val</span> conf<span class="token operator">:</span> SparkConf <span class="token operator">=</span> <span class="token keyword">new</span> SparkConf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setMaster<span class="token punctuation">(</span><span class="token string">"local[*]"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setAppName<span class="token punctuation">(</span><span class="token string">"Control3"</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> SparkContext<span class="token punctuation">(</span>conf<span class="token punctuation">)</span>    <span class="token keyword">val</span> rdd <span class="token operator">=</span>      sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span>        <span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span>      <span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> result<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>foldByKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">(</span>      <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token keyword">=></span> <span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span>    <span class="token punctuation">)</span>    result<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span>    sc<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不是kv类型就基本不会让你调用xxbykey的方法</p><p><strong>combineByKey</strong></p><p>def combineByKey[C](</p><p> createCombiner: V &#x3D;&gt; C,</p><p> mergeValue: (C, V) &#x3D;&gt; C,</p><p> mergeCombiners: (C, C) &#x3D;&gt; C): RDD[(K, C)]</p><p>val list: List[(String, Int)] &#x3D; List((“a”, 88), (“b”, 95), (“a”, 91), (“b”, 93), </p><p>(“a”, 95), (“b”, 98))</p><p>val input: RDD[(String, Int)] &#x3D; sc.makeRDD(list, 2)</p><p>val combineRdd: RDD[(String, (Int, Int))] &#x3D; input.combineByKey(</p><p> (_, 1),</p><p> (acc: (Int, Int), v) &#x3D;&gt; (acc._1 + v, acc._2 + 1),</p><p> (acc1: (Int, Int), acc2: (Int, Int)) &#x3D;&gt; (acc1._1 + acc2._1, acc1._2 + acc2._2)</p><p>)</p>]]></content>
      
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongoDB的安装和部署</title>
      <link href="/2022/05/11/mongoDB%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%83%A8%E7%BD%B2/"/>
      <url>/2022/05/11/mongoDB%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB数据库安装及配置环境"><a href="#MongoDB数据库安装及配置环境" class="headerlink" title="MongoDB数据库安装及配置环境"></a><a href="https://so.csdn.net/so/search?q=MongoDB&spm=1001.2101.3001.7020">MongoDB</a>数据库安装及配置环境</h1><h2 id="一-MongoDB的下载与安装"><a href="#一-MongoDB的下载与安装" class="headerlink" title="一. MongoDB的下载与安装"></a>一. MongoDB的下载与安装</h2><h2 id="windows端"><a href="#windows端" class="headerlink" title="windows端"></a>windows端</h2><h3 id="1-1-下载地址"><a href="#1-1-下载地址" class="headerlink" title="1.1 下载地址"></a>1.1 下载地址</h3><p><a href="https://www.mongodb.com/download-center/community?jmp=docs">https://www.mongodb.com/download-center/community?jmp=docs</a></p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220512172251154.png"></p><p>MongoDB 有两个服务器版本：<em>社区</em>版和 <em>企业版</em>。</p><h4 id="若想选择其他版本-可点击-Current-releases-amp-packages-自行下载"><a href="#若想选择其他版本-可点击-Current-releases-amp-packages-自行下载" class="headerlink" title="若想选择其他版本 可点击  Current releases &amp; packages 自行下载"></a>若想选择其他版本 可点击  Current releases &amp; packages 自行下载</h4><h4 id="打开-MongoDB-Shell-下载页面。"><a href="#打开-MongoDB-Shell-下载页面。" class="headerlink" title="打开 MongoDB Shell 下载页面。"></a>打开 MongoDB Shell 下载页面。</h4><h4 id="下载mongosh适用于您的操作系统的安装存档。"><a href="#下载mongosh适用于您的操作系统的安装存档。" class="headerlink" title="下载mongosh适用于您的操作系统的安装存档。"></a>下载<code>mongosh</code>适用于您的操作系统的安装存档。</h4><p>安装 “install mongoDB compass” 勾选（当然你也可以选择安装它，可能需要更久的安装时间），MongoDB Compass 是一个图形界面管理工具</p><h4 id="从下载的存档中提取文件"><a href="#从下载的存档中提取文件" class="headerlink" title="从下载的存档中提取文件"></a>从下载的存档中提取文件</h4><h4 id="将mongosh二进制文件添加到您的PATH环境变量中"><a href="#将mongosh二进制文件添加到您的PATH环境变量中" class="headerlink" title="将mongosh二进制文件添加到您的PATH环境变量中"></a>将<code>mongosh</code>二进制文件添加到您的<code>PATH</code>环境变量中</h4><p>确保提取的MongoDB Shell二进制文件位于文件系统中的所需位置，然后将该位置添加到<code>PATH</code> 环境变量中。</p><p>要将MongoDB Shell二进制文件的位置添加到您的 <code>PATH</code>环境变量中：</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511202542447.png"></p><h2 id="二、连接到远程服务器"><a href="#二、连接到远程服务器" class="headerlink" title="二、连接到远程服务器"></a>二、连接到远程服务器</h2><p>要使用MongoDB Shell ，您必须具有要连接的 MongoDB 部署。</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511203240401.png"></p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511203412464.png"></p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511203520850.png"></p><p>托管在云服务上可能要花费3-5min</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511203714885.png"></p><p>可以选择托管在云平台上  但只有512M的集群  如果要更多的存储空间 则要付费</p><p>默认情况下，MongoDB Atlas集群不需要能够启动与您的应用程序环境的连接。如果您希望启用具有 <a href="https://www.mongodb.com/docs/atlas/security-ldaps/#std-label-ldaps-authentication-authorization">LDAP 身份验证和授权</a>的Atlas集群，您必须允许从Atlas集群直接访问您的安全LDAP的网络访问。只要公共DNS主机名指向Atlas集群可以访问的 IP，您就可以允许使用公共或私有 IP 访问您的LDAP 。</p><p>简单来说就是通过ip来访问云服务</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511205759816.png"></p><p>连接说明中点第一个 然后就可以通过mongoDB compass连接上</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511205900562.png"></p><p>然后你会发现有三个集群节点可用 这也体现了分布式的特点</p><p>打开cmd</p><p>查看版本:mongod –version </p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511205950224.png"></p><p>进入shell :mongo, 默认端口为27017</p><p>mongod –dbpath 任意路径 默认就在根目录data下</p><p><strong>DataGrip</strong> 是JetBrains公司开发的数据库管理客户端工具 支持多种数据库连接 </p><p>特别棒的功能就是代码的智能提示 简直不要太好  可自行前往官网下载 </p><p>点击 new -&gt; data source mongodb 然后复制原本在compass上的url 点击test </p><p>如果没问题的话就可以连接上了</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511211000869.png"></p><p>show dbs</p><p>这两个数据库都是系统自带的，不建议更改，可以自己创个数据库 然后添加数据，这里就不做过多说明。</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511211206249.png"></p><p>到此为止，win端的mongodb的安装已经顺利成功</p><h2 id="Linux端的安装和数据迁移"><a href="#Linux端的安装和数据迁移" class="headerlink" title="Linux端的安装和数据迁移"></a>Linux端的安装和数据迁移</h2><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/100.png"></p><p>选择centos7版本的进行解压安装</p><p>1.新建文件夹 mkdir &#x2F;data  mkdir -p &#x2F;data&#x2F;db </p><p>2.解压:tar -zxvf xx -C   &#x2F;data</p><p>配置环境变量</p><pre class="line-numbers language-js"><code class="language-js">vim <span class="token operator">/</span>etc<span class="token operator">/</span>profile<span class="token comment" spellcheck="true">//拉到最下方</span><span class="token keyword">export</span> MONGODB_HOME <span class="token operator">=</span><span class="token operator">/</span>data<span class="token operator">/</span>mongodb<span class="token operator">/</span>bin<span class="token keyword">export</span> $PATH<span class="token punctuation">:</span>$MONGODB_HOME<span class="token operator">/</span>bin<span class="token comment" spellcheck="true">//更新环境变量</span>source <span class="token operator">/</span>etc<span class="token operator">/</span>profile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入mongo 直接报错 可以看见版本号但是 进不去mongo shell</p><p>报错信息如下：</p><p>Error: couldn’t connect to server 127.0.0.1:27017, connection attempt failed: SocketException: Error connecting to 127.0.0.1:27017 :: caused by :: Connection refused :</p><p>这时候我们将一台主机当做服务端  另一台当做客户端     通过客户端连接上服务端这样就可以正常访问   这里的本地模式并不是连接到windows上的本地  是linux的本地</p><p>bin&#x2F;mongod</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/101.png"></p><p>在另外一台输入</p><p>mongo </p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/102.png"></p><p>连接成功！ </p><p>当然在linux也可以连接之前在云端部署的MONGDB集群  具体操作如下</p><p>我们在官网登入自己的账户 点击command Line Tools</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/104.png"></p><p>点进去 然后选择 i have the MongoDB shell installed</p><p>然后复制一段代码 将mongosh 改为 mongo即可</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/105.png"></p><p>出现以下代码则说明连接成功</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/106.png"></p><p><strong>Q:第二次连接远程的时候连接不上 我们登入官网</strong> </p><p>点击NetWork Access 选择edit 将里面的连接方式改成运行任何地方的连接</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/107.png"></p><h3 id="如何导入数据"><a href="#如何导入数据" class="headerlink" title="如何导入数据"></a>如何导入数据</h3><p>首先要确保有mongorestore命令 如果没有的话则需要去官网下载工具包</p><p>mongodb-database-tools-rhel70-x86_64-100.5.2</p><p>解压到当前的bin目录下</p><p>mongorestore 如果可以Tab出来就代表没什么问题</p><p>mongorestore dump </p><p>即可导入成功</p><p>我们再重新登入客户端 </p><p>show dbs 就可以看见导入的数据库了 </p>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>scala指导手册</title>
      <link href="/2022/05/06/scala%E6%8C%87%E5%AF%BC%E6%89%8B%E5%86%8C/"/>
      <url>/2022/05/06/scala%E6%8C%87%E5%AF%BC%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="scala"><a href="#scala" class="headerlink" title="scala"></a>scala</h1><p>Scala combines <strong>object-oriented</strong> and <strong>functional programming</strong> in one concise, high-level language. Scala’s static types help avoid bugs in complex applications, and its JVM and JavaScript runtimes let you build high-performance systems with easy access to huge ecosystems of libraries.</p><p>(Scala将面向对象编程和函数式编程结合在一种简洁的高级语言中。Scala的静态类型有助于避免复杂应用程序中的错误，它的JVM和JavaScript运行时让您可以构建高性能系统，轻松访问庞大的库生态系统。)</p><ol><li>Scala embraces a fusion of functional programming (FP) and object-oriented programming (OOP)</li><li>Scala is statically typed, but often feels like a dynamically typed language</li><li>Scala’s syntax is concise(简洁), but still readable; it’s often referred to as <em>expressive</em></li><li><em>Implicits</em> in Scala 2 were a defining feature, and they have been improved and simplified（simply 简化） in Scala 3</li><li>Scala integrates(集成) seamlessly with Java, so you can create projects with mixed Scala and Java code, and Scala code easily uses the thousands of existing Java libraries </li><li>Scala can be used on the server, and also in the browser with <a href="https://www.scala-js.org/">Scala.js</a></li><li>The Scala standard library has dozens of pre-built, functional methods to save you time, and greatly reduce the need to write custom <code>for</code> loops and algorithms</li><li>“Best practices” are built into Scala, which favors immutability, anonymous functions, higher-order functions, pattern matching, classes that cannot be extended by default, and more</li><li>The Scala ecosystem offers the most modern FP libraries in the world</li><li>Strong type system</li></ol><h2 id="1-VARIABLES-AND-DATA-TYPES"><a href="#1-VARIABLES-AND-DATA-TYPES" class="headerlink" title="1.VARIABLES AND DATA TYPES"></a>1.VARIABLES AND DATA TYPES</h2><p>AnyVal(值类型)    </p><p>AnyRef(引用类型)</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/20200905165023396.png"></p><p>根类型 Any ，他是所有类的父类。</p><p>Class Any is the root of the Scala class hierarchy. Every class in a Scala execution environment inherits directly or indirectly from this class.</p><p>Starting with Scala 2.10 it is possible to directly extend Any using universal traits. A universal trait is a trait that extends Any, only has defs as members, and does no initialization.</p><p>scala 中一切皆为对象，分为两大类 AnyVal(值类型)， AnyRef(引用类型)， 他们都是 Any 子类</p><p>Null 类型是 scala 的特别类型，它只有一个值 null, 他是 bottom calss ,是 所有 AnyRef 类型的子类<br>Nothing 类型也是 bottom class ,他是所有类的子类，在开发中通常可以将 Nothing 类型的值返回给任意变量或者函数， 这里抛出异常使用很多</p><h3 id="Unit-类型、Null-类型和-Nothing-类型"><a href="#Unit-类型、Null-类型和-Nothing-类型" class="headerlink" title="Unit 类型、Null 类型和 Nothing 类型"></a>Unit 类型、Null 类型和 Nothing 类型</h3><p>1）Null 类只有一个实例对象，null，类似于 Java 中的 null 引用。null 可以赋值给任意引用类型(AnyRef)，但是不能赋值给值类型(AnyVal: 比如 Int, Float, Char, Boolean, Long, Double, Byte, Short)</p><p>2）Unit 类型用来标识过程，也就是没有明确返回值的函数。由此可见，Unit 类似于 Java 里的 void，Unit 只有一个实例。</p><p>3）Nothing，可以作为没有正常返回值的方法的返回类型，非常直观的告诉你这个方法不会正常返回，而且由于 Nothing 是其他任意类型的子类，他还能跟要求返回值的方法兼容。</p><h2 id="val-and-var-variables"><a href="#val-and-var-variables" class="headerlink" title="val and var variables:"></a>val and var variables:</h2><p>&#x2F;&#x2F;immutable</p><p>val a &#x3D; 10</p><p>&#x2F;&#x2F;mutable </p><p>var b &#x3D; 2</p><h2 id="Declaring-variable-types"><a href="#Declaring-variable-types" class="headerlink" title="Declaring variable types"></a>Declaring variable types</h2><p>val x :Int &#x3D; 10;</p><p>val p &#x3D; 10; </p><p>You can always explicitly declare a variable’s type if you prefer, but in simple assignments like these it isn’t necessary:</p><p><strong>val</strong> x: <strong>Int</strong> &#x3D; 1 </p><p><strong>val</strong> s: <strong>String</strong> &#x3D; “a string”</p><p><strong>val</strong> p: <strong>Person</strong> &#x3D; <strong>Person</strong>(“Richard”)</p><h2 id="CONTROL-STRUCTURES"><a href="#CONTROL-STRUCTURES" class="headerlink" title="CONTROL STRUCTURES"></a>CONTROL STRUCTURES</h2><p>Scala has the control structures you find in other programming languages, and also has powerful <code>for</code> expressions and <code>match</code> expressions:,it seems like java, but there have some differents  in  syntax  so that’s we begin!</p><ul><li><code>if</code>&#x2F;<code>else</code></li><li><code>for</code> loops and expressifoons</li><li><code>match</code> expressions</li><li><code>while</code> loops</li><li><code>try</code>&#x2F;<code>catch</code></li></ul><h3 id="if-x2F-else"><a href="#if-x2F-else" class="headerlink" title="if&#x2F;else"></a><code>if</code>&#x2F;<code>else</code></h3><pre><code>if(a&gt;10) print(a) //It can only be written in one sentence</code></pre><p>or like this :</p><pre class="line-numbers language-scala"><code class="language-scala"><span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">></span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{</span>print<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="for-loops-and-expressions"><a href="#for-loops-and-expressions" class="headerlink" title="for loops and expressions"></a>for loops and expressions</h2><p><strong>val</strong> ints &#x3D; <strong>List</strong>(1, 2, 3, 4, 5)</p><p> <strong>for</strong>( i &lt;- ints)  println(i)</p><p>for(i&lt;- 1 to&#x2F;until 10) {</p><p>}</p><p> for (i &lt;- 1 to 10 if i % 2 &#x3D;&#x3D; 1) { </p><p>​     println(i)    </p><p>}</p><p>For each iteration of your for loop, yield generates a value which will be remembered. It’s like the for loop has a buffer you can’t see, and for each iteration of your for loop, another item is added to that buffer. When your for loop finishes running, it will return this collection of all the yielded values. The type of the collection that is returned is the same type that you were iterating over, so a Map yields a Map, a List yields a List, and so on.</p><pre><code>val values:IndexedSeq[Int] = for(i&lt;- 1 to 10 )  yield i*2val list = List(1,2,3,4,5)val arr:Array[Int] = Array(1,2,3,5)val list_01:List[Int] = for(i&lt;-list) yield i*2val arr_01:Array[Int] = for (i&lt;-arr) yield i*2println(values)println(list_01)arr_01.foreach(println)</code></pre><h1 id="3-object-oriented"><a href="#3-object-oriented" class="headerlink" title="3.object-oriented"></a>3.object-oriented</h1><h1 id="4-Functions-and-methods"><a href="#4-Functions-and-methods" class="headerlink" title="4.Functions and methods"></a>4.Functions and methods</h1><h1 id="5-Interface-API"><a href="#5-Interface-API" class="headerlink" title="5.Interface API"></a>5.Interface API</h1><h1 id="6-option"><a href="#6-option" class="headerlink" title="6.option"></a>6.option</h1><h1 id="7-source"><a href="#7-source" class="headerlink" title="7.source"></a>7.source</h1><h1 id="8-Use-of-higher-order-functions"><a href="#8-Use-of-higher-order-functions" class="headerlink" title="8. Use of higher-order functions"></a>8. Use of higher-order functions</h1><h1 id="9-Implicit-conversion"><a href="#9-Implicit-conversion" class="headerlink" title="9. Implicit conversion"></a>9. Implicit conversion</h1><h1 id="10-Generics"><a href="#10-Generics" class="headerlink" title="10. Generics"></a>10. Generics</h1><h1 id="11-Collection"><a href="#11-Collection" class="headerlink" title="11.Collection"></a>11.Collection</h1><p>refresh ……..</p>]]></content>
      
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集(set)和映射(Map)</title>
      <link href="/2022/04/25/%E9%9B%86set%E5%92%8C%E6%98%A0%E5%B0%84Map/"/>
      <url>/2022/04/25/%E9%9B%86set%E5%92%8C%E6%98%A0%E5%B0%84Map/</url>
      
        <content type="html"><![CDATA[<p>默认情况下 你使用的set or map 都是不可变的对象   如果可变需要提前声明</p><p>以下是创建可变的集合</p><pre class="line-numbers language-scala"><code class="language-scala"><span class="token keyword">package</span> com<span class="token punctuation">.</span>heima<span class="token punctuation">.</span>arrp<span class="token keyword">import</span> scala<span class="token punctuation">.</span>collection<span class="token punctuation">.</span>mutable<span class="token comment" spellcheck="true">/** * @author lyc * @date 2022/4/25 11:30   * @version V1.0.0 */</span><span class="token keyword">object</span> Map_prc <span class="token punctuation">{</span>  <span class="token keyword">def</span> map<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> map01 <span class="token operator">=</span> mutable<span class="token punctuation">.</span>Map<span class="token punctuation">(</span><span class="token string">"aa"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> set01 <span class="token operator">=</span> mutable<span class="token punctuation">.</span>Set<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="set集合的基本使用"><a href="#set集合的基本使用" class="headerlink" title="set集合的基本使用"></a>set集合的基本使用</h2><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220425113431055.png"></p><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h3><ol><li><code>var 变量=Set()</code> （创建空的Set集合）</li><li><code>var 变量=Set[类型]()</code>  &#x2F;&#x2F;写死后里面的元素只能是set规定的数据类型</li></ol><p>scala内部能简化的全部帮你简化了</p><h3 id="2-差集和补集"><a href="#2-差集和补集" class="headerlink" title="2.差集和补集"></a>2.差集和补集</h3><ol><li>&amp;返回两个集合的交集</li><li>&amp;~返回两个集合的差集</li><li>++合并两个集合</li><li>diff比较两个集合的差集</li></ol><h3 id="3-遍历"><a href="#3-遍历" class="headerlink" title="3.遍历"></a>3.遍历</h3><ul><li>通过for（i &lt;- x )</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis概述</title>
      <link href="/2022/04/15/redis%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/04/15/redis%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Redis是用C语言开发的一个开源的高性能基于内存运行的键值对NoSQL数据库</p><p>Redis（Remote Dictionary Server 远程字段服务）是一个开源的使用ANSI C语言编写、支持网络、科技与<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>亦可持久化的日志型、key-value数据库，并提供多种语言的API。</p><p>(1) 支持数据的持久化，可以将数据保存在磁盘中，重启之后可以再次加载到内存中使用<br>(2) 支持多种数据类型，除了KV类型的数据，还支持list、set、<a href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a>等数据结构<br>(3) 支持master-slave模式的数据备份</p><h2 id="二、Redis应用场景"><a href="#二、Redis应用场景" class="headerlink" title="二、Redis应用场景"></a>二、Redis应用场景</h2><ol><li>热点数据加速查询(主要场景)，如热点商品、热点信息等访问量较高的数据</li><li>即时信息查询，如公交到站信息、在线人数信息等</li><li>时效性信息控制，如验证码控制、投票控制等</li><li>分布式数据共享，如分布式集群架构中的session分离消息队列</li></ol><h3 id="1-NoSQL技术"><a href="#1-NoSQL技术" class="headerlink" title="1.NoSQL技术"></a>1.NoSQL技术</h3><p>为了克服上述问题，java web项目通常会引入NoSQL技术，这是一种基于内存的数据库，并且提供一定的持久化功能。</p><p>Redis和MongoDB是当前使用最广泛的NoSQL， 而就Redis技术而言，它的性能十分优越，可以支持每秒十几万的读写操作，其性能远超数据库，并且还支持集群、。分布式、主从同步等配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还支持一定的事务能力，这保证了高并发的场景下数据的安全和一致性。</p><h3 id="2-高并发和快速原因"><a href="#2-高并发和快速原因" class="headerlink" title="2.高并发和快速原因"></a>2.高并发和快速原因</h3><p>Redis是基于内存的，内存的读写速度非常快；<br>Redis是单线程的，省去了很多上下文切换线程的时间；<br>Redis使用多路复用技术，可以处理并发的连接。非IO内部实现采用epoll，采用了epoll自己实现的简单的事件框架。epoll的读写、关闭、连接都转化为事件，然后利用epoll的多路复用特性，绝不在IO上浪费一点时间。</p><h3 id="3-单线程的优劣势"><a href="#3-单线程的优劣势" class="headerlink" title="3.单线程的优劣势"></a>3.单线程的优劣势</h3><p>1、优势</p><p>代码更清晰，处理逻辑更简单</p><p>不用考虑各种锁的问题，不存在加锁和释放锁的操作，没有因为可能出现死锁而导致的性能消耗</p><p>不存在多线程切换而消耗CPU</p><p>2、劣势</p><p>无法发挥多核CPU性能优势，不过可以通过单击开多个Redis实例来完善。</p><h3 id="4-Redis高并发总结"><a href="#4-Redis高并发总结" class="headerlink" title="4.Redis高并发总结"></a>4.Redis高并发总结</h3><p>1、Redis是纯内存数据库，一般都是简单存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快；</p><p>2、Redis使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成事件，减少了线程切换时上下文切换和竞争。</p><p>3、Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。</p><p>4、Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如跳表，使用有序的数据结构加快读写的速度。</p><p>5、Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</p><h2 id="三、Redis基础知识"><a href="#三、Redis基础知识" class="headerlink" title="三、Redis基础知识"></a>三、Redis基础知识</h2><p>Redis采用单线程机制进行工作</p><p>Redis默认拥有16个数据库，数据库编号从0开始，默认使用0号数据库</p><p>使用select 数据库编号 可以切换使用的数据库</p><p>dbsize 命令查看当前数据库key的数量</p><p>keys * 命令查看当前数据库所有的key</p><p>flushdb 命令清空当前数据库</p><p>flushall 命令清空所有数据库</p><p>Redis中所有数据库使用同一个密码，默认没有密码，Redis认为安全层面应该由Linux来保证</p><p>Redis中所有索引都是从0开始</p><p>Redis默认端口是6379</p>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文数</title>
      <link href="/2022/04/10/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
      <url>/2022/04/10/%E5%9B%9E%E6%96%87%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>例如，121 是回文，而 123 不是。</p><pre><code>输入：x = 121输出：true</code></pre><pre><code>输入：x = -121输出：false解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</code></pre><p>解法一：</p><p>利用StringBuffer </p><p>思路 ： 负数肯定不是回文数 直接返回false </p><p>创建 StringBuff对象 进行比较 </p><p>通过String.valueof 方法 转成一个字符串进行 比较 </p><pre class="line-numbers language-java"><code class="language-java">     <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        StringBuffer s<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解法二：<br>数学（推荐）</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>num<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            cur <span class="token operator">=</span> cur<span class="token operator">*</span><span class="token number">10</span> <span class="token operator">+</span>num<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>            num <span class="token operator">/=</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cur<span class="token operator">==</span>x<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scala的伴生对象</title>
      <link href="/2022/04/06/scala%E7%9A%84%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1/"/>
      <url>/2022/04/06/scala%E7%9A%84%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h1><p>​    一个class和object具有同样的名字。这个object称为<strong>伴生对象</strong>，这个class称为<strong>伴生类</strong></p><ul><li>伴生对象必须要和伴生类一样的名字；</li><li>伴生对象和伴生类在同一个scala源文件中；</li><li>伴生对象和伴生类可以互相访问<strong>private</strong>属性。</li></ul><p>作用 ：让伴生类更好访问到伴生对象的私有属性和方法</p><p>一旦私有 main方法直接不能调  严格的权限控制</p><h2 id="1-单例对象-object"><a href="#1-单例对象-object" class="headerlink" title="1.单例对象(object)"></a>1.单例对象(object)</h2><p>scala中是没有static关键字的，要想定义类似于Java中的static变量、static方法，就要使用到scala中的单例对象了, 也就是object。</p><h2 id="2-定义单例对象"><a href="#2-定义单例对象" class="headerlink" title="2.定义单例对象"></a>2.定义单例对象</h2><p>object 单例对象名{ } &#x2F;&#x2F; 定义一个单例对象 也可以解释为什么main方法是静态的了</p><p>网上说的什么伴生对像之间可以互相访问跟情侣一样同生死 只有伴生类能够访问伴生对象中的私有属性和对象  我尝试了 一下 明明只有类可以访问到 对象访问不到类的东西。</p><p>但后来慢慢发现我放了一个错误</p><p>伴生对象不实例化类的对象，怎么访问伴生类中定义的私有属性？不实例化 伴生对象是类的一个傀儡</p><p>就是必须要在伴生对象的中定义个方法去实例化它</p><h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><p>class Person{</p><p>}</p><p> var op ：person &#x3D;  new Person（）实例化后才能调用</p><p>但我们一般都是在main方法中实例化的 （java的思维） 真的sorry</p><h2 id="3-案例1-2-3"><a href="#3-案例1-2-3" class="headerlink" title="3.案例1 2 3"></a>3.案例1 2 3</h2><p>ps：可以试着运行下</p><p>可以尝试着把伴生对象理解 成用static 修饰的类</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>atiguigu<span class="token punctuation">.</span>prc<span class="token comment" spellcheck="true">/** * @author lyc * @date 2022/4/10 20:50   * @version V1.0.0 */</span>object Logger <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//单例对象 不能带参数 不能实例化 没有机会向单例对象传参</span>  <span class="token comment" spellcheck="true">//在第一次调用的时候进行 初始化</span>  <span class="token comment" spellcheck="true">//静态方法 一加上private就没办法访问了</span>    def <span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token operator">:</span>String<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token string">"info:$msg"</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>  def <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span><span class="token punctuation">{</span>    Logger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"林杰"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//为什么要有 object定义main方法 因为static 被scala完全给隔绝了</span><span class="token comment" spellcheck="true">//scala是高度化的面向对象语言 不允许静态和非静态属性和方法 糅杂在一起 所以就用一个</span><span class="token comment" spellcheck="true">//object 单例对象</span><span class="token comment" spellcheck="true">//程序入口</span>object LoggerTest<span class="token punctuation">{</span>  def <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span>String<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span>    Logger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"林杰1"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//类名.方法名</span>    val obj <span class="token operator">:</span>Test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    obj<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>atiguigu<span class="token punctuation">.</span>prc<span class="token comment" spellcheck="true">/** * @author lyc * @date 2022/4/10 20:56   * @version V1.0.0 */</span><span class="token keyword">class</span> <span class="token class-name">AccountInfo</span> <span class="token punctuation">{</span>  var id <span class="token operator">=</span><span class="token number">0</span>  id <span class="token operator">=</span> AccountInfo<span class="token punctuation">.</span><span class="token function">newUniqueNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//之间的特点 互相访问对方的私有属性和方法</span><span class="token comment" spellcheck="true">//称为类的伴生对象</span>object AccountInfo<span class="token punctuation">{</span>  <span class="token keyword">private</span> var last_num <span class="token operator">=</span><span class="token number">0</span>  <span class="token keyword">private</span>  def <span class="token function">newUniqueNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">{</span>    last_num <span class="token operator">+=</span><span class="token number">2</span>    last_num  <span class="token punctuation">}</span><span class="token punctuation">}</span>object  compannionTest<span class="token punctuation">{</span>  def <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span>String<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span>    var obj <span class="token operator">:</span>AccountInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AccountInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>id<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>atiguigu<span class="token punctuation">.</span>prc<span class="token comment" spellcheck="true">/** * @author lyc * @date 2022/4/10 21:15   * @version V1.0.0 */</span><span class="token comment" spellcheck="true">//类自带无参的构造器 开发者把这些觉得重复的东西全部省略了</span><span class="token comment" spellcheck="true">//set get 底层封装起来了</span><span class="token comment" spellcheck="true">// 有参构造函数 直接 给class（）java中是不允许的！！</span><span class="token comment" spellcheck="true">//scala中的构造器 有两种</span><span class="token comment" spellcheck="true">// 主构造函数 和 辅助构造函数</span><span class="token comment" spellcheck="true">// 记住一点 辅助构造函数是在 类中的  定义必须以this开头 以下是具体例子</span><span class="token comment" spellcheck="true">// 调用辅助构造函数 根据传参来区分是第几个辅助构造函数</span>object Constructorc <span class="token punctuation">{</span>  def <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span>String<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span>    val obj <span class="token operator">:</span>Const <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Const</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>    var obj1 <span class="token operator">:</span>Confuse <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Confuse</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>a<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Const</span><span class="token punctuation">{</span>  var a <span class="token operator">=</span> <span class="token number">10</span>  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1调用无参的构造函数"</span><span class="token punctuation">)</span>  <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  def <span class="token keyword">this</span><span class="token punctuation">(</span>a1<span class="token operator">:</span>Int<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//调用主构造函数 必须的一步！！！</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2调用有参的构造函数"</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a1  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//有参的构造函数</span><span class="token comment" spellcheck="true">//如果用 var就是放在类里面的一个属性 不带则为参数 注意一下</span><span class="token comment" spellcheck="true">//class Confuse{</span><span class="token comment" spellcheck="true">// int a</span><span class="token keyword">class</span> <span class="token class-name">Confuse</span><span class="token punctuation">(</span>a <span class="token operator">:</span>Int<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2022/04/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/04/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><pre><code>输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4</code></pre><pre class="line-numbers language-java"><code class="language-java">   <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span><span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// // 当left==right，区间[left, right]依然有效，所以用 &lt;=</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left<span class="token operator">+</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 防止溢出 等同于(left + right)/2</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//target 在左区间，所以[left, mid - 1]</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>                left <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// target 在右区间，所以[mid + 1, right]</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//数组中找到目标值，直接返回下标</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组去重</title>
      <link href="/2022/04/05/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
      <url>/2022/04/05/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<p>数组去重也是比经典的一个算法 这里演示了三种不同的数组去重操作</p><p>1.利用Hashset本身无序的特性进行去重</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test04</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span>arr<span class="token punctuation">)</span><span class="token punctuation">{</span>            set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.利用ArrayList进行去重</p><pre><code>    public void remove() &#123;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        int[] arr = &#123;1, 2, 3, 4, 5, 6, 2, 3, 4&#125;;        for (int i :arr)&#123;            if (!list.contains(i))&#123;                list.add(i);            &#125;        &#125;        System.out.println(list);    &#125;&#125;</code></pre><p>3.双重for循环</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> Arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>x<span class="token operator">&lt;</span>temp<span class="token punctuation">.</span>length<span class="token punctuation">;</span>x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">boolean</span> flag<span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> y<span class="token operator">=</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>y<span class="token operator">&lt;</span>temp<span class="token punctuation">.</span>length<span class="token punctuation">;</span>y<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">==</span>temp<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    flag<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span>               Arr<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>temp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除LinkedList中的重复项</title>
      <link href="/2022/04/02/%E5%88%A0%E9%99%A4LinkedList%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/2022/04/02/%E5%88%A0%E9%99%A4LinkedList%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="CHARACTER"><a href="#CHARACTER" class="headerlink" title="CHARACTER"></a>CHARACTER</h1><p>Q:LinkedList 去除重复元素</p><p>阿牛最近在学习 <code>LinkedList</code> 的知识，现在他想要测试一下自己究竟学会了多少，他成功的发现了自己并没有掌握相关知识点，现在需要你帮助他完成这道题目，给定六个字符串，将这些字符串存放在 <code>LinkedList</code> 中，然后将 <code>LinkedList</code> 中重复的元素删除，最后将 <code>LinkedList</code> 中所有元素用迭代器方式打印在标准输出流（控制台）中，请你帮助她完成这道题目。</p><p>挺简单的一道题 代码如下 </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Iterator<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>LinkedList<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//解法一</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Permanent</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> LinkedList<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">Weighting</span><span class="token punctuation">(</span>LinkedList<span class="token operator">&lt;</span>String<span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LinkedList<span class="token operator">&lt;</span>String<span class="token operator">></span>linkedList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> iterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            String str <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>linkedList<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                linkedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> linkedList<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//解法二</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Permanent</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> LinkedList<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">Weighting</span><span class="token punctuation">(</span>LinkedList<span class="token operator">&lt;</span>String<span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            HashSet set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Iterator iter <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                String str <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    iter<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> list<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala中的Map集合</title>
      <link href="/2022/03/31/Scala%E4%B8%AD%E7%9A%84Map%E9%9B%86%E5%90%88/"/>
      <url>/2022/03/31/Scala%E4%B8%AD%E7%9A%84Map%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="不可变MAP"><a href="#不可变MAP" class="headerlink" title="不可变MAP"></a>不可变MAP</h1><p>Map(映射)是一种可迭代的键值对（key&#x2F;value）结构。<br>所有的值都可以通过键来获取。<br>Map 中的键都是唯一的。<br>Map 也叫哈希表（Hash tables）。<br>Map 有两种类型，可变与不可变，区别在于可变对象可以修改它，而不可变对象不可以。<br>默认情况下 Scala 使用不可变 Map。如果你需要使用可变集合，你需要显式的引入 import scala.collection.mutable.Map 类<br>在Scala中你可以同时使用可变与不可变 Map,不可变的直接使用 Map,可变的使用 mutable.Map.以下实例演示了不可变 Map 的应用：</p><pre class="line-numbers language-java"><code class="language-java">def <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span>String<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span> val p<span class="token operator">:</span> Map<span class="token punctuation">[</span>String<span class="token punctuation">,</span> Int<span class="token punctuation">]</span> <span class="token operator">=</span> Map<span class="token punctuation">[</span>String<span class="token punctuation">,</span> Int<span class="token punctuation">]</span><span class="token punctuation">(</span>   <span class="token string">"CK"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">15</span><span class="token punctuation">,</span>   <span class="token string">"PH"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">25</span><span class="token punctuation">,</span>   <span class="token string">"PW"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">35</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两种获取值的方式</p><pre class="line-numbers language-java"><code class="language-java">   val values<span class="token operator">:</span> Option<span class="token punctuation">[</span>Int<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"PH"</span><span class="token punctuation">)</span>   <span class="token function">println</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span>get<span class="token punctuation">)</span>          val age <span class="token operator">:</span>Int  <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span><span class="token string">"PW"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">println</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span>         <span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>keys<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//返回所有的key;</span>  <span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>values<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//返回所有的value;</span>  <span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>isEmpty<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//当map为空时,返回true;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="可变MAP"><a href="#可变MAP" class="headerlink" title="可变MAP"></a>可变MAP</h1><p>​    </p><pre><code>  def main(args: Array[String]): Unit = &#123;    val personalMap  = scala.collection.mutable.Map[String,Int](      &quot;kw&quot; -&gt;7,      &quot;dk&quot;-&gt;20    )    for(kb&lt;-personalMap)&#123;      val key =kb._1;      val value = kb._2      println(key+value)    &#125;    personalMap.foreach(x=&gt;println(x))  &#125;</code></pre><pre class="line-numbers language-java"><code class="language-java">def <span class="token function">map3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//不可变Map+var关键词修饰例子</span>  var a<span class="token operator">:</span>scala<span class="token punctuation">.</span>collection<span class="token punctuation">.</span>mutable<span class="token punctuation">.</span>Map<span class="token punctuation">[</span>String<span class="token punctuation">,</span>Int<span class="token punctuation">]</span><span class="token operator">=</span>scala<span class="token punctuation">.</span>collection<span class="token punctuation">.</span>mutable<span class="token punctuation">.</span><span class="token function">Map</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"k2"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//初始化构造函数</span>  a <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token string">"k3"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//添加元素</span>  a <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token string">"k4"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//添加元素</span>  a <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">100</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//已经存在添加元素会覆盖</span>  a <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">100</span><span class="token punctuation">,</span><span class="token string">"k9"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">9</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//添加多个元素</span>  a <span class="token operator">-=</span> <span class="token punctuation">(</span><span class="token string">"k2"</span><span class="token punctuation">,</span><span class="token string">"k1"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//删除元素</span>  a <span class="token operator">++</span><span class="token operator">=</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token string">"CA"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token string">"CO"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//追加集合</span>  a <span class="token operator">--</span><span class="token operator">=</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token string">"AL"</span><span class="token punctuation">,</span> <span class="token string">"AZ"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//删除集合</span>   a<span class="token punctuation">.</span><span class="token function">retain</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> k<span class="token operator">==</span><span class="token string">"k1"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//只保留等于k1元素，其他的删除</span>  a<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"put1"</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//put</span>  a<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"k2"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//remove</span>  a<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//清空</span>  <span class="token function">a</span><span class="token punctuation">(</span><span class="token string">"k3"</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">100</span><span class="token comment" spellcheck="true">//支持</span>   <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"k6"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//是否包含某元素</span>  <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//打印大小</span>  <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//根据key读取元素，不存在就替换成默认值</span>  a<span class="token punctuation">.</span>foreach<span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span>i<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//遍历打印1</span>  <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>k<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">-</span>a <span class="token punctuation">)</span> <span class="token function">println</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>v<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//遍历打印2</span>  <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>isEmpty<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//判断是否为空</span>  a<span class="token punctuation">.</span>keys<span class="token punctuation">.</span><span class="token function">foreach</span><span class="token punctuation">(</span>println<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//只打印key</span>  a<span class="token punctuation">.</span>values<span class="token punctuation">.</span><span class="token function">foreach</span><span class="token punctuation">(</span>println<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//只打印value</span>  a<span class="token operator">=</span>scala<span class="token punctuation">.</span>collection<span class="token punctuation">.</span>mutable<span class="token punctuation">.</span><span class="token function">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//引用能变</span>  <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>size<span class="token punctuation">)</span>  a<span class="token punctuation">.</span>toSeq<span class="token punctuation">.</span><span class="token function">sortBy</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>_1<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//排序 key</span>  a<span class="token punctuation">.</span>toSeq<span class="token punctuation">.</span><span class="token function">sortBy</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>_2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//排序 value</span>  a<span class="token punctuation">.</span>toSeq<span class="token punctuation">.</span><span class="token function">sortWith</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>_1<span class="token operator">></span>_<span class="token punctuation">.</span>_1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//降序排序 key</span>  a<span class="token punctuation">.</span>toSeq<span class="token punctuation">.</span><span class="token function">sortWith</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>_2<span class="token operator">></span>_<span class="token punctuation">.</span>_2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//降序排序 value</span>        <span class="token comment" spellcheck="true">//下面自定义按英文字母或数字排序</span>  implicit  val KeyOrdering<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Ordering</span><span class="token punctuation">[</span>String<span class="token punctuation">]</span> <span class="token punctuation">{</span>    override def <span class="token function">compare</span><span class="token punctuation">(</span>x<span class="token operator">:</span> String<span class="token punctuation">,</span> y<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token punctuation">{</span>      x<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>toSeq<span class="token punctuation">.</span>sorted<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于StringBuider的使用</title>
      <link href="/2022/03/30/%E5%85%B3%E4%BA%8EStringBuider%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/03/30/%E5%85%B3%E4%BA%8EStringBuider%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="String与StringBuilder的区别"><a href="#String与StringBuilder的区别" class="headerlink" title="String与StringBuilder的区别"></a>String与StringBuilder的区别</h1><h2 id="1-String"><a href="#1-String" class="headerlink" title="1.String"></a>1.String</h2><p>String类位于Java的lang包下 无需导包即可调用</p><p>String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间</p><p>每创建一个String对象就要在栈中 开辟空间 当修改String的值的时候 会在堆中新开辟一块空间 造成空间的浪费</p><h4 id="用String类创建对象通常有两种形式："><a href="#用String类创建对象通常有两种形式：" class="headerlink" title="用String类创建对象通常有两种形式："></a>用String类创建对象通常有两种形式：</h4><p>1、String str &#x3D; “abc”</p><p>2、String str1 &#x3D; new String(“abc”);</p><p>方法1：通过字面量直接给字符串进行赋值，在栈中创建字符串str时，会先在字符串常量池中检查是否已有该字符串，如果没有则创建并存入字符串常量池中，如果已存在则直接从常量池中获取。</p><p>方法2：创建的字符串，不管内存有没有为“abc”字符串分配内存，都会在内存中重新分配一个内存区域存放“abc”，然后用str1指向它，相当于内存中有两个“abc”，只是存放的地址不一样。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>1、public String();</p><p>String类的无参构造方法，用来创建空字符串的String类；</p><p>案例：String str &#x3D; new String();</p><p>2、public String(String value);</p><p>用已知的字符串value值来创建一个字符串对象；</p><p>案例：String str1 &#x3D; new String(“aaa”);</p><p>3、public String(char[] value)</p><p>用字符数组value创建一个String对象。</p><p>案例：char[] value &#x3D; {“ab”,”cd”,”efg”};</p><h2 id="2-StringBuffer"><a href="#2-StringBuffer" class="headerlink" title="2. StringBuffer"></a>2. StringBuffer</h2><p> StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量 </p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/20180411092328691"></p><p><img src="C:\Users\lyc\AppData\Roaming\Typora\typora-user-images\image-20220330183450896.png"></p><p>我们调用equals方法  显而易见结果是false</p><p>一些常用的方法 看参数 你应该就知道如何使用  无非就是增删改查 类型转换 多练即可掌握</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220330183812261.png"></p><p> (1) String中的是常量(final)数组，只能被赋值一次。<br>   比如：new String(“abc”)使得value[]&#x3D;{‘a’,’b’,’c’}(查看jdk String 就是这么实现的)，之后这个String对象中的value[]再也不能改变了。这也正是大家常说的，String是不可变的原因 。<br>   注意：这个对初学者来说有个误区，有人说String str1&#x3D;new String(“abc”); str1&#x3D;new String(“cba”);不是改变了字符串str1吗？那么你有必要先搞懂对象引用和对象本身的区别。这里我简单的说明一下，对象本身指的是存放在堆空间中的该对象的实例数据(非静态非常量字段)。而对象引用指的是堆中对象本身所存放的地址，一般方法区和Java栈中存储的都是对象引用，而非对象本身的数据。</p><p>   (2) StringBuffer中的value[]就是一个很普通的数组，而且可以通过append()方法将新字符串加入value[]末尾。这样也就改变了value[]的内容和大小了。</p><p>   比如：new StringBuffer(“abc”)使得value[]&#x3D;{‘a’,’b’,’c’,’’,’’…}(注意构造的长度是str.length()+16)。如果再将这个对象append(“abc”)，那么这个对象中的value[]&#x3D;{‘a’,’b’,’c’,’a’,’b’,’c’,’’….}。这也就是为什么大家说 StringBuffer是可变字符串 的涵义了。从这一点也可以看出，StringBuffer中的value[]完全可以作为字符串的缓冲区功能。其累加性能是很不错的</p><p>   总结，讨论String和StringBuffer可不可变。本质上是指对象中的value[]字符数组可不可变，而不是对象引用可不可变。 </p><h2 id="3-StringBuilder"><a href="#3-StringBuilder" class="headerlink" title="3.StringBuilder"></a>3.StringBuilder</h2><p>程序开发过程中，我们常常碰到字符串连接的情况，方便和直接的方式是通过”+”符号来实现，但是这种方式达到目的的效率比较低，且每执行一次都会创建一个String对象，即耗时，又浪费空间。使用<a href="https://so.csdn.net/so/search?q=StringBuilder%E7%B1%BB&spm=1001.2101.3001.7020">StringBuilder类</a>就可以避免这种问题的发生，下面就Stringbuilder的使用做个简要的总结：</p><p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&spm=1001.2101.3001.7020">线程安全</a>的（不能同步访问）。</p><p>由于 StringBuilder 相较于 StringBuffer 有速度优势，<strong>所以多数情况下建议使用 StringBuilder 类</strong>。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p><h3 id="String和StringBuilder的区别："><a href="#String和StringBuilder的区别：" class="headerlink" title="String和StringBuilder的区别："></a>String和StringBuilder的区别：</h3><p>   ●String：内容不可变   </p><p>   ●StringBuilder：内容是可变的</p><p>好处：效率高   但线程不安全</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1.无参数  stringBuilder  s&#x3D;new stringBuilder();</p><p>实例化时会有一个默认的16字符的空间，当追加字符超过16个字符时，会新开一个翻倍的空间，而原油空间会浪费掉</p><p>2.有参数：stringBulider s&#x3D;new stringBuilder(20);</p><p>可以在实例化的时候创建一个固定大小的空间，避免资源的浪费。</p><p>常见的方法：</p><p>StringBuilder的常见用法。</p><p>1、初始化一个StringBuilder。</p><pre><code>StringBuilder sb = new StringBuilder()；</code></pre><p>2、填充：使用append() 来追加字符串填充到sb中：</p><pre><code>  sb.append(&quot;xxxx&quot;).append(&quot; xxx&quot;)....可继续延伸</code></pre><p>3、删除sb里面的已有的内容：</p><pre><code>  sb.delete(0,sb.length());将删除sb里面从0开始到结尾的所有内容，也可以自己定义区间</code></pre><p>4、sb里面的内容要显示时需要转换成String类型</p><pre><code>  System.out.println(sb.toString());r reverse() 返回相反的字符序列</code></pre><p>5.reverse 可以反转</p><h2 id="4-从源码出发（进阶）吊打面试官"><a href="#4-从源码出发（进阶）吊打面试官" class="headerlink" title="4.从源码出发（进阶）吊打面试官"></a>4.从源码出发（进阶）吊打面试官</h2><p>stringbuffer和stringbuild区别<br>1、StringBuffer 与 StringBuilder 是长度可变得。<br>2、只是StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。<br>3、在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全。而StringBuffer则每次都需要判断锁，效率相对更低。</p><p>public final class String implements java.io.Serializable, Comparable<String>, CharSequence {<br>    &#x2F;** The value is used for character storage. *&#x2F;<br>    private final char value[];</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** Cache the hash code for the string */</span><span class="token keyword">private</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Default to 0</span><span class="token comment" spellcheck="true">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span>6849794470754667710L<span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">&lt;=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Note: offset or count might be near -1>>>1.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">></span> value<span class="token punctuation">.</span>length <span class="token operator">-</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>offset <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> offset<span class="token operator">+</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个被final关键字修饰的char[]数组，所以实现细节上也是不允许改变，这就是String类的Immutable（不可变）属性(你知道String类为什么不能被继承吗？)，导致每次对String的操作都会生成新的String对象导致每次对String的操作都会生成新的String对象，这样不仅效率低下，而且大量浪费有限的内存空间。<br>2、StringBuffer和StringBuild</p><p>public final class StringBuilder    extends AbstractStringBuilder    implements java.io.Serializable, CharSequence {}</p><p>public final class StringBuffer    extends AbstractStringBuilder    implements java.io.Serializable, CharSequence {}</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>    <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span><span class="token punctuation">,</span> Comparable<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** The value is used for character storage. */</span><span class="token comment" spellcheck="true">//final修饰的char数组</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractStringBuilder</span> <span class="token keyword">implements</span> <span class="token class-name">Appendable</span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * The value is used for character storage.     */</span>    <span class="token comment" spellcheck="true">//stringbuilder和stringbuffer都继承了AbstractStringBuilder 但AbstractStringBuilder 中的     </span><span class="token comment" spellcheck="true">//char数组没有使用final修饰，这就是为什么string是不可变，但stringbuffer和stringbuilder是可变的</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/**     * The count is the number of characters used.     */</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/**     * This no-arg constructor is necessary for serialization of subclasses.     */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过Stringbuffer和Stringbuilder的源码和类结构图，可以发现Stringbuilder和Stringbuffer都是继承了abstractStringbuilder这个抽象类，然后实现了Serializable, CharSequence接口。其次Stringbuilder和Stringbuffer的内部实现其实跟String是一样的，都是通过一个char类型的数组进行存储字符串的，但是是String类中的char数组是final修饰的，是不可变的，而StringBuilder和StringBuffer中的char数组没有被final修饰，是可变的。这就是StringBuilder和StringBuffer和String的区别。</p><p>在多线程编程中有个概念叫原子操作，原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有切换到任何的一个其他的线程）。上述代码中的count+&#x3D;len就不是一个原子操作，它等同于count&#x3D;count+len，比如在上诉代码中，执行到count的值为99998的时候，新建一个len长度为1，但是当有两个线程同时执行到了count+&#x3D;len的时候，他们的count的值都是99998，然后分别各自都执行了count+&#x3D;len，则执行完之后的值都是99999，然后将值赋给count，则count最后的结果是99999，不是正确的100000，所以在多线程中执行stringbuilder的值始终会小于正确的结果。但是StringBuilder和stringbuffer都是继承了abstractstringbuilder为什么结果不一样呢。既然abstractstringbuilder中的append方法肯定都是一样的,再来看看stringbuffer中的</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token comment" spellcheck="true">//append操作被synchronized 关键字修饰了</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> StringBuffer <span class="token function">append</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        toStringCache <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>   <span class="token comment" spellcheck="true">//append操作被synchronized 关键字修饰了</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> StringBuffer <span class="token function">append</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        toStringCache <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现stringbuffer中的append操作被synchronized关键字修饰了。这个关键字肯定不会陌生，主要用来保证多线程中的线程同步和保证数据的准确性。所以再多线程中使用stringbuffer是线程安全的。在AbstractStringBuilder的append方法中有这样的两个个操作:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>count <span class="token operator">+</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//1</span>str<span class="token punctuation">.</span><span class="token function">getChars</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> value<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>转到第一个操作方法的源码，可以发现这是一个是检查StringBuilder对象的原数组的大小是否能装下新的字符串的方法，如果装不下了就new一个新的数组，新的数组的容量是原来char数组的两倍，再通过CopyOf()方法将原数组的内容复制到新数组。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * For positive values of {@code minimumCapacity}, this method     * behaves like {@code ensureCapacity}, however it is never     * synchronized.     * If {@code minimumCapacity} is non positive due to numeric     * overflow, this method throws {@code OutOfMemoryError}.     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minimumCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// overflow-conscious code</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minimumCapacity <span class="token operator">-</span> value<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            value <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span>                    <span class="token function">newCapacity</span><span class="token punctuation">(</span>minimumCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后第二步操作是将String对象里面char数组里面的内容拷贝到StringBuilder对象的char数组里面。getchars源码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getChars</span><span class="token punctuation">(</span><span class="token keyword">int</span> srcBegin<span class="token punctuation">,</span> <span class="token keyword">int</span> srcEnd<span class="token punctuation">,</span> <span class="token keyword">char</span> dst<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> dstBegin<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//1       </span> <span class="token keyword">if</span> <span class="token punctuation">(</span>srcBegin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>srcBegin<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//2   </span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>srcEnd <span class="token operator">></span> value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>srcEnd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//3   </span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>srcBegin <span class="token operator">></span> srcEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>srcEnd <span class="token operator">-</span> srcBegin<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> srcBegin<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> dstBegin<span class="token punctuation">,</span> srcEnd <span class="token operator">-</span> srcBegin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到原来在这里会抛出StringIndexOutOfBoundsException的异常。假设前面的代码中有两个线程a和线程b同时执行了append方法，并且都执行完了ensureCapacityInternal()方法，这个时候count的值为99997，如果当线程a执行完了，则轮到线程2继续执行，线程b执行完了append方法之后，count变成了99998，这个时候如果线程a执行到了上面的getchars方法的时候线程a得到的count的值就是99998了，而它本来的值应该是99997，所以在这个时候就会抛出ArrayIndexOutOfBoundsException的异常了。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建mybatis指南</title>
      <link href="/2022/03/27/%E6%90%AD%E5%BB%BAmybatis%E6%8C%87%E5%8D%97/"/>
      <url>/2022/03/27/%E6%90%AD%E5%BB%BAmybatis%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="一、搭建MyBatis"><a href="#一、搭建MyBatis" class="headerlink" title="一、搭建MyBatis"></a>一、<strong>搭建</strong>MyBatis</h1><h2 id="1-开发环境"><a href="#1-开发环境" class="headerlink" title="1.开发环境"></a>1.开发环境</h2><p>IDEA version : 2021.2.2</p><p>mysql version ：8.0.23</p><p>mybatis version : 3.5.2</p><p>maven version : 3.5.7</p><h2 id="2-创建maven工程"><a href="#2-创建maven工程" class="headerlink" title="2.创建maven工程"></a>2.创建maven工程</h2><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220327134903258.png"></p><p>next-&gt;Name(存放路径)-&gt;groupID(com.lyc.mybatis)-&gt;finish</p><p>加入依赖</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.11<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.5.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>8.0.25<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.13.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-创建数据库连接信息配置文件"><a href="#3-创建数据库连接信息配置文件" class="headerlink" title="3.创建数据库连接信息配置文件"></a>3.创建数据库连接信息配置文件</h2><p>在项目中的src&#x2F;main&#x2F;resources目录下创建db.properties</p><pre class="line-numbers language-sql"><code class="language-sql">driver <span class="token operator">=</span> com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>cj<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>Driverurl <span class="token operator">=</span> jdbc:mysql:<span class="token comment" spellcheck="true">//localhost:3306/mybatis?serverTimezone=UTC&amp;\</span>            characterEncoding<span class="token operator">=</span>utf8<span class="token operator">&amp;</span>useUnicode<span class="token operator">=</span><span class="token boolean">true</span><span class="token operator">&amp;</span>useSSL<span class="token operator">=</span><span class="token boolean">false</span>username <span class="token operator">=</span> rootpassword <span class="token operator">=</span> <span class="token number">123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-创建MyBatis的核心配置文件"><a href="#4-创建MyBatis的核心配置文件" class="headerlink" title="4.创建MyBatis的核心配置文件"></a>4.创建MyBatis的核心配置文件</h2><p>在项目中的src&#x2F;main&#x2F;resources目录下创建MyBatis的核心配置文件</p><p>用于项目的环境配置，如数据库连接相关配置等。建议命名为mybatis-config.xml</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?></span> <span class="token doctype">&lt;!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>db.properties<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!--设置连接数据库的环境--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environments</span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environment</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManager</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POOLED<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driver<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${driver}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${url}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${username}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${password}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataSource</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environment</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environments</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--引入映射文件--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mappers/UserMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数详细：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?></span>  xml的版本号<span class="token doctype">&lt;!DOCTYPE configuration  mybatis中的约束  dtd文件        PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"></span>configuration 根标签environments 可嵌套多个单数标签 <span class="token comment" spellcheck="true">&lt;!--设置连接数据库的环境--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--引入映射文件--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManager</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> 事务的管理方式以jdbc的方式进行管理<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POOLED<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> 数据库连接池 下一次使用直接调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-创建POJO实体"><a href="#5-创建POJO实体" class="headerlink" title="5.创建POJO实体"></a>5.创建POJO实体</h2><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220327143310015.png"></p><p>这是我们的表中的数据 跟实体类的属性要一致（默认的映射规则）-&gt;为属性名赋值</p><p>在src&#x2F;main&#x2F;java 目录下创建com.lyc.mybatis.pojo包 在pojo包下创建User类 该类用于封装User对象的属性 如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> uid<span class="token punctuation">;</span>    <span class="token keyword">private</span> String uname<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> uage<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getUid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> uid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUid</span><span class="token punctuation">(</span><span class="token keyword">int</span> uid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>uid <span class="token operator">=</span> uid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getUname</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> uname<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUname</span><span class="token punctuation">(</span>String uname<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>uname <span class="token operator">=</span> uname<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getUage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> uage<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUage</span><span class="token punctuation">(</span><span class="token keyword">int</span> uage<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>uage <span class="token operator">=</span> uage<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-创建mapper接口"><a href="#6-创建mapper接口" class="headerlink" title="6.创建mapper接口"></a>6.创建mapper接口</h2><p>MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要</p><p>提供实现类。</p><p>在src&#x2F;main&#x2F;java&#x2F;com.lyc.mybatis下创建mapper文件夹</p><p>在文件夹下创建UserMapper接口</p><pre><code>int insertUser();</code></pre><h2 id="7-创建映射文件UserMapper-xml"><a href="#7-创建映射文件UserMapper-xml" class="headerlink" title="7.创建映射文件UserMapper.xml"></a>7.创建映射文件UserMapper.xml</h2><p>在src&#x2F;main&#x2F;resources下创建一个mappers文件夹 在文件下创建映射文件UserMapper.xml</p><p>用于配置真正的sql与java对象之间的映射  </p><p><strong>1.MyBatis映射文件用于编写SQL，访问以及操作表中的数据</strong></p><p><strong>2、MyBatis中可以面向接口操作数据，要保证两个一致：</strong> </p><p>a&gt;mapper接口的全类名和映射文件的命名空间（namespace）保持一致</p><p>b&gt;mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token comment" spellcheck="true">&lt;!--sql与java之间的映射 --></span><span class="token doctype">&lt;!DOCTYPE mapper        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.lyc.mybatis.mapper.UserMapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>insertUser<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        insert into users values (4,'王五',19)    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>映射文件的命名规则：</p><p>表所对应的实体类的类名+Mapper.xml</p><p>例如：表t_user，映射的实体类为Users，所对应的映射文件为UsersMapper.xml</p><h2 id="8-测试"><a href="#8-测试" class="headerlink" title="8.测试"></a>8.测试</h2><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220327152644515.png"></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> com<span class="token punctuation">.</span>lyc<span class="token punctuation">.</span>mybatis<span class="token punctuation">.</span>mapper<span class="token punctuation">.</span>UserMapper<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Resources<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>session<span class="token punctuation">.</span>SqlSession<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>session<span class="token punctuation">.</span>SqlSessionFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>session<span class="token punctuation">.</span>SqlSessionFactoryBuilder<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStream<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapperTest01</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">TestMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//读取MyBatis的核心配置文件 InputStream is = Resources.g</span>        InputStream resourceAsStream <span class="token operator">=</span>   Resources<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"mybatis-config.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">////通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象</span>        SqlSessionFactoryBuilder sqlSessionFactoryBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SqlSessionFactory sqlSessionFactory <span class="token operator">=</span> sqlSessionFactoryBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>resourceAsStream<span class="token punctuation">)</span><span class="token punctuation">;</span>        SqlSession session <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                UserMapper mapper <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>UserMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配 映射文件中的SQL标            签，并执行标签中的SQL语句</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">insertUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//事务提交</span>        session<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result"</span><span class="token operator">+</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> ORM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql中的聚合函数易混淆的概念</title>
      <link href="/2022/03/20/mysql%E4%B8%AD%E7%9A%84%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/03/20/mysql%E4%B8%AD%E7%9A%84%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h1><p>与其他查询不同，普通的查询做的都是横向查询，它们都是根据条件一行一行的进行判断，而使用聚合函数查询是纵向查询，</p><p>它是对一列的值进行计算，然后返回一个单一的值；另外聚合函数会忽略空值。</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/11.png"></p><h3 id="从案例引出问题："><a href="#从案例引出问题：" class="headerlink" title="从案例引出问题："></a>从案例引出问题：</h3><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220320154124681.png"></p><p>我们基于以上表作为查询：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> product<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 返回18 没有任何问题</span><span class="token keyword">select</span> pid<span class="token punctuation">,</span><span class="token function">min</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span> <span class="token keyword">from</span> product <span class="token punctuation">;</span><span class="token keyword">select</span> pid<span class="token punctuation">,</span><span class="token function">max</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span> <span class="token keyword">from</span> product <span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 此时不报错 pid显示结果都为1  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Q；为什么会产生这种现象？</p><p>因为聚合函数是对列进行操作和pid字段没有产生联系 ，系统pid默认的值全为1</p><p>此时我们可以考虑子查询＋AND 来解决类似hive里的窗口函数的功能</p><pre><code>select pid ,price from product where price = (select min(price) from product);</code></pre><p>聚合函数一般会和分组查询group by 结合使用</p><p>格式：</p><p>select 字段1,字段2… from 表名 group by 分组字段 having 分组条件;</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 1 统计各个分类商品的个数</span><span class="token keyword">select</span> category_id <span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> product <span class="token keyword">group</span> <span class="token keyword">by</span> category_id <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220320160246892.png"></p><p>执行结果如上：</p><p>执行顺序是先分组 再进行count聚合  </p><p>注意：如果要进行分组的话，则SELECT子句之后，只能出现分组的字段和统计函数，其他的字段不能出现</p><h3 id="having与where的区别"><a href="#having与where的区别" class="headerlink" title="having与where的区别"></a>having与where的区别</h3><ul><li><p>分组之后对统计结果进行筛选的话必须使用having，不能使用where</p></li><li><p>where子句用来筛选 FROM 子句中指定的操作所产生的   行 </p></li><li><p>group  by  子句用来分组 WHERE 子句的输出。 </p></li><li><p>having 子句用来从分组的结果中筛选行</p></li></ul><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> category_id <span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> product <span class="token keyword">where</span> price<span class="token operator">></span><span class="token number">300</span> <span class="token keyword">group</span> <span class="token keyword">by</span> category_id <span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">select</span> category_id <span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> product <span class="token keyword">group</span> <span class="token keyword">by</span> category_id <span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 思考以上语句哪条会有问题？</span><span class="token comment" spellcheck="true">-- 答案是都没问题 where首先把不满足的行去掉后进行分组，筛选出特定的组 </span><span class="token comment" spellcheck="true">-- 另一个也是将条件不满足的筛选掉 只不过是分组后进行 顺序问题</span><span class="token comment" spellcheck="true">-- 执行顺序where>group by>count(*) > having </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="一些注意的点"><a href="#一些注意的点" class="headerlink" title="一些注意的点"></a>一些注意的点</h3><p>mysql 5.6环境下除了count(*)为特例（不忽略null值）外，其余聚集函数确实是忽略null值</p><p>聚合函数默认忽略字段为null的记录 要想列值为null的记录也参与计算，必须使用ifnull函数对null值做替换  这里不做过多演示</p><p>使用Group By子句返回的组没有特定的顺序，可以使用Order By子句指定次序。</p><p>group by和order by连用的确会出现问题</p><h4 id="Group-by中子查询order-by排序失效问题分析"><a href="#Group-by中子查询order-by排序失效问题分析" class="headerlink" title="Group by中子查询order by排序失效问题分析"></a>Group by中子查询order by排序失效问题分析</h4><p>依然要考虑执行顺序</p><p><strong>获取sql分组中id最大的记录</strong></p><p>select id,name from (select id,name from tt order by id desc) as t group by name</p><p>从from开始执行顺序   group by的执行顺序&gt; select  每个组默认取了第一条数据。</p><pre><code>// 表数据如下：id,name1,name12,name13,name24,name2select id,name from (select id,name from tt order by id desc) as t group by name// 输出结果如下：id,name1,name13,name2</code></pre><p>这是为什么呢？因为mysql 5.6之后版本对排序的sql解析做了优化，子查询中的排序是会被忽略的，所以上面的order by id desc未起到作用。如果子语句中排序不做优化那不就可以了么，查阅资料发现可以在子语句中加上limit来避免这种优化（加上limit相当于临时表限定了取值范围不会进行优化，如果是全表的话就被优化掉了）。</p><p>正确写法：</p><pre><code>// 加上limitselect id,name from (select id,name from tt order by id desc limit 1024) as t group by name // 输出结果如下：id,name2,name14,name2</code></pre>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 聚合函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList底层结构和源码分析</title>
      <link href="/2022/03/19/ArrayList%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2022/03/19/ArrayList%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h1><p>1）允许添加任意的元素 包括null 多个</p><p>2） ArrayList是由数组来实现数据存储的</p><p>3）Array在多线程中是不安全的 建议使用vector</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>数组是数据结构基本的数据结构 java封装了一系列数组的方法</p><p>数组中存储的内存是连续的 插入和删除困难 查询方便</p><ul><li>ArrayList中维护了一个Object类型的数组elementData</li><li>无参构造器：自动扩容机制 ele-&gt;0（default）-&gt;10（First add）-&gt;15(second add)-&gt;15x1.5-&gt;15x1.5x1.5</li><li>有参构造器：指定大小（size）-&gt;size*1.5(First add) -&gt; sizex1.5X1.5(second add)</li></ul><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><ul><li>Tip：英语对于看源码和理解有一定的帮助</li></ul><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h4><pre class="line-numbers language-java"><code class="language-java">     <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建指定长度的object数组</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//空数组</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>            <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将集合转换成数组</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> ArrayList<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//如果不是object数组类型</span>                elementData <span class="token operator">=</span> a<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> size<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//拷贝一下</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// replace with empty array.</span>            elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * This helper method split out from add(E) to keep method * bytecode size under 35 (the -XX:MaxInlineSize default value), * which helps when add(E) is called in a C1-compiled loop. */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        elementData <span class="token operator">=</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    size <span class="token operator">=</span> s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return {@code true} (as specified by {@link Collection#add}) */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//改进后的直接自增</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException {@inheritDoc} */</span><span class="token comment" spellcheck="true">//指定位置添加</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> s<span class="token punctuation">;</span>    Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> size<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span>elementData <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>elementData<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>        elementData <span class="token operator">=</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将index之后的所有元素移动一位</span>    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                     elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                     s <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>    size <span class="token operator">=</span> s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//扩容的入口方法 DEFAULTCAPACITY_EMPTY_ELEMENTDATA  默认为10</span><span class="token comment" spellcheck="true">//判断是你的值大还是它的值大 就返回你的值</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> elementData<span class="token punctuation">.</span>length            <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA                 <span class="token operator">&amp;&amp;</span> minCapacity <span class="token operator">&lt;=</span> DEFAULT_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            modCount<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//数组扩容方法</span>   <span class="token keyword">private</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> elementData <span class="token operator">!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> ArraysSupport<span class="token punctuation">.</span><span class="token function">newLength</span><span class="token punctuation">(</span>oldCapacity<span class="token punctuation">,</span>                    minCapacity <span class="token operator">-</span> oldCapacity<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* minimum growth */</span>                    oldCapacity <span class="token operator">>></span> <span class="token number">1</span>           <span class="token comment" spellcheck="true">/* preferred growth */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">grow</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//第一次其实是  0*any=0    </span><span class="token comment" spellcheck="true">//用0.5倍来扩容</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>modCount++;用来记录修改的记录</p><pre><code>return elementData = Arrays.copyOf(elementData, newCapacity);</code></pre><p>进行扩容</p><p>使用扩容机制来确定扩容到多大</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper的基本介绍</title>
      <link href="/2022/03/19/zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/03/19/zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Zookeeper："><a href="#Zookeeper：" class="headerlink" title="Zookeeper："></a>Zookeeper：</h1><p>官方文档上这么解释zookeeper，它是一个分布式服务框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：<strong>统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理</strong>。  </p><p>上面的解释有点抽象，简单来说zookeeper&#x3D;文件系统+监听通知机制。  </p><p>每个子目录项如 NameService 都被称作为 znode(目录节点)，和文件系统一样，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode，唯一的不同在于znode是可以存储<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE&spm=1001.2101.3001.7020">数据</a>的。</p><h4 id="四种类型的znode："><a href="#四种类型的znode：" class="headerlink" title="四种类型的znode："></a>四种类型的znode：</h4><ul><li><h5 id="PERSISTENT-持久化目录节点"><a href="#PERSISTENT-持久化目录节点" class="headerlink" title="PERSISTENT-持久化目录节点"></a>PERSISTENT-持久化目录节点</h5></li></ul><p>客户端与zookeeper断开连接后，该节点依旧存在</p><ul><li><h5 id="PERSISTENT-SEQUENTIAL-持久化顺序编号目录节点"><a href="#PERSISTENT-SEQUENTIAL-持久化顺序编号目录节点" class="headerlink" title="PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点"></a>PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点</h5></li></ul><p>客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号</p><ul><li><h5 id="EPHEMERAL-临时目录节点"><a href="#EPHEMERAL-临时目录节点" class="headerlink" title="EPHEMERAL-临时目录节点"></a>EPHEMERAL-临时目录节点</h5></li></ul><p>客户端与zookeeper断开连接后，该节点被删除</p><ul><li><h5 id="EPHEMERAL-SEQUENTIAL-临时顺序编号目录节点"><a href="#EPHEMERAL-SEQUENTIAL-临时顺序编号目录节点" class="headerlink" title="EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点"></a>EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点</h5></li></ul><p>客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</p><h4 id="监听通知机制"><a href="#监听通知机制" class="headerlink" title="监听通知机制"></a>监听通知机制</h4><p>客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。</p><p>就这么简单，下面我们看看Zookeeper能做点什么呢？</p><p>zookeeper功能非常强大，可以实现诸如<a href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F&spm=1001.2101.3001.7020">分布式</a>应用配置管理、统一命名服务、状态同步服务、集群管理等功能，我们这里拿比较简单的分布式应用配置管理为例来说明。</p><p>假设我们的程序是分布式部署在多台机器上，如果我们要改变程序的配置文件，需要逐台机器去修改，非常麻烦，现在把这些配置全部放到zookeeper上去，保存在 zookeeper 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到 zookeeper 的通知，然后从 zookeeper 获取新的配置信息应用到系统中。</p><h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><p>先给自己选票+1；后面再根据myid开始选票；</p><ul><li><p>崩溃恢复：主要就是Leader选举过程。</p></li><li><p>数据同步：Leader服务器与其他服务器进行数据同步。</p></li><li><p>消息广播：Leader服务器将数据发送给其他服务器。</p></li></ul><p>Q:集群中为什么要有主节点</p><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，</p><p>其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点</p><h2 id="leader-选举过程"><a href="#leader-选举过程" class="headerlink" title="leader 选举过程"></a>leader 选举过程</h2><p>有两种情况会发起Leader选举：</p><ol><li><p>服务器启动的时候</p></li><li><p>服务器运行的时候当Leader宕机</p></li></ol><h4 id="第一次选举规则："><a href="#第一次选举规则：" class="headerlink" title="第一次选举规则："></a><strong>第一次选举规则：</strong></h4><p>投票过半数时，id大的胜出</p><h4 id="第二次选举规则："><a href="#第二次选举规则：" class="headerlink" title="第二次选举规则："></a><strong>第二次选举规则：</strong></h4><p>Epoch 大的直接胜出</p><p>若相同 ID 大的直接胜出</p><p>事物id相同 服务器id大的胜出</p><h3 id="Q-生产集群安装多少台zookeeper合适："><a href="#Q-生产集群安装多少台zookeeper合适：" class="headerlink" title="Q:生产集群安装多少台zookeeper合适："></a>Q:生产集群安装多少台zookeeper合适：</h3><p>10台服务器：3台zk;</p><p>20台：5台zk</p><p>100台：11台zk</p><p>服务器台数多的时候，可靠性比较高 坏处：提高通信延时</p><p>paxos算法：一种消息传递且具有高度容错特性的一致性算法</p><h3 id="Q-Zookeeper-怎么保证主从节点的状态同步？"><a href="#Q-Zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="Q:Zookeeper 怎么保证主从节点的状态同步？"></a>Q:Zookeeper 怎么保证主从节点的状态同步？</h3><p>Zookeeper 的核心是原子广播机制，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。</p><p>paxos算法解决的问题：就是如何快速在一个分布式系统中对某一个数据进行达成一致，且保证不论发生任何异常</p><p>都不会破坏系统的一致性</p><p>例如：机器宕机</p>]]></content>
      
      
      <categories>
          
          <category> 大数据生态圈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于super关键字和this的区别</title>
      <link href="/2022/03/17/%E5%85%B3%E4%BA%8Esuper%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8Cthis%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/03/17/%E5%85%B3%E4%BA%8Esuper%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8Cthis%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="一、super-与-this-用法"><a href="#一、super-与-this-用法" class="headerlink" title="一、super 与 this 用法"></a>一、super 与 this 用法</h2><h4 id="关于super"><a href="#关于super" class="headerlink" title="关于super"></a>关于super</h4><ol><li><p>主要存在于子类方法中，用于指向子类对象中父类对象。</p></li><li><p>调用父类的属性和方法</p></li><li><p>访问父类的构造函数</p></li></ol><ul><li><p>关于super你首先需要明白的是，如果父类和子类都有一个同名方法</p><p> 在没有重写的情况下，优先调用的是父类的方法</p></li><li><p>只有重写后才会优先调用子类的 这时候就可以使用super关键字来调用</p></li><li><p>super（形参列表）的使用，必须声明在<a href="https://so.csdn.net/so/search?q=%E5%AD%90%E7%B1%BB&spm=1001.2101.3001.7020">子类</a>构造器的首行。</p></li></ul><p><strong>例子</strong></p><p>我们可以注意到父类和子类都有相同的成员变量age，（super.age）就是访问的是Person类中的age </p><p>如果不加super 就近原则就是Student类的age</p><pre><code>class Person &#123;    int age = 12;&#125;class Student extends Person &#123;    int age = 18;    void display() &#123;        System.out.println(&quot;学生年龄：&quot; + super.age);    &#125;&#125;class Test &#123;    public static void main(String[] args) &#123;        Student stu = new Student();        stu.display();    &#125;&#125;</code></pre><h4 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h4><p>​    1 this相当于是指向当前对象本身</p><p>​    2 形参与成员变量重名，用this来区分</p><p>​    3 this关键字也可以在构造函数中调用其他构造函数 但是必须定义在构造函数的第一行 这一点与super的用法非常相似  this（）调用其他构造函数时，必须放在定义的构造函数第一行。如果随意放在普通方法的第一行，则立马报错</p><p><strong>例子</strong></p><pre><code>class Person&#123;    private String name;    private int age;    Person(String name)    &#123;        //成员变量和局部变量重名，可以用关键字this区分        this.name = name;    &#125;    public void speak()    &#123;        //输出时，会默认为成员增加this关键字，用来代表具体对象的数据        System.out.println(this.name+&quot;：&quot;+this.age);    &#125;&#125;</code></pre><pre><code>class Person&#123;    private String name;    private int age;    Person()    &#123;        name = &quot;baby&quot;;        age = 1;        System.out.println(&quot;Person run&quot;);    &#125;    Person(String name)    &#123;        //成员变量和局部变量重名，可以用关键字this区分        this.name = name;    &#125;    Person(String name,int age)    &#123;        //调用其他构造函数时，只能定义在构造函数的第一行，因为初始化动作要先执行        this();        this.name = name;        this.age = age;    &#125;    public void speak()    &#123;        System.out.println(this.name+&quot;：&quot;+this.age);    &#125; &#125;  class ThisDemo &#123;    public static void main(String[] args)     &#123;        Person p = new Person(&quot;小强&quot;,10);        p.speak();    &#125;&#125;//输出结果Person run 小强：10</code></pre><p> <strong>虽然我们在 Person(String name,int age) 构造函数中调用了 Person() 构造函数，但是最后的输出结果，仅输出了 Person run ，成员变量的内容还是我们在新建对象时，传递进去的参数，并不是 Person() 中初始化的内容。成员变量传进去的参数所被覆盖了</strong></p><h4 id="二、关于一些细节"><a href="#二、关于一些细节" class="headerlink" title="二、关于一些细节"></a>二、关于一些细节</h4><p>为了看的更直观 我们直接用代码进行说明</p><pre><code>public class Animal &#123;    public Animal() &#123;        System.out.println(&quot;Animal类的无参数构造函数执行&quot;);    &#125;&#125;class Cat extends Animal &#123;    public Cat() &#123;        System.out.println(&quot;Cat类的无参数构造函数执行&quot;);        &#125;    &#125;    class Test &#123;        public static void main(String[] args) &#123;            Cat c1 = new Cat();        &#125;    &#125;// 在实例化对象的时候 直接就把构造器的方法全执行了//上面的隐藏了一个super(); 你写不写都行 但为了看的方便我们还是需要在子类的构造器中写一下的</code></pre><p>那么又引出一个问题 父类有多个构造器我们怎么知道super调用的是哪个?</p><p>1.父类是无参构造器 super（）；</p><p>2.父类是有参构造器super(name,age); 调用相同形参的</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于HashList的深入探究</title>
      <link href="/2022/03/15/%E5%85%B3%E4%BA%8EHashList%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6/"/>
      <url>/2022/03/15/%E5%85%B3%E4%BA%8EHashList%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220315223146221.png"></p><h2 id="HashSet本质是HashMap"><a href="#HashSet本质是HashMap" class="headerlink" title="HashSet本质是HashMap"></a>HashSet本质是HashMap</h2><p>HashSet是一个不允许有重复元素的集合。</p><p>它实现了set接口 可以存放null值，但是只能有一个null</p><p>和ArrayList不同的是：HashSet 是无序的，即不会记录插入的顺序。</p><p>HashSet是非同步的。如果多个线程同时访问一个<a href="https://so.csdn.net/so/search?q=%E5%93%88%E5%B8%8C&spm=1001.2101.3001.7020">哈希</a> set，<br>而其中至少一个线程修改了该 set，那么它必须 保持外部同步。这通常是通过对自然封装该 set 的对象执行同步操作来完成的。<br>如果不存在这样的对象，则应该使用 Collections.synchronizedSet 方法来“包装” set。最好在创建时完成这一操作，<br>以防止对该 set 进行意外的不同步访问：</p><pre><code>HashSet set = new HashSet();//1.add方法返回的是一个boolean值 添加成功则为true 失败为false//2.remove的方法指定删除对象</code></pre><h2 id="HASHMAP"><a href="#HASHMAP" class="headerlink" title="HASHMAP"></a>HASHMAP</h2><p>HashMap底层是数组+链表+红黑树</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/20160605101246837.png"></p><h3 id="数组元素Node-lt-K-V-gt-实现了Entry接口"><a href="#数组元素Node-lt-K-V-gt-实现了Entry接口" class="headerlink" title="数组元素Node&lt;K,V&gt;实现了Entry接口"></a>数组元素Node&lt;K,V&gt;实现了Entry接口</h3><pre><code>//Node是单向链表，它实现了Map.Entry接口static class Node&lt;k,v&gt; implements Map.Entry&lt;k,v&gt; &#123;    final int hash;    final K key;    V value;    Node&lt;k,v&gt; next;    //构造函数Hash值 键 值 下一个节点    Node(int hash, K key, V value, Node&lt;k,v&gt; next) &#123;        this.hash = hash;        this.key = key;        this.value = value;        this.next = next;    &#125;     public final K getKey()        &#123; return key; &#125;    public final V getValue()      &#123; return value; &#125;    public final String toString() &#123; return key + = + value; &#125;     public final int hashCode() &#123;        return Objects.hashCode(key) ^ Objects.hashCode(value);    &#125;     public final V setValue(V newValue) &#123;        V oldValue = value;        value = newValue;        return oldValue;    &#125;    //判断两个node是否相等,若key和value都相等，返回true。可以与自身比较为true    public final boolean equals(Object o) &#123;        if (o == this)            return true;        if (o instanceof Map.Entry) &#123;            Map.Entry&lt;!--?,?--&gt; e = (Map.Entry&lt;!--?,?--&gt;)o;            if (Objects.equals(key, e.getKey()) &amp;&amp;                Objects.equals(value, e.getValue()))                return true;        &#125;        return false;    &#125;</code></pre><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><pre><code>//红黑树static final class TreeNode&lt;k,v&gt; extends LinkedHashMap.Entry&lt;k,v&gt; &#123;    TreeNode&lt;k,v&gt; parent;  // 父节点    TreeNode&lt;k,v&gt; left; //左子树    TreeNode&lt;k,v&gt; right;//右子树    TreeNode&lt;k,v&gt; prev;    // needed to unlink next upon deletion    boolean red;    //颜色属性    TreeNode(int hash, K key, V val, Node&lt;k,v&gt; next) &#123;        super(hash, key, val, next);    &#125;     //返回当前节点的根节点    final TreeNode&lt;k,v&gt; root() &#123;        for (TreeNode&lt;k,v&gt; r = this, p;;) &#123;            if ((p = r.parent) == null)                return r;            r = p;        &#125;    &#125;</code></pre><p>HashMap有四个构造函数可供我们使用</p><pre><code>//默认无参构造，指定一个默认的加载因子public HashMap() &#123;    this.loadFactor = DEFAULT_LOAD_FACTOR; &#125;//可指定容量的有参构造，但是需要注意当前我们指定的容量并不一定就是实际的容量，下面会说public HashMap(int initialCapacity) &#123;    //同样使用默认加载因子    this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;//可指定容量和加载因子，但是笔者不建议自己手动指定非0.75的加载因子public HashMap(int initialCapacity, float loadFactor) &#123;    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                           initialCapacity);    if (initialCapacity &gt; MAXIMUM_CAPACITY)        initialCapacity = MAXIMUM_CAPACITY;    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                                           loadFactor);    this.loadFactor = loadFactor;    //这里就是把我们指定的容量改为一个大于它的的最小的2次幂值，如传过来的容量是14，则返回16    this.threshold = tableSizeFor(initialCapacity);&#125;//可传入一个已有的mappublic HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;    this.loadFactor = DEFAULT_LOAD_FACTOR;    putMapEntries(m, false);&#125;//把传入的map里边的元素都加载到当前mapfinal void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;    int s = m.size();    if (s &gt; 0) &#123;        if (table == null) &#123; // pre-size            float ft = ((float)s / loadFactor) + 1.0F;            int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?                     (int)ft : MAXIMUM_CAPACITY);            if (t &gt; threshold)                threshold = tableSizeFor(t);        &#125;        else if (s &gt; threshold)            resize();        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;            K key = e.getKey();            V value = e.getValue();    putVal(hash(key), key, value, false, evict);        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hive的配置</title>
      <link href="/2022/03/10/hive%E4%B8%93%E9%A2%98/"/>
      <url>/2022/03/10/hive%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="认识hive的基本配置"><a href="#认识hive的基本配置" class="headerlink" title="认识hive的基本配置"></a>认识hive的基本配置</h1><h5 id="Metastore"><a href="#Metastore" class="headerlink" title="Metastore"></a>Metastore</h5><ol><li><p>Metastores是元数据服务，元数据的服务组件，这个组件存储着hive的元数据。<br>作用：管理metadata元数据，让客户端通过连接Metastore服务，再由metastore去<br>连接MySQL数据库存取元数据。可以间接保证数据的安全。</p></li><li><p>有了metastore服务，就可以有多个客户端同时连接，而且这些客户端不需要知道<br>MySQL数据库的用户名和密码，只需要连接metastore 服务即可。</p></li></ol><h5 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h5><p>关于数据的数据或者叫做用来描述数据的数据或者叫做信息的信息。可以理解为最小的数据单元。<br>元数据可以为数据说明其元素或属性（名称、大小、数据类型、等），或其结构（长度、字段、数据列）</p><h3 id="Metastore启动方式"><a href="#Metastore启动方式" class="headerlink" title="Metastore启动方式"></a>Metastore启动方式</h3><p>Metastore的启动方式有三种：</p><p><strong>（1）嵌入模式</strong></p><p>内嵌模式使用的是内嵌的Derby数据库来存储元数据，也不需要额外起Metastore服务。<br>数据库和Metastore服务都嵌入在主Hive Server进程中。这个是默认的，配置简单，<br>但是一次只能一个客户端连接，适用于用来实验，不适用于生产环境。</p><p>解压hive安装包 bin&#x2F;hive 启动即可使用</p><p>缺点：不同路径启动hive，每一个hive拥有一套自己的元数据，无法共享。</p><p><strong>（2）本地模式</strong></p><p>本地模式采用外部数据库来存储元数据，目前支持的数据库有：<br>MySQL、Postgres、Oracle、MS SQL Server.在这里我们使用MySQL。</p><p>本地模式不需要单独起metastore服务，用的是跟hive在同一个进程里的metastore服务。<br>也就是说当你启动一个hive 服务，里面默认会帮我们启动一个metastore线程服务。<br>hive根据hive.metastore.uris，如果为空，则为本地模式。</p><p>缺点是：每启动一次hive服务，都内置启动了一个metastore。</p><p><strong>（3）远程模式</strong></p><p>远程模式下，需要单独起metastore服务（hive –service metastore），然后每个客户端</p><p>都在配置文件里配置连接到该metastore服务。</p><p>远程模式的metastore服务和hive运行在不同的进程里。</p><p>在生产环境中，建议用远程模式来配置Hive Metastore。</p><p>在这种情况下，其他依赖hive的软件都可以通过** Metastore访问hive。**</p><p>远程模式下，需要配置hive.metastore.uris 参数来指定metastore服务运行的机器ip和端口，<br>并且需要单独手动启动metastore服务，如有多个metastore服务器，URI之间用逗号分隔。</p><h2 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h2><p>本次安装的hive版本为3.0x 基于Hadoop3.0x进行远程模式的搭建</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p><strong>基本的hadoop集群环境要确保能够正常启动</strong></p><h4 id="1-防火墙管理"><a href="#1-防火墙管理" class="headerlink" title="1.防火墙管理"></a>1.防火墙管理</h4><p><strong>(1)防火墙状态查询</strong>：systemctl status firewalld.service<br><strong>(2)防火墙关闭</strong>：systemctl stop firewalld.service<br><strong>(3)禁止防火墙开机启动</strong>：systemctl disable firewalld.service</p><h4 id="2-mysql安装配置成功"><a href="#2-mysql安装配置成功" class="headerlink" title="2.mysql安装配置成功"></a>2.mysql安装配置成功</h4><p>Mysql安装配置成功并能使用 mysql -uroot -p 进行登入</p><h4 id="3-JAVA-JDK配置"><a href="#3-JAVA-JDK配置" class="headerlink" title="3.JAVA JDK配置"></a>3.JAVA JDK配置</h4><p>JDK安装配置成功，并能查看java 版本信息</p><h4 id="4-Hadoop与hive整合"><a href="#4-Hadoop与hive整合" class="headerlink" title="4.Hadoop与hive整合"></a>4.Hadoop与hive整合</h4><p>因为Hive需要把数据存储在HDFS上，并且通过MapReduce作为执行引擎处理数据；<br>修改Hadoop中core-site.xml，并且Hadoop集群同步配置文件，重启生效。</p><pre><code>&lt;!-- 整合hive --&gt;  &lt;property&gt;    &lt;name&gt;hadoop.proxyuser.root.hosts&lt;/name&gt;    &lt;value&gt;*&lt;/value&gt;  &lt;/property&gt;  &lt;property&gt;    &lt;name&gt;hadoop.proxyuser.root.groups&lt;/name&gt;    &lt;value&gt;*&lt;/value&gt;  &lt;/property&gt;</code></pre><h4 id="5-hive的jar包准备"><a href="#5-hive的jar包准备" class="headerlink" title="5.hive的jar包准备"></a>5.hive的jar包准备</h4><p>地址：<a href="http://archive.apache.org/dist/hive/hive-3.1.0/">http://archive.apache.org/dist/hive/hive-3.1.0/</a><br>选择apache-hive-3.1.0-bin.tar.gz 进行下载</p><h2 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h2><h5 id="上传解压安装包"><a href="#上传解压安装包" class="headerlink" title="上传解压安装包"></a>上传解压安装包</h5><ol><li>解压hive安装包<pre><code>tar -zxvf apache-hive-3.1.0-bin.tar.gz  -C mv apache-hive-3.1.0-bin hive</code></pre></li><li>解决hadoop、hive之间guava版本差异</li></ol><p>进入hive目录 将guava-27.0-jre.jar 拷贝至lib目录下</p><pre><code>rm -rf lib/guava-19.0.jarcp /export/server/hadoop-3.1.3/share/hadoop/common/lib/guava-27.0-jre.jar ./lib/</code></pre><ol start="3"><li>添加mysql jdbc驱动到hive安装包lib&#x2F;文件下<br>下载地址：<a href="https://maven.ityuan.com/maven2/mysql/mysql-connector-java/5.1.32">https://maven.ityuan.com/maven2/mysql/mysql-connector-java/5.1.32</a></li></ol><h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><p>可参照自己的文件存放的位置进行修改<br>cd &#x2F;export&#x2F;server&#x2F;hive&#x2F;conf&#x2F;<br>mv hive-env.sh.template hive-env.sh<br>vim hive-env.sh<br>export HADOOP_HOME&#x3D;&#x2F;export&#x2F;server&#x2F;hadoop-3.1.0<br>export HIVE_CONF_DIR&#x3D;&#x2F;export&#x2F;server&#x2F;hive&#x2F;conf<br>export HIVE_AUX_JARS_PATH&#x3D;&#x2F;export&#x2F;server&#x2F;hive&#x2F;lib</p><p>修改conf路径下的hive-site.xml</p><p>vim hive-site.xml (配置路径与mysql)</p><pre><code>&lt;configuration&gt;    &lt;!-- 存储元数据mysql相关配置 --&gt;    &lt;property&gt;        &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;        &lt;value&gt; jdbc:mysql://hadoop102:3306/hive?createDatabaseIfNotExist=true&amp;amp;useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;        &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;        &lt;value&gt;root&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;        &lt;value&gt;hadoop&lt;/value&gt;    &lt;/property&gt;    &lt;!-- H2S运行绑定host --&gt;    &lt;property&gt;        &lt;name&gt;hive.server2.thrift.bind.host&lt;/name&gt;        &lt;value&gt;hadoop102&lt;/value&gt;    &lt;/property&gt;    &lt;!-- 远程模式部署metastore 服务地址 --&gt;    &lt;property&gt;        &lt;name&gt;hive.metastore.uris&lt;/name&gt;        &lt;value&gt;thrift://hadoop102:9083&lt;/value&gt;    &lt;/property&gt;    &lt;!-- 关闭元数据存储授权  --&gt;    &lt;property&gt;        &lt;name&gt;hive.metastore.event.db.notification.api.auth&lt;/name&gt;        &lt;value&gt;false&lt;/value&gt;    &lt;/property&gt;    &lt;!-- 关闭元数据存储版本的验证 --&gt;    &lt;property&gt;        &lt;name&gt;hive.metastore.schema.verification&lt;/name&gt;        &lt;value&gt;false&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><h3 id="初始化metadata"><a href="#初始化metadata" class="headerlink" title="初始化metadata"></a>初始化metadata</h3><p>cd &#x2F;export&#x2F;server&#x2F;hive<br>bin&#x2F;schematool -initSchema -dbType mysql -verbos<br>初始化成功会在mysql中创建74张表</p><h2 id="hiveserver2"><a href="#hiveserver2" class="headerlink" title="hiveserver2"></a>hiveserver2</h2><p>Hive发展至今，总共历经了两代客户端工具。</p><ol><li><p>第一代客户端（deprecated不推荐使用）：$HIVE_HOME&#x2F;bin&#x2F;hive, 是一个 shellUtil。<br>主要功能：一是可用于以交互或批处理模式运行Hive查询；二是用于Hive相关服务的启动，比如metastore服务。</p></li><li><p>第二代客户端（recommended 推荐使用）：$HIVE_HOME&#x2F;bin&#x2F;beeline，是一个JDBC客户端，<br>是官方强烈推荐使用的Hive命令行工具，和第一代客户端相比，性能加强安全性提高。</p></li></ol><p>Q:为什么我们要使用hiveserver2？</p><p>HiveServer2支持多客户端的并发和身份认证，旨在为开放API客户端如JDBC、ODBC提供更好的支持。</p><p>HiveServer2通过Metastore服务读写元数据。所以在远程模式下，启动HiveServer2之前<strong>必须先首先启动metastore服务</strong></p><h3 id="配置bin-x2F-hive-客户端"><a href="#配置bin-x2F-hive-客户端" class="headerlink" title="配置bin&#x2F;hive 客户端"></a>配置bin&#x2F;hive 客户端</h3><p>上传hive安装包到另一个机器上，比如node3<br>cd &#x2F;export&#x2F;server&#x2F;tar zxvf apache-hive-3.1.0-bin.tar.gzmv apache-hive-3.1.0-bin hive#</p><pre><code># 解决hadoop、hive之间guava版本差异cd /export/server/hive/rm -rf lib/guava-19.0.jarcp /export/server/hadoop-3.1.3/share/hadoop/common/lib/guava-27.0-jre.jar ./lib/# 修改hive环境变量文件 添加Hadoop_HOMEcd /export/server/hive/confmv hive-env.sh.template hive-env.shvim hive-env.shexport HADOOP_HOME=/export/server/hadoop-3.1.4# 添加metastore服务地址cd /export/server/hive/conf/vim  hive-site.xml&lt;configuration&gt;&lt;property&gt;    &lt;name&gt;hive.metastore.uris&lt;/name&gt;    &lt;value&gt;thrift://hadoop102:9083&lt;/value&gt; &lt;/property&gt;  &lt;/configuration&gt;</code></pre><p>hive经过发展，推出了第二代客户端beeline，但是beeline客户端不是直接访问metastore服务的，而是需要单独启动hiveserver2服务。<br>在hive安装的服务器上，首先启动metastore服务，然后启动hiveserver2服务。</p><h2 id="hive的使用"><a href="#hive的使用" class="headerlink" title="hive的使用"></a>hive的使用</h2><p>后台挂起 可使用jps命令查看是否开启 正常的话就是runjar<br>注意hivesever2开启后要等一段时间才可以使用 </p><pre><code>nohup /export/servers/hive/bin/hive --service metastore &amp;nohup /export/servers/hive/bin/hive --service hiveserver2 &amp;</code></pre><p>cd 到hive的bin目录下</p><pre><code>! connect jdbc:hive2://hadoop:10000Enter username for jdbc:hive2://hadoop102:10000: rootEnter password for jdbc:hive2://node1:10000: Connected to: Apache Hive (version 3.1.0)</code></pre><p>创建一个数据库<br>如果可以创建则表明成功，后续自行使用idea连接hive即可</p><h3 id="一些BUG解决方案"><a href="#一些BUG解决方案" class="headerlink" title="一些BUG解决方案"></a>一些BUG解决方案</h3><ol><li><p>User: root is not allowed to impersonate root(state&#x3D;08S01,code&#x3D;0)</p><p>服务端hadoop01 操作</p></li></ol><pre><code>&lt;property&gt;    &lt;name&gt;hadoop.proxyuser.root.hosts&lt;/name&gt;    &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;hadoop.proxyuser.root.groups&lt;/name&gt;    &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;</code></pre><p>在hive的conf下修改配置文件hive-site.xml</p><pre><code>&lt;property&gt;&lt;name&gt;hive.server2.enable.doAs&lt;/name&gt;&lt;value&gt;false&lt;/value&gt;&lt;/property&gt;端口号&lt;property&gt;&lt;name&gt;hive.server2.thrift.port&lt;/name&gt;&lt;value&gt;10000&lt;/value&gt;&lt;/property&gt;</code></pre><p>修改hadoop下core-site.xml文件（已修改的可以不加）</p><pre><code> &lt;property&gt;        &lt;name&gt;hadoop.proxyuser.root.hosts&lt;/name&gt;        &lt;value&gt;*&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;hadoop.proxyuser.root.groups&lt;/name&gt;        &lt;value&gt;*&lt;/value&gt;    &lt;/property&gt;</code></pre><p>hdfs dfs -chmod -R 777 &#x2F;tmp</p><ol start="2"><li>Permission denied: user&#x3D;root, access&#x3D;WRITE, inode&#x3D;”&#x2F;user”:hdfs:supergroup:drwxr-xr-x</li></ol><p>众所周知，HDFS文件系统的目录基本都属于supergroup用户组，<br>所以我们就把就把用户添加到该用户组，即可解决很多权限问题，<br>例如连接Hive却无法操作的创建库、表的问题…</p><p><strong>解决hive中root权限不能写的问题</strong></p><p>1、在Linux执行如下命令增加supergroup<br>sudo groupadd supergroup</p><p>2、将用户增加到supergroup中<br>sudo usermod -a -G supergroup root</p><p>3、同步系统的权限信息到HDFS文件系统<br>hdfs dfsadmin -refreshUserToGroupsMappings</p><p>4、查看属于supergroup用户组的用户<br>grep ‘supergroup:’ &#x2F;etc&#x2F;group</p><p>重新连接 服务端runjar2 客户端runjar1发现问题解决！</p>]]></content>
      
      
      <categories>
          
          <category> 大数据生态圈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HIVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的基本运用</title>
      <link href="/2022/03/10/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%94%A8/"/>
      <url>/2022/03/10/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="认识单链表"><a href="#认识单链表" class="headerlink" title="认识单链表"></a>认识单链表</h1><p>单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。<br>链表中的数据是以节点来表示的，每个节点的构成：data域（数据元素）+next域（下一个结点的存储位置）。<br>单链表与数组相比的最大差别是：单链表的数据元素存放在内存空间的地址是不连续的，<br>而数组的数据元素存放的地址在内存空间中是连续的，<br>这也是为什么根据索引无法像数组那样直接就能查询到数据元素。</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/109.png" alt="109"></p><h2 id="基本操作如下"><a href="#基本操作如下" class="headerlink" title="基本操作如下"></a>基本操作如下</h2><pre><code>public class LinkList &#123;    private static final LinkNode NULL = null;private LinkNode Head = new LinkNode();//先初始化一个头结点，头结点为空    LinkList() &#123;        Init_LinkNode();&#125;//内部类节点LinkNode    class LinkNode &#123;        int data;        LinkNode next=null;        LinkNode()&#123;        &#125;        LinkNode(int elem)&#123;            data=elem;        &#125;        LinkNode(int elem,LinkNode nextval)&#123;            data=elem;            next=nextval;        &#125;        LinkNode(LinkNode nextval)&#123;            next=nextval;        &#125;    &#125;        //1.单链表的初始化    public void Init_LinkNode() &#123;        LinkNode head = null;    &#125;//2.    判断表是否为空 public boolean isEmpty() &#123;//通过判断头结点的下一结点地址是否为空，即可判断单链表是否为空        if(this.Head.next == null) &#123;           return true;         &#125;        return false;    &#125;    //3.返回单链表的长度    public int Length_LinkList() &#123;        int j=0;        LinkNode tmp=Head; //head节点不能动，需要一个tmp辅助遍历        while(tmp != null) &#123;            j++;            tmp=tmp.next;        &#125;        return j;    &#125;        //4.返回第i个元素        public LinkNode Get_LinkList(int i) &#123;            LinkNode p = Head;            int a = 0;            while (p.next != null &amp;&amp; a &lt; i) &#123;                p = p.next;                a++;            &#125;            if (a == i) &#123;                return p;            &#125; else &#123;                return null;            &#125;        &#125;       //5.删除第i个元素        public int Delete_LinkList(int i) &#123;                LinkNode p;                LinkNode s;            p=Get_LinkList(i-1);            if(p==null)&#123;                System.out.println(&quot;第i-1个结点不存在&quot;);                return -1;            &#125;else if (p.next==null)&#123;                System.out.println(&quot;第i个结点不存在&quot;);                return 0;            &#125;else&#123;                s=p.next;                p.next=s.next;                return 1;            &#125;        &#125; //6.在第i个位置插入元素        public int  Insert_LinkList(int i,int x) &#123;        LinkNode p,s;        p=Get_LinkList(i-1);            if(p==null)&#123;                System.out.println(&quot;参数i错误&quot;);                return 0;            &#125;else &#123;                s=new LinkNode();                s.data=x;                s.next=p.next;                p.next=s;                return 1;            &#125;&#125;        //7.把表中的元素打印出来            public void display()&#123;                LinkNode tmp=Head;                while (tmp!=null) &#123;                    System.out.println(tmp.data+&quot;  &quot;);                    tmp=tmp.next;                &#125;                System.out.println();            &#125;&#125;</code></pre><h1 id="顺序表与单链表的比较"><a href="#顺序表与单链表的比较" class="headerlink" title="顺序表与单链表的比较"></a>顺序表与单链表的比较</h1><h2 id="顺序表的优点："><a href="#顺序表的优点：" class="headerlink" title="顺序表的优点："></a>顺序表的优点：</h2><p>其存储结构为随机存取结构，逻辑关系可直接用数组元素下标表示。</p><h2 id="顺序表的缺点："><a href="#顺序表的缺点：" class="headerlink" title="顺序表的缺点："></a>顺序表的缺点：</h2><p>①线性表的长度不确定，难以事先确定数组长度。<br>②存储空间必须是连续的，易造成存储空间的“碎片”现象。③插入和删除操作需要移动大量元素。</p><h2 id="单链表的优点："><a href="#单链表的优点：" class="headerlink" title="单链表的优点："></a>单链表的优点：</h2><p>①元素的存储单元是任意的，可连续也可不连续。②不需要限定长度。</p><h2 id="单链表的缺点"><a href="#单链表的缺点" class="headerlink" title="单链表的缺点"></a>单链表的缺点</h2><p>：①其查找时间复杂度为O(n)。②存放元素时需要另外开辟一个指针域的空间。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
