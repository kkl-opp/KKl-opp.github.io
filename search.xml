<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>numpy_sort&amp;del</title>
      <link href="/2022/08/18/numpy-sort/"/>
      <url>/2022/08/18/numpy-sort/</url>
      
        <content type="html"><![CDATA[<h2 id="NUMPY-SORT"><a href="#NUMPY-SORT" class="headerlink" title="NUMPY.SORT"></a>NUMPY.SORT</h2><p>ATTENTION ：</p><p>axis &#x3D; 0 代表行操作</p><p> axis &#x3D;1 代表列操作 </p><h3 id="1-sort"><a href="#1-sort" class="headerlink" title="1.sort"></a>1.sort</h3><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/nm7.png"></p><p>par1：传入的数组 可以是多维</p><p>par2：沿着排序的轴 axis&#x3D;-1 (x轴) axis &#x3D;0 (y轴) 默认axis&#x3D;-1</p><p>par3：提供的排序方法：quitsort heapsort timesort</p></n><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/nm6.png" alt="nm6">如何降序排列：</p><p> x[::-1]  注意仅对一维数组有效</p><p>如果对二维数组 我采用的方法是遍历反转</p><p>具体代码如下</p><p>ff &#x3D; np.array([[3, 6, 10, 2, 10], [2, 10, 3, 4, 5],[3,3,4,9,10]])</p><p>f1 &#x3D; np.sort(ff)</p><p>for index in range(len(f1)):</p><p>  print(f1[index][::-1])</p><h3 id="2-lexsort"><a href="#2-lexsort" class="headerlink" title="2.lexsort()"></a>2.lexsort()</h3><p>def lexsort(keys, axis&#x3D;None)</p><p>lexsort是一种多级排序方法。作用为对给定的 keys 中的<strong>最后一个 key</strong> 排序，每一个 key 都被认为是列向量，其他 keys 用来辅助最后一个 key 进行排序。最后返回最后一个 key 进行排序的<strong>索引</strong>。</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/nm5.png"></p><p>计算的规则如下：</p><p>#a1 拍完后的索引 再个根据b来进行比较</p><p>#a1 &#x3D; [80,70,90,100,100] &#x3D;&gt; [70,80,90,100,100] &#x3D;&gt; (1,0,2,3,4)</p><p>a1 &#x3D; [80,70,90,100,100]</p><p>b1 &#x3D; [77,92,88,95,92]</p><p>cc &#x3D; np.lexsort((b1,a1))</p><p># cause 95&gt;92 </p><p># return [1 0 2 4 3] index</p><h3 id="3-sort-complex"><a href="#3-sort-complex" class="headerlink" title="3.sort_complex()"></a>3.<strong>sort_complex()</strong></h3><p>对复数进行排序</p><h3 id="4-searchsorted"><a href="#4-searchsorted" class="headerlink" title="4.searchsorted()"></a>4.<strong>searchsorted()</strong></h3><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/nm4.png"></p><p>二分查找用于查找所需的插入点</p><p>从 NumPy 1.4.0 开始<a href="https://numpy.org/doc/stable/reference/generated/numpy.searchsorted.html#numpy.searchsorted" title="numpy.searchsorted">searchsorted</a>，可以使用包含 <a href="https://numpy.org/doc/stable/reference/constants.html#numpy.nan" title="numpy.nan">nan</a>值的实数&#x2F;复数数组。增强的排序顺序记录在<a href="https://numpy.org/doc/stable/reference/generated/numpy.sort.html#numpy.sort" title="numpy.sort">sort</a>.</p><p><a href="https://docs.python.org/3/library/bisect.html#bisect.bisect_left" title="（在 Python v3.10 中）">bisect.bisect_left</a> 此函数使用与内置 python ( side&#x3D;’left’) 和<a href="https://docs.python.org/3/library/bisect.html#bisect.bisect_right" title="（在 Python v3.10 中）">bisect.bisect_right</a>( ) 函数相同的算法，该算法side&#x3D;’right’也在_v_参数中进行了矢量化。</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/nm3.png"></p><p>关于二分查找需要一定要考虑好左右边界</p><p>测试效率：</p><p>import time</p><p>time_start &#x3D; time.time() </p><p>【put your codes in here】</p><p>time_end &#x3D; time.time()</p><p>time_sum &#x3D; time_end - time_start</p><p>print(time_sum)</p><h2 id="NUMPY-INSERT-x2F-DELETE"><a href="#NUMPY-INSERT-x2F-DELETE" class="headerlink" title="NUMPY INSERT&#x2F;DELETE"></a>NUMPY INSERT&#x2F;DELETE</h2><p>quick start</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/nm2.png"></p><p>numpy.append(arr, values, axis&#x3D;None)</p><p>如果没有给定axis 则会将数组完全展开</p><p>a &#x3D; np.array([[1,4,4,5,6],[2,3,3,4,5]])</p><p>c &#x3D; np.append(a,[[3,4,5,6,7],[1,2,3,4,5]],axis&#x3D;1)</p><p>print(c)</p><p>numpy.insert(arr, obj, values, axis)</p></n><p>参数说明：</p><ul><li><p>arr：输入数组</p></li><li><p>obj：在其之前插入值的索引</p></li><li><p>values：要插入的值</p></li><li><p>axis：沿着它插入的轴，如果未提供，则输入数组会被展开</p></li></ul><p>Numpy.delete(arr, obj, axis)</p></n><p>参数说明：</p><ul><li><p>arr：输入数组</p></li><li><p>obj：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组</p></li><li><p>axis：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开</p></li></ul><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/nm1.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hive on spark异常排查</title>
      <link href="/2022/08/15/hive-on-spark%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/"/>
      <url>/2022/08/15/hive-on-spark%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="问题发现：在使用bin-x2F-hive-启动hive的时候报错"><a href="#问题发现：在使用bin-x2F-hive-启动hive的时候报错" class="headerlink" title="问题发现：在使用bin&#x2F;hive 启动hive的时候报错"></a>问题发现：在使用bin&#x2F;hive 启动hive的时候报错</h3><p>Failed to execute spark task, with exception ‘org.apache.hadoop.hive.ql.metadata.HiveException(Failed to create spark client.)’<br>FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.spark.SparkTask</p><p>Hive版本 3.1.2</p><p>Spar版本 3.0.0</p><p>在官方查了资料可知目前hive最高支持2.6的spark版本，并不支持3.0的版本。所以要自己编译jar包和反编译。可以按照尚硅谷配置完</p><p>hive 和 spark的相关参数。</p><p>这边的hiveserver2 和 metastore 可以不用开，hive的元数据信息存储在mysql中，我们作为客户端可以直接连接，也可以选择metastore来间接连接。如果使用datagrip进行远程连接则需要在core-site.xml中配置(可略过)</p><p><strong>lyc-&gt;改成自己的host名</strong></p><pre><code> &lt;property&gt;      &lt;name&gt;hadoop.proxyuser.lyc.hosts&lt;/name&gt;      &lt;value&gt;*&lt;/value&gt; &lt;/property&gt; &lt;property&gt;        &lt;name&gt;hadoop.proxyuser.lyc.groups&lt;/name&gt; &lt;value&gt;*&lt;/value&gt; &lt;/property&gt;  &lt;property&gt; &lt;name&gt;dfs.permissions&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt;</code></pre><h3 id="故障排查："><a href="#故障排查：" class="headerlink" title="故障排查："></a>故障排查：</h3><p>打开&#x2F;tmp&#x2F;hive</p><p>查看日志</p><p>1.主机名显示错误</p><p>No Route to Host from  hadoop01&#x2F;192.168.10.20 to hadoop102:8020 failed on socket timeout exception: java.net.NoRouteToHostException: 没有到主机的路由; For more details see:  <a href="http://wiki.apache.org/ha">http://wiki.apache.org/ha</a></p><p>hadoop102 应该改成自己的 hadoop01 参数在hive.site.xml的配置中</p><p>2.配置环境变量</p><p>将Hadoop和spark的环境变量添加到自己的环境变量中，并检查</p><p>修改yarn-site.xml，在其中添加SPARK_HOME 并分发</p><p>3.修改spark连接的时间：</p><pre><code>&lt;!--Hive和Spark连接超时时间--&gt;&lt;property&gt;    &lt;name&gt;hive.spark.client.connect.timeout&lt;/name&gt;    &lt;value&gt;80000ms&lt;/value&gt;&lt;/property&gt;</code></pre><p>4.在saprk的conf下修改spark-env.sh（直接这样复制就可以）</p><p>export SPARK_DIST_CLASSPATH&#x3D;$(hadoop classpath)</p><p>5.内存分配不足</p><p>如果电脑是8g的可能启动下集群cpu就爆掉了，没有足够的内存跑任务，</p><p>spark对内存的依赖性比较高，还是老实使用mr去跑任务吧</p><p>总结：报错先去看对应的日志，去hadoop02中查看到详细信息，bug需要一步步进行排查，再从网上得出相关结论。Linux对某些资源的权限和参数把控的很严，如果不配置就会报错。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据生态圈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HIVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql中Inoodb底层原理</title>
      <link href="/2022/08/09/mysql%E4%B8%ADInoodb%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/2022/08/09/mysql%E4%B8%ADInoodb%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1.引言"></a>1.1.引言</h2><p>InnoDB是能够保证事务安全的MySQL存储引擎。主要特点是：</p><ul><li>支持行锁；</li><li>支持<a href="https://zhuanlan.zhihu.com/p/66791480">MVCC</a>;</li><li>支持外键；</li><li>提供一致性非锁定读；</li><li>被设计用来有效利用以及使用内存和CPU;</li></ul><h2 id="1-2-架构图"><a href="#1-2-架构图" class="headerlink" title="1.2.架构图"></a>1.2.架构图</h2><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L3lOS3YxUDRROWVYQ3U1S2liY2FZOFBoRHhZZ1NSeVRmMjNWVUpvaWExR0hkZXF5TFRBNXg5STdZaWJtVjM5ZmVNazhpYVpPTHZYbENhTzRpY3E5R05rSnZ6VkEvNjQw"></p><p>InnoDB 的架构分为两块：内存中的结构和磁盘上的结构。InnoDB 使用日志先行策略，将数据修改先在内存中完成，并且将事务记录成重做日志(Redo Log)，转换为顺序IO高效的提交事务。</p><p>这里日志先行，说的是日志记录到数据库以后，对应的事务就可以返回给用户，表示事务完成。但是实际上，这个数据可能还只在内存中修改完，并没有刷到磁盘上去。<strong>内存是易失的</strong>，如果在数据落地前，机器挂了，那么这部分数据就丢失了。</p><p>InnoDB 通过 redo 日志来保证数据的一致性。如果保存所有的重做日志，显然可以在系统崩溃时根据日志重建数据。</p><p>当然记录所有的重做日志不太现实，所以 InnoDB 引入了检查点机制。即定期检查，保证检查点之前的日志都已经写到磁盘，则下次恢复只需要从检查点开始。</p><h2 id="1-3-InnoDB-内存中的结构"><a href="#1-3-InnoDB-内存中的结构" class="headerlink" title="1.3.InnoDB 内存中的结构"></a>1.3.<strong>InnoDB 内存中的结构</strong></h2><p>Buffer Pool，Change Buffer、Adaptive Hash Index以及 Log Buffer</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/7c4eca9be779e05b590da69ba0dd0cb4.png"></p><h4 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h4><p>作用：为了加快数据的访问，会把常用的数据放在缓存中，避免每次都去访问数据库。</p><p>InnoDB中数据管理的最小单位为页，默认每页大小为16KB</p><p>缓冲池缓存的数据包括Page Cache、Change Buffer、Data Dictionary Cache等，通常 MySQL 服务器的 80% 的物理内存会分配给 Buffer Pool。Buffer Pool被分成了很多<strong>页</strong>，每页可以存放很多数据。那么为什么要分配这么多内存空间呢，因为能缓存的数据就更多，更多的操作都会发生在内存(内存是最快的！！)</p><p>多个Buffer Pool</p><p>一个mysql实例中，缓冲池不只一个，而是有多个，所有缓存页根据哈希值平均分配到不同缓冲池实例。将内存空间分为多个缓冲池是为了增加临界资源，减少多个线程对buffer pool的竞争（毕竟访问buffer pool的各种链表都需要加锁处理），提高并发。</p> <br/><p>每个 buffer pool有自己独立的内存空间，独立的lru、free、flush链表。buffer pool的个数不是越多越好，因为管理每一个buffer pool也需要开销。</p><br/><p>InnoDB使用了<strong>链表</strong>来组织页和页中存储的数据，页与页之间形成了<strong>双向链表</strong>，这样可以方便的从当前页跳到下一页，同时使用LRU（Least Recently Used）算法去淘汰那些不经常使用的数据。</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/94a4bc8add38b085ecc3eada5f477981.png"></p><p>为了提高缓存管理效率，InnoDB的缓存池通过一个页链表实现，很少访问的页会通过缓存池的 LRU 算法淘汰出去。这里不得提到</p><p>LRU算法</p><h4 id="LRU算法："><a href="#LRU算法：" class="headerlink" title="LRU算法："></a>LRU算法：</h4><p> 普通 : 实现的是末尾淘汰法,当整个<a href="https://so.csdn.net/so/search?q=%E9%93%BE%E8%A1%A8&spm=1001.2101.3001.7020">链表</a>已满时,淘汰尾部,将新的数据页加入头部</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/20210422201334762.png"></p><p><strong>new sublist占用5&#x2F;8的空间</strong>     <em><strong>*‘热端’*</strong></em>  经常被访问的数据<br>midpoint是两者的中间点<br><strong>old sublist占用3&#x2F;8的空间</strong>      <em><strong>*‘冷端’*</strong></em>  很少被访问的数据</p><p>起到了一个隔断的作用</p><p><strong>流程：</strong></p><p> 1.当 InnoDB 从磁盘读一页数据并放入缓冲池中时，它会将此页插入到列表的中间位置（也就是冷端页子表的头部）。发生读页一般是因为用户查询数据，或者InnoDB自动触发的read-ahead操作。</p><p>2.读取旧页子表中的数据会让该页变新（年轻，young），’并将其移动到缓冲池的头部（也就是新页子表的头部）。</p><p>3.如果是用户查询读造成该页被读取，则该页会立即被标识为年轻，并直接插入到列表头部。</p><p>如果该页因为read-ahead被读取，而是放入列表中点，需要再次读取才能使该页被标识为年轻状态。</p><p>read-ahead、或者表、索引扫描都会造成类似的缓冲池扰动。’在这些情景下，页通常会被读取（命中）若干次，然后从此不再访问。</p><p>为此MySQL提供了配置参数innodb_old_blocks_time用来指定该页在放入缓冲池后第一次读之后一定时间内（时间窗口，单位毫秒,milliseconds）</p><p>读取不会被标识为年轻，也就是不会被移动到列表头部。参数innodb_old_blocks_time的默认值是1000s，增大这个参数将会造成更多的页会更快的从缓冲池中被淘汰。<br>1s就淘汰</p><ul><li>Buffer Pool 预热</li></ul><p>Mysql重启时，BP中的热数据会清空，为此mysql提供了缓冲池预热功能，当关机时会把内存中的热数据写入到 ib_buffer_pool 文件中，保存的数据占 lru 的比例可由参数控制，mysql启动时会自动加载热数据到缓冲池。预热功能默认开启。</p><h4 id="MySQL缓冲池污染"><a href="#MySQL缓冲池污染" class="headerlink" title="MySQL缓冲池污染"></a>MySQL缓冲池污染</h4><p>当某一个SQL语句，要批量扫描大量数据时，可能导致把缓冲池的所有页都替换出去，导致大量热数据被换出，MySQL性能急剧下降，这种情况叫缓冲池污染。</p><p>全表扫描 或者查询到一个数量集比较大的数据 如果频繁读写就会把young的部分的数据全部替换出去</p><p>所以innodb就采用了young 的和 old 两个分区 大量的数据首先会被插入到old的头部 待的时间需要大于T</p><p>才会被放在young区的头部，并淘汰young区不活跃的页</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/2021050715434878.png"></p><h4 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h4><p>DML 不会立刻刷入磁盘 而是会先将变更的页写入到缓冲区，经过一系列策略同步到磁盘。</p><p>Change buffer 的主要目的是将对 <strong>非唯一 辅助索引页的操作缓存下来</strong>，以此减少辅助索引的随机IO，并达到操作合并的效果。它会占用部分Buffer Pool 的内存空间。如果辅助索引页已经在缓冲区了，则直接修改即可；如果不在，则先将修改保存到 Change Buffer。Change Buffer的数据在对应辅助索引页读取到缓冲区时合并到真正的辅助索引页中。Change Buffer 内部实现也是使用的 B+ 树。</p><p>此时分为两种情况：</p><p>1、当更改的页存在于 Buffer Pool 的 lru 链表，则直接在缓冲池中修改这个页，这个页会变成脏页，链入到 flush list中，但并不马上刷盘；此时不涉及 change buffer 操作。</p> <br/><p>2、当更改的页不存在于 Buffer Pool 的 lru 链表，就要先从磁盘读取要修改的数据页到Buffer Pool后再修改（数据不可能在磁盘中直接更改，肯定要读到内存，在内存中修改）。</p><p>但为了避免修改操作引发的磁盘读IO，系统会将DML操作记录到 change buffer中，并不马上刷盘。</p><p>等下次对这些修改的页进行查询时，由于lru链表不存在该页，会从磁盘读取（磁盘页是更改前的数据），为了避免读到脏数据，该磁盘页会和 change buffer中的更改合并后才链入到 lru链表。</p><p>如果未来一段时间都不会查询到这个修改了的页，也会有 insert buffer thread 定时将change buffer 的数据合并到磁盘页中。</p><p>change buffer 默认占 Buffer Pool 的 25%，最大允许占50%。可以根据写业务的量调整，写操作越频繁，change buffer 带来的性能提升越明显。</p><br/><p>查看Change Buffer信息</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">engine</span> <span class="token keyword">innodb</span> <span class="token keyword">status</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Adaptive-Hash-Index"><a href="#Adaptive-Hash-Index" class="headerlink" title="Adaptive Hash Index"></a>Adaptive Hash Index</h4><p>自适应哈希索引(AHI)查询非常快，一般时间复杂度为 O(1)，相比 B+ 树通常要查询 3~4次，效率会有很大提升。innodb 通过观察索引页上的查询次数，如果发现建立哈希索引可以提升查询效率，则会自动建立哈希索引，称之为自适应哈希索引，不需要人工干预，可以通过 innodb_adaptive_hash_index 开启，MySQL5.7 默认开启。</p><p>考虑到不同系统的差异，有些系统开启自适应哈希索引可能会导致性能提升不明显，而且为监控索引页查询次数增加了多余的性能损耗， MySQL5.7 更改了 AHI 实现机制，每个 AHI 都分配了专门分区，通过 innodb_adaptive_hash_index_parts配置分区数目，默认是8个</p><h4 id="Log-Buffer"><a href="#Log-Buffer" class="headerlink" title="Log Buffer"></a>Log Buffer</h4><p>Log Buffer是 重做日志在内存中的缓冲区，大小由 innodb_log_buffer_size 定义，默认是 16M。一个大的 Log Buffer可以让大事务在提交前不必将日志中途刷到磁盘，可以提高效率。如果你的系统有很多修改很多行记录的大事务，可以增大该值。</p><p>配置项 innodb_flush_log_at_trx_commit 用于控制 Log Buffer 如何写入和刷到磁盘。注意，除了 MySQL 的缓冲区，操作系统本身也有内核缓冲区。</p><p>默认为1，表示每次事务提交都会将 Log Buffer 写入操作系统缓存，并调用配置的 “flush” 方法将数据写到磁盘。</p><p>设置为 1 因为频繁刷磁盘效率会偏低，但是安全性高，最多丢失 1个 事务数据。</p><p>而设置为 0 和 2 则可能丢失 1秒以上 的事务数据。</p><p>为 0 则表示每秒才将 Log Buffer 写入内核缓冲区并调用 “flush” 方法将数据写到磁盘。</p><p>为 2 则是每次事务提交都将 Log Buffer写入内核缓冲区，但是每秒才调用 “flush” 将内核缓冲区的数据刷到磁盘。</p><p>innodb_flush_log_at_timeout 可以配置刷新日志缓存到磁盘的频率，默认是1秒。注意刷磁盘的频率并不保证就正好是这个时间，可能因为MySQL的一些操作导致推迟或提前。</p> <br/><p>而这个 “flush” 方法并不是C标准库的 fflush 方法(fflush是将C标准库的缓冲写到内核缓冲区，并不保证刷到磁盘)，它通过 innodb_flush_method 配置的，默认是 fsync，即日志和数据都通过 fsync 系统调用刷到磁盘。</p><p>可以发现，InnoDB 基本每秒都会将 Log buffer落盘。而InnoDB中使用的 redo log 和 undo log，它们是分开存储的。</p> <br/><p>redo log在内存中有log buffer，在磁盘对应ib_logfile文件。而undo log是记录在表空间ibd文件中的，InnoDB为undo log会生成undo页，对undo log本身的操作（比如向undo log插入一条记录），也会记录redo log，因此undo log并不需要马上落盘。而 redo log 则通常会分配一块连续的磁盘空间，然后先写到log buffer，并每秒刷一次磁盘。</p><p>redo log 必须在数据落盘前先落盘(Write Ahead Log)，从而保证数据持久性和一致性。而数据本身的修改可以先驻留在内存缓冲池中，再根据特定的策略定期刷到磁盘。</p><h2 id="2-InnoDB-磁盘上的结构"><a href="#2-InnoDB-磁盘上的结构" class="headerlink" title="2.InnoDB 磁盘上的结构"></a>2.<strong>InnoDB 磁盘上的结构</strong></h2><p><strong>表空间：</strong></p><p>分为系统表空间(MySQL 目录的 ibdata1 文件)，临时表空间，常规表空间，Undo 表空间以及 file-per-table 表空间(MySQL5.7默认打开file_per_table 配置）。</p><p>系统表空间又包括了InnoDB数据字典，双写缓冲区(Doublewrite Buffer)，修改缓存(Change Buffer），Undo日志等。</p><p><strong>Redo日志：</strong></p><p>存储的就是 Log Buffer 刷到磁盘的数据。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用datagrip连接clickhouse</title>
      <link href="/2022/07/28/%E4%BD%BF%E7%94%A8datagrip%E8%BF%9E%E6%8E%A5clickhouse/"/>
      <url>/2022/07/28/%E4%BD%BF%E7%94%A8datagrip%E8%BF%9E%E6%8E%A5clickhouse/</url>
      
        <content type="html"><![CDATA[<h3 id="1-编辑两个配置"><a href="#1-编辑两个配置" class="headerlink" title="1.编辑两个配置"></a>1.编辑两个配置</h3><p>在原有的基础上新增即可</p><p>etc&#x2F;security&#x2F;limits.conf</p><pre><code>* soft nofile 65536* hard nofile 65536* soft nproc 131072* hard nproc 131072</code></pre><p>&#x2F;etc&#x2F;security&#x2F;limits.d&#x2F;20-nproc.conf</p><pre><code>* soft nofile 65536* hard nofile 65536* soft nproc 131072* hard nproc 131072</code></pre><p>并xsync分发到集群</p><p>sudo   &#x2F;home&#x2F;lyc&#x2F;bin&#x2F;xsync  xxx</p><h3 id="2-安装依赖"><a href="#2-安装依赖" class="headerlink" title="2.安装依赖"></a>2.安装依赖</h3><p>分别在三台机子上</p><p>sudo yum install -y libtool</p><p>sudo yum install -y <em>unixODBC</em></p><h3 id="3-修改SELINUX"><a href="#3-修改SELINUX" class="headerlink" title="3.修改SELINUX"></a>3.修改SELINUX</h3><p>sudo vim &#x2F;etc&#x2F;selinux&#x2F;config</p><p>SELINUX&#x3D;disabled</p><p>分发 重启机子</p><h3 id="4-安装clickhouse"><a href="#4-安装clickhouse" class="headerlink" title="4.安装clickhouse"></a>4.安装clickhouse</h3><p>创一个文件夹 拖进去</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220728230709986.png"></p><p>将这个文件夹分发到其他机子上</p><p>三台机子上都要安装，分布式</p><p>sudo rpm -ivh   *.rpm（以rpm结尾的全部解压）</p><p>修改配置文件 &#x2F;etc&#x2F;clickhouse-server&#x2F;config.xml</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220728230932761.png"></p><p>分发</p><p>启动：sudo systemctl start clickhouse-server</p><p>停止:   sudo systemctl stop clickhouse-server</p><p>状态:   sudo systemctl status clickhouse-server</p><p><strong>自启 sudo systemctl disable clickhouse-server</strong> </p><p>测试：</p><p>在第一台机子直接测试</p><p>clickhouse-client -m</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220728231143024.png"></p><p>说明已经成功了</p><h3 id="5-使用datagrip连接clickhouse"><a href="#5-使用datagrip连接clickhouse" class="headerlink" title="5.使用datagrip连接clickhouse"></a>5.使用datagrip连接clickhouse</h3><p><strong>csdn上基本全是错误的</strong> </p><h4 id="1-新建一个数据源"><a href="#1-新建一个数据源" class="headerlink" title="1.新建一个数据源"></a>1.新建一个数据源</h4><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220728231305535.png"></p><h4 id="2-下载依赖-下方有个东西-download"><a href="#2-下载依赖-下方有个东西-download" class="headerlink" title="2.下载依赖 下方有个东西 download"></a>2.下载依赖 下方有个东西 download</h4><p>不要着急去连接 一连接就是 connect refused！删除这个DataSource 重启 datagrip     (点击减号)</p><p>重启后，新建一个DataSource</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220728231645720.png"></p><h4 id="3-按这样连接-点击test-如果是绿色就是连接成功了"><a href="#3-按这样连接-点击test-如果是绿色就是连接成功了" class="headerlink" title="3.按这样连接 点击test 如果是绿色就是连接成功了"></a>3.按这样连接 点击test 如果是绿色就是连接成功了</h4><p>host就是你自己的ip地址</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220728231607233.png"></p><p>到这一步安装的部分就全部结束了</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220728231740054.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>全排列</title>
      <link href="/2022/07/19/%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2022/07/19/%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,1,2]<br>输出：<br>[[1,1,2],<br> [1,2,1],<br> [2,1,1]]<br>示例 2：</p><p>输入：nums &#x3D; [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p><p><strong>解题思路：去重一定要对元素进行排序，这样才能通过相邻节点来判断是否重复使用过</strong><br>class Solution {<br>    &#x2F;&#x2F;存放结果<br>    List&lt;List<Integer>&gt; result &#x3D; new ArrayList&lt;&gt;();<br>    &#x2F;&#x2F;暂存结果<br>    List<Integer> path &#x3D; new ArrayList&lt;&gt;();</p><pre><code>public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;    boolean[] used = new boolean[nums.length];    Arrays.fill(used, false);    Arrays.sort(nums);    backTrack(nums, used);    return result;&#125;private void backTrack(int[] nums, boolean[] used) &#123;    if (path.size() == nums.length) &#123;        result.add(new ArrayList&lt;&gt;(path));        return;    &#125;    for (int i = 0; i &lt; nums.length; i++) &#123;        // used[i - 1] == true，说明同⼀树⽀nums[i - 1]使⽤过        // used[i - 1] == false，说明同⼀树层nums[i - 1]使⽤过        // 如果同⼀树层nums[i - 1]使⽤过则直接跳过        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == false) &#123;            continue;        &#125;        //如果同⼀树⽀nums[i]没使⽤过开始处理        if (used[i] == false) &#123;            used[i] = true;//标记同⼀树⽀nums[i]使⽤过，防止同一树支重复使用            path.add(nums[i]);            backTrack(nums, used);            path.remove(path.size() - 1);//回溯，说明同⼀树层nums[i]使⽤过，防止下一树层重复            used[i] = false;//回溯        &#125;    &#125;&#125;</code></pre><p>}</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的锁机制</title>
      <link href="/2022/07/06/mysql%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/07/06/mysql%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h1><p>并发事务访问，分为以下几种</p><p>1.读-读 允许</p><p>2.写-写 对相同的数据进行写入 可能出现脏写</p><p>一条事务加一个锁？ 三个事务开三把锁 等待执行is_waitting </p><p>如果为true 就让下一个事务等它执行完再继续执行操作。</p><p>3.读-写</p><p>脏读，不可重复读，幻读</p><p>脏读</p><p>指事务A读取到了事务B更新了但是未提交的数据，然后事务B由于某种错误发生回滚，那么事务A读取到的就是脏数据。</p><p><strong>举个例子</strong> </p><p>我查要这个人的salary原本应该是10000，记为线程A(read)，另一个线程B（write)在这个线程A之前 把salary修改了5000，此时事务还未提交，还没来得及进行回滚，然后我就查到了线程B的数据 5000。 结果线程B内部错误，导致整个事务回滚，回溯到10000。线程A继续执行命令 将这个人的脏读的salary加上10000</p><p>脏读的数据：5000+10000</p><p>实际的应该的数据：10000+10000</p><br/><p>不可重复读</p><p>两次读发现结果不一样。线程A最开始查一次 中间插进来一个线程B 直接把你查的东西改掉，可能是木马病毒，导致你这个任务最后再读的时候发现这个查的和第一次不一样。</p><p>幻读：</p><p>两次读发现结果多了几条。直接将你查的东西数据乱插入几条。导致你这个任务最后再读的时候发现这个查的和第一次不一样。</p><p>并发问题解决方案1：MVCC </p><p>MVCC生成一个ReadView 读操作只能查到ReadView生成之前已提交事务所做的更改 未提交的事务都是看不到的，写操作枷锁</p><p>ReadView的存在保证了事务不可以读取到未提交的事务所做的更改。</p><p>并发问题解决方案2：读写都加锁</p><p>性能：w，r 彼此不冲突。MVCC方案效率高</p><p>MYSQL:</p><p>1.对数据的操作类型进行划分</p><p>读锁&#x2F;写锁 通常被称为共享锁&#x2F;排他锁 S锁 X锁</p><p>旧版本加S锁 SELECT….. LOCK IN SHARE MODE</p><p>8.0       FOR SHARE</p><p>X锁 FOR UPDATE</p><h2 id="1-表锁"><a href="#1-表锁" class="headerlink" title="1.表锁"></a>1.表锁</h2><h4 id="1-1表级别的s锁和x锁"><a href="#1-1表级别的s锁和x锁" class="headerlink" title="1.1表级别的s锁和x锁"></a>1.1表级别的s锁和x锁</h4><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> t <span class="token keyword">READ</span> <span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> t <span class="token keyword">WRITE</span> unlock <span class="token keyword">tables</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-07-26%20104214.png"></p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-07-26%20104247.png"></p><p>粒度大枷锁的速度快 在开启另一个事务的时候锁会被释放</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">begin</span> <span class="token punctuation">;</span><span class="token keyword">lock</span> <span class="token keyword">tables</span> user_profile <span class="token keyword">read</span> <span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token operator">*</span>  <span class="token keyword">from</span> user_profile<span class="token punctuation">;</span><span class="token keyword">commit</span> <span class="token punctuation">;</span><span class="token keyword">begin</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> user_profile <span class="token keyword">value</span> <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1231</span><span class="token punctuation">,</span><span class="token string">'male'</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token string">'besadida'</span><span class="token punctuation">,</span><span class="token number">3.2</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">rollback</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于DDL 就算你给它开启了事务 你是<strong>无法回滚</strong>的 因为是对表的结构进行操作 所以慎用drop！truncate好像也不能回滚！</p><p>s锁 两者均可读 均不可写</p><p>x锁 自己可写可读 他人写读统统阻塞</p><h4 id="1-2元数据锁"><a href="#1-2元数据锁" class="headerlink" title="1.2元数据锁"></a>1.2元数据锁</h4><p>不需要手动开启，在访问一个表的时候会<strong>自动加上</strong></p><p>当对一个表做增删查改的时候，加MDL读锁，当对<strong>表结构做更改</strong>操作的时候，加MDL写锁</p><ul><li><ul><li><strong>读锁之间不互斥</strong>，所以可以多个线程同时对一张表增删查改(DML DQL)；</li><li><strong>读写锁之间，写锁之间是互斥的</strong>，如果有多个线程要同时给一个表加字段，其中一个要等待另外一个执行完成才能开始执行；</li></ul></li><li><strong>事物中的MDL锁，在语句执行时开始申请，但是语句结束后并不会马上释放，而是等到这个事物提交后才释放；</strong> （⭐）</li></ul><p>所以说开启了事务 没问题的话就赶紧commit掉 不然就rollback重新改sql。不然会造成数据库崩溃等严重后果，你就等着跑路吧</p><br/><p>InnoDB的厉害之处还是实现了更细粒度的 行锁 表锁不推荐使用</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/025sn2_SetwD85riH8hH7FYo2_u46cCMjweYHqtfi48.png"></p><p>Innodb支持多粒度锁，允许行锁和表锁共存，意向锁就是其中的一种</p><br/><h4 id="1-3意向锁"><a href="#1-3意向锁" class="headerlink" title="1.3意向锁"></a>1.3意向锁</h4><p><strong>作用：</strong> 加意向锁的目的是为了表明某个事务正在锁定一行或者将要锁定一行。表名加锁的“意图”。</p><p>因为mysql中表锁和行锁是可以<strong>共存</strong>的</p><br/><p>数据库对表进行操作的时候 需要判断两点条件</p><p><strong>1.这个表是否被锁住</strong></p><p><strong>2.表中的行是否被锁住</strong></p><br/><p><strong>IS意向共享锁 :对表中某行上s锁，默认这个表会开一个IS锁</strong></p><p><strong>IX意向共享锁:对表中某行上x锁，默认这个表会开一个Ix锁</strong></p><p>意向锁之间是互相<strong>兼容</strong>的，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性</p><p>事务A 查询id &#x3D;5 并上S锁 。事务B 也查询id&#x3D;6 并上X锁 是被允许的</p><p>举例：事务A要修改这个表中的某一行</p><p>流程：</p><p>1.检查这个表是否上了读锁或者是写锁</p><p>2.然后A向这个表申请IX锁或IS锁，如果申请不到，就说明有另外事务在对这个表中的行进行加锁</p><p>IX锁可以看做一把钥匙，钥匙在其他事务手上，也抢不过来，只能等它的事务一提交，钥匙就</p><p>没人占用了，事务A就可以拿到这个IX锁了</p><p>3.一拿到这个IX锁就可以获得这个表的最高权限，你就可以进行修改了</p><p>总结：</p><ul><li>IX IS 自己之间不会冲突，都在上锁，没什么关系</li><li>IS S 之间不冲突，其他都冲突。</li><li>意向锁的目的是为了避免全表扫描。</li></ul><p>SELECT column FROM table … FOR UPDATE;</p><p>DBA对某行上X锁 那么InooDB就会为这个表上IX锁 </p><p>由于意向锁是由InooDB维护的，我们并不能去更改它</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/lcM5HW2AMERlh9pf97RN1dPFryG11KHGsCexUXhk0Yw.png"></p><p>从上图我们可以看见</p><p>提示：如果我们对表加锁，机器是不知道你哪行是上了锁的 ！！它只能从头到尾遍历 效率极低</p><p>才引出意向锁</p><p>(X1) IX  (X2) IX 都不冲突</p><p>那么事务A、B同时修改你这条记录呢？ 那么就跟你这个意向锁没什么关系 直接被行X锁 X锁之间阻塞了</p><p>第二种情况流程：<br>事务A在执行 对某行进行查询并上了X锁 默认表就会有一个意向排他锁IX  </p><p>事务B插进来 想要将表上X锁 首先它要拿到这个表的IX锁 才可以上锁</p><p>但是IX锁还在事务A中 事务B就抢不过来 就没有权限，直接阻塞。</p><p>等你A执行完 然后执行B </p><p>commit提交后事务结束 就释放这个锁</p><h2 id="2-行锁"><a href="#2-行锁" class="headerlink" title="2.行锁"></a>2.行锁</h2><h4 id="MySQL的行锁又分为共享锁（S锁）和排他锁（X锁）。"><a href="#MySQL的行锁又分为共享锁（S锁）和排他锁（X锁）。" class="headerlink" title="MySQL的行锁又分为共享锁（S锁）和排他锁（X锁）。"></a>MySQL的行锁又分为共享锁（S锁）和排他锁（X锁）。</h4><p>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可 以继续获取X型记录锁； 当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不 可以继续获取X型记录锁。</p><h4 id="间隙锁（Gap-Locks）"><a href="#间隙锁（Gap-Locks）" class="headerlink" title="间隙锁（Gap Locks）"></a>间隙锁（Gap Locks）</h4><p>MySQL 在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 MVCC 方 案解决，也可以采用 加锁 方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读 取操作时，那些幻影记录尚不存在，我们无法给这些 幻影记录 加上 记录锁 。InnoDB提出了一种称之为 Gap Locks 的锁，官方的类型名称为： LOCK_GAP ，我们可以简称为 gap锁 。</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-07-26%20130309.png"></p><h4 id="临键锁（Next-Key-Locks）"><a href="#临键锁（Next-Key-Locks）" class="headerlink" title="临键锁（Next-Key Locks）"></a>临键锁（Next-Key Locks）</h4><p>跟间隙锁差不多 只是不允许在这个行记录的前面加值</p><p>一般普通的select语句，InnoDB不加任何锁，我们称之为快照读</p><pre><code>select * from test;</code></pre><p>通过加S锁和X锁的select语句或者插入&#x2F;更新&#x2F;删除操作，我们称之为当前读</p><pre><code>select * from test lock in share mode;select * from test for update;insert into test values(…);update test set …;delete from test …;</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>特殊说明：以上的当前读，读取的都是记录的最新版本。对读取记录都会加锁，除了第一条语句lock in share mode是对记录加S锁（共享锁）外，其他的操作都是加X锁（排他锁）。两阶段锁协议</p><p>传统的关系型数据库加锁都要遵循一个原则：</p><h4 id="两阶段锁原则"><a href="#两阶段锁原则" class="headerlink" title="两阶段锁原则"></a>两阶段锁原则</h4><p>两阶段锁是将锁的操作分为两个阶段，加锁阶段和解锁阶段，并且保证加锁阶段和解锁阶段不相交。</p><p>分享一个例子说明两阶段锁协议：</p><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>不同事务隔离级别对应的行锁也是不同的，所以我们需要先了解事务的隔离级别后，再来演示不同隔离级别的行锁如何加上去。</p><p>MySQL的4种隔离级别：</p><p>READ UNCOMMITTED（读未提交）：任何一个事务当中，都可以看见其他事务的执行情况，会出现脏读现象。<br>READ COMMITTED（读已提交，简称：RC）：在当前事务中只能看见已经提交事务的执行结果，当同一事务在读取期间出现新的commit操作，会出现不可重复读现象。<br>REPEATABLE READ（可重复读，简称：RR）：这是MySQL默认的隔离级别，得益于MVCC，</p><p>它能在同一事务在多实例并发读取数据时看到相同的数据行，消除了脏读、不可重复读，默认不会出现幻读</p><p>（MySQL的行锁+间隙锁解决了快照读的幻读，未解决当前读的幻读）。<br>SERIALIZABLE（串行）：MySQL的最高隔离级别，通过加锁，强制事务执行顺序，保证不会出现幻读问题。</p><p><strong>没有索引的情况下，InnoDB的当前读会对所有记录都加锁。所以在实际开发中，如果是当前读或者是插入&#x2F;更新&#x2F;删除等操作一定要使用索引，否则会产生大量的锁等待</strong>。</p><h3 id="RC隔离级别-where唯一索引"><a href="#RC隔离级别-where唯一索引" class="headerlink" title="RC隔离级别+where唯一索引"></a>RC隔离级别+where唯一索引</h3><p>避免了当前读，所有记录都枷锁的情况，造成业务等待</p><h2 id="3-乐观和悲观锁"><a href="#3-乐观和悲观锁" class="headerlink" title="3.乐观和悲观锁"></a>3.乐观和悲观锁</h2><p>乐观锁（Optimistic Lock）： 就是很乐观，每次去拿数据的时候都认为别人不会修改。所以不会上锁，但是如果想要更新数据，则会在更新前检查在读取至更新这段时间别人有没有修改过这个数据。如果修改过，则重新读取，再次尝试更新，循环上述步骤直到更新成功（当然也允许更新失败的线程放弃操作）,乐观锁适用于多读的应用类型，这样可以提高吞吐量</p><p>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本（version）或者是时间戳来实现，不过使用版本记录是最常用的。</p><br/><p>悲观锁（Pessimistic Lock）： 就是很悲观，每次去拿数据的时候都认为别人会修改。所以每次在拿数据的时候都会上锁。这样别人想拿数据就被挡住，直到悲观锁被释放，悲观锁中的共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</p><p>但是在效率方面，处理加锁的机制会产生额外的开销，还有增加产生死锁的机会。另外还会降低并行性，如果已经锁定了一个线程A，其他线程就必须等待该线程A处理完才可以处理</p><h2 id="4-MVCC"><a href="#4-MVCC" class="headerlink" title="4.MVCC"></a>4.MVCC</h2><p><strong>MVCC</strong><br>**<code>MVCC</code>**，全称 <code>Multi-Version Concurrency Control</code> ，即多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>。</p><p><strong>解决：堵塞问题</strong></p><p><strong>当前读</strong><br>像 select lock in share mode (共享锁), select for update; update; insert; delete (排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是<strong>记录的最新版本</strong>，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁</p><p><strong>快照读</strong><br>像不加锁的 select 操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即 MVCC ,可以认为 MVCC 是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而<strong>有可能是之前的历史版本</strong></p><p>MVCC 多版本并发控制是 「维持一个数据的多个版本，使得读写操作没有冲突」 的概念，只是一个抽象概念，并非实现<br>因为 MVCC 只是一个抽象概念，要实现这么一个概念，MySQL 就需要提供具体的功能去实现它，「快照读就是 MySQL 实现 MVCC 理想模型的其中一个非阻塞读功能」。而相对而言，当前读就是悲观锁的具体功能实现</p><h4 id="3-1-1数据库并发场景？"><a href="#3-1-1数据库并发场景？" class="headerlink" title="3.1.1数据库并发场景？"></a>3.1.1数据库并发场景？</h4><ul><li><code>读-读</code>：不存在任何问题，也不需要并发控制</li><li><code>读-写</code>：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li><li><code>写-写</code>：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</li></ul><h4 id="3-1-2MVCC组合"><a href="#3-1-2MVCC组合" class="headerlink" title="3.1.2MVCC组合"></a>3.1.2MVCC组合</h4><ul><li><p><code>MVCC + 悲观锁</code>：MVCC解决读写冲突，悲观锁解决写写冲突</p></li><li><p><code>MVCC + 乐观锁</code>：MVCC解决读写冲突，乐观锁解决写写冲突</p></li><li><p>我们数据库中的每行数据，除了我们肉眼看见的数据，还有几个隐藏字段，得开天眼才能看到。分别是trx_id、db_roll_pointer。</p><p>trx_id</p><p>6byte，最近修改(修改&#x2F;插入)事务ID：记录创建这条记录&#x2F;最后一次修改该记录的事务ID。</p><p>roll_pointer（版本链关键）</p><p>7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</p><p>如上图，<code>trx_id</code>是当前操作该记录的<code>事务ID</code>，而<code>roll_pointer</code>是一个<code>回滚指针</code>，用于配合<code>undo日志</code>，指向上一个<code>旧版本</code></p></li></ul><p><strong>6.2 undo日志</strong></p><p>Undo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到undo log里。</p><p>当事务进行回滚时可以通过undo log 里的日志进行数据还原。</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/20210707173920585.png"></p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/20210707173953585.png"></p><p><strong>Undo log 的用途</strong></p><p>保证事务进行rollback时的原子性和一致性，当事务进行回滚的时候可以用undo log的数据进行恢复。<br>用于MVCC快照读的数据，在MVCC多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。<br>1.insert undo log</p><p>代表事务在insert新记录时产生的undo log , 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p><p>2.update undo log（主要）</p><p>事务在进行update或delete时产生的undo log ; 不仅在事务回滚时需要，在快照读时也需要；</p><p>所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除<br>————————————————</p><h4 id="3-1-3侧视图"><a href="#3-1-3侧视图" class="headerlink" title="3.1.3侧视图"></a>3.1.3侧视图</h4><p>事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照。</p><p>记录并维护系统当前活跃事务的ID(trx_id)(没有commit，当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以越新的事务，ID值越大)，是系统中当前不应该被本事务看到的其他事务id列表。</p><p>Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</p><p>trx_ids: 当前系统活跃(未提交)事务版本号集合。<br>low_limit_id: 创建当前read view 时“当前系统最大事务版本号+1”。<br>up_limit_id: 创建当前read view 时“系统正处于活跃事务最小版本号”<br>creator_trx_id: 创建当前read view的事务版本号；</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql中的表空间</title>
      <link href="/2022/06/18/mysql%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4/"/>
      <url>/2022/06/18/mysql%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql表空间"><a href="#mysql表空间" class="headerlink" title="mysql表空间"></a>mysql表空间</h1><p>查看是否开启：show variables like ‘%innodb_file_per_table%’ ;</p><p>SHOW VARIABLES LIKE ‘datadir’;</p><p>0 代表系统 1代表独立</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/SO6Ld1GtjHNlSJIV-bQF-YPiXg71ITxP7Wmk0qi8tVw.png"></p><h3 id="1-独立表空间"><a href="#1-独立表空间" class="headerlink" title="1. 独立表空间"></a>1. 独立表空间</h3><p>底层的存储是怎么存储的？那么多表mysql是如何管理和维护数据和索引的？那么要搞清楚这个概念，你需要知道的是表空间的相关知识。</p><p>对于 InnoDB 存储引擎，它可以将每张表存放于独立的表空间（1-&gt;1），即 <code>tablename.ibd</code> 文件；也可以将数据存放于 <code>ibdata</code> 的共享表空间，一般命名是 <code>ibdataX</code>，后面的 X 是一个具体的数字。</p><ul><li><strong>需要注意的是，**<strong>innodb_file_per_table</strong></strong> 要在创建表之前修改，创建表之后再去修改，是不会影响已有的表结构。**</li><li>每张表的数据和索引都会存储在自己的表空间中。</li></ul><ol><li>可以实现单表在不同的数据库中移动（因为每张表都有独立的数据表文件）。</li><li>空间可以回收（通过 optimize table 等命令实现）。</li></ol><h2 id="2-系统表空间"><a href="#2-系统表空间" class="headerlink" title="2.系统表空间"></a>2.系统表空间</h2><p>默认情况下，InnoDB会在数据目录下创建一个名为 ibdata1 、大小为 12M 的文件，这个文件就是对应</p><p>的 系统表空间 在文件系统上的表示。怎么才12M？注意这个文件是 自扩展文件 ，当不够用的时候它会自己增加文件大小。</p><h2 id="3-版本变动"><a href="#3-版本变动" class="headerlink" title="3.版本变动"></a>3.版本变动</h2><p>在MySQL5.6.6以及之后的版本中，innodb为每一个表建立一个独立表空间 ，也就是说我们创建了多少个表，就有多少个独立表空间。使用 独立表空间 来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同，只不过添加了一个 .ibd 的扩展名而已。</p><p>MySQL5.7 中会在data&#x2F;a的目录下生成 db.opt 文件用于保存数据库的相关配置</p><p>在8.0中 frm 和 ibd -&gt; ibd  db.opt也不再提供</p><p>扩展：</p><p>如果采取MyISAM引擎 ，data\a中会产生3个文件：</p><p>MySQL5.7 中： b.frm ：描述表结构文件，字段长度等。</p><p>MySQL8.0 中 b.xxx.sdi ：描述表结构文件，字段长度等</p><p>b.MYD (MYData)：数据信息文件，存储数据信息(如果采用独立表存储模式)</p><p>b.MYI (MYIndex)：存放索引信息文件</p><h2 id="4-共享表空间和独立表空间的优缺点"><a href="#4-共享表空间和独立表空间的优缺点" class="headerlink" title="4.共享表空间和独立表空间的优缺点"></a>4.共享表空间和独立表空间的优缺点</h2><p>共享表空间<br>Innodb的所有数据保存在一个单独的表空间里面，共享表空间可以由多个文件组成，当表使用共享表空间时，表数据可以分布在多个文件中，从而不受Innodb单表不超过64TB的限制。<br>默认的共享表空间的文件路径在data目录下，默认文件名为ibdata1，初始化为10M。</p><p>优点：<br>可以放表空间分成多个文件存放到各个磁盘上，没有单表不超过64TB的限制。</p><p>缺点：<br>由于多表共用一个共享表空间，当某些表进行大量删除后，共享表空间存在大量碎片，但MySQL暂未提供对共享表空间收缩的方法。<br>表空间中的空间只能被这个表使用<br>fsync操作必须在每个表上都运行一遍<br>mysqld必须保持一个打开的文件句柄，表太多会影响性能。(消耗很多 fd)</p><p>通过innodb_file_per_table参数将innodb表的数据和索引存放到其自己的表空间中，不再使用共享表空间，独立表空间的默认目录为innodb_data_file<br>独立表空间<br>优点：<br>1、 每个表有自己独立的表空间，数据和索引存放到其独立的表空间中。<br>2、可以轻松实现表在不同数据库之间移动<br>3、DROP TABLE后，表使用的空间立即被释放<br>4、当表中数据被大量删除后，可以使用alter table TableName engine&#x3D;innodb;来进行收缩<br>5、表空间存在碎片时不会影响其他表的使用。</p><p>缺点：<br>1、使用独立表空间后，无法再将表数据分散到不同的多个文件中，如果单个存储无法提供该表所需的全部空间时，无法通过增加新存储来解决<br>2、innodb_file_per_table开启后，不会影响已经使用共享表空间的表。<br>3、单表数据较大时，导致其对于的数据文件过大而不利于维护</p><h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p>系统表空间<br>使用系统表空间的话，会在该表所在数据库对应的子目录下创建一个名为”表名.frm”的文件，表中的数据会存储在对应的文件中。</p><p>独立表空间<br>会在该表所在数据库对应的子目录下创建一个名为”表名.frm”和一个名为”表名.ibd”的文件，表中的数据会存储在这个ibd的文件中。8.0只有ibd 默认独立</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/SUDMhXOXWIhr6oebk0RvPtICdaepVV4TXzA7J77UACs.png"></p><p>Q:有什么用？为什么要提出namespace的概念？</p><p>对于<code>InnoDB</code>存储引擎来说，每一个<a href="https://so.csdn.net/so/search?q=%E8%A1%A8%E7%A9%BA%E9%97%B4&spm=1001.2101.3001.7020">表空间</a>可被划分成很多个页，表数据存放在表空间下的某些页中。表空间分为几种不同的类型。</p><p>这里谈到了区和段的概念</p><h3 id="区"><a href="#区" class="headerlink" title="区"></a>区</h3><p>表空间中的页实在是太多了，为了更好的管理这些页面，所以提出了区（extent）的概念。对于16KB的页来说，<strong>连续的64个页就是一个区</strong>，也就是说一个区默认占用1MB的空间。无论是系统表空间还是独立表空间，都可以看作由若干个连续的区组成，每256个区被划分为一组。</p><p>其中extent0-extent255为一组，extent256-extent511为一组，依此类推，可以划分更多的组。</p><ul><li>FREE-空闲的区</li><li>FREE_FRAG-有剩余空闲页面的碎片区</li><li>FULL_FRAG-没有剩余空闲页面的碎片区</li><li>FSEG-附属某个段的区</li></ul><h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><p>段是一些零散页的页面以及一些完整的区的集合。</p><p>为了尽量使用顺序I&#x2F;O，提升磁盘的性能，作者不仅提出了区的概念，有提出了段的概念。上面说的256个区为一个组，其实这个组就是段。 每一个索引都对应2个段，一个叶子节点段，一个非叶子节点段。</p><h3 id="组"><a href="#组" class="headerlink" title="组"></a>组</h3><ul><li>每256个区分为一组</li><li>每个组的最开始的几个页面类型是固定的</li></ul><p>我们每向表中插入一条记录，本质上就是向该表的聚簇索引以及所有二级索引代表的B+树的节点中插入数据。而B+树每一层中的页都会形成一个双向链表，如果以页尾单位来分配存储空间，双向链表相邻的两个页之间的物理位置可能离的非常远。前面提到使用B+树来减少存储记录的扫描行数的过程是通过一些搜索条件到B+树的叶子节点中定位到第一条符合该条件的记录，然后沿着由该记录组成的单向链表以及数据页组成的双向链表一直向后扫描就可以了。</p><p>如果双向链表中相邻的两个页的物理位置不连续，对于传统的机械硬盘来说，需要重新定位磁头位置，也就是会产生随机I&#x2F;O，这样会影响磁盘的性能，所以我们应该尽量让页面链表中相邻的页的物理位置页尽量相邻，这样在扫描叶子节点中大量的记录时才可以使用顺序I&#x2F;O。</p><p>所以才引入了区的概念，一个区就是在物理位置上连续的64个页。在表中的数据量很大时，为某个索引分配空间的时候就不再按照页尾单位分配了。而是按照区为单位进行分配。甚至在表中的数据非常非常多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费，但是可以消除很多随机I&#x2F;O。</p><p>我们在使用B+树执行查询时，只是在扫描叶子节点的记录，如果不区分叶子节点和非叶子节点，而是统统把节点代表的页面放到申请到的区里，扫描效果就大打折扣了，所以这里对叶子节点和非叶子节点进行了区分，也就是说，叶子节点和非叶子节点都有自己独立的区。存放叶子节点的区的集合就是一个段（segment），存放非叶子节点的区的集合也是一个段。也就是说一个索引会生成两个段，一个叶子节点段，一个非叶子节点段。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql8.0的新特性-窗口函数</title>
      <link href="/2022/06/13/mysql8-0%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/"/>
      <url>/2022/06/13/mysql8-0%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h1><h4 id="1-1简介"><a href="#1-1简介" class="headerlink" title="1.1简介"></a>1.1简介</h4><p>窗口函数可以分为</p><p><strong>静态、动态</strong></p><p>静态窗口函数的窗口大小是固定的, 不会因为记录的不同而不同;</p><p>动态窗口函数的窗口大小会随着记录的不同而变化;优点：减少了重复繁琐的子查</p><h4 id="1-2语法结构"><a href="#1-2语法结构" class="headerlink" title="1.2语法结构"></a>1.2语法结构</h4><p>OVER 关键字指定窗口的范围,通常配合嵌套查询使用;</p><pre><code>函数 OVER ([PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]</code></pre><p><strong>窗口函数</strong> MySQL 8开始支持窗口函数。在之前的版本中已存在的大部分 聚合函数 在MySQL 8中也可以</p><p>作为窗口函数来使用。学过大数据的应该都知道这玩意跟hive中的窗口函数类似，简单来说窗口函数就是不进行</p><p>内部的聚合，而是将所聚合的字段的结果全部保留。刚开始理解可能有点困难，我们就根据案例来进行理解。</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220613181134589.png"></p><h4 id="2-案例需求：查询每种商品分类下，价格前3大的信息"><a href="#2-案例需求：查询每种商品分类下，价格前3大的信息" class="headerlink" title="2.案例需求：查询每种商品分类下，价格前3大的信息"></a><strong>2.案例需求：查询每种商品分类下，价格前3大的信息</strong></h4><p>数据准备</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> goods<span class="token punctuation">(</span> id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span> category_id <span class="token keyword">INT</span><span class="token punctuation">,</span> category <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">,</span> NAME <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span> price <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stock <span class="token keyword">INT</span><span class="token punctuation">,</span> upper_time <span class="token keyword">DATETIME</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> goods<span class="token punctuation">(</span>category_id<span class="token punctuation">,</span>category<span class="token punctuation">,</span>NAME<span class="token punctuation">,</span>price<span class="token punctuation">,</span>stock<span class="token punctuation">,</span>upper_time<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'女装/女士精品'</span><span class="token punctuation">,</span> <span class="token string">'T恤'</span><span class="token punctuation">,</span> <span class="token number">39.90</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'女装/女士精品'</span><span class="token punctuation">,</span> <span class="token string">'连衣裙'</span><span class="token punctuation">,</span> <span class="token number">79.90</span><span class="token punctuation">,</span> <span class="token number">2500</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'女装/女士精品'</span><span class="token punctuation">,</span> <span class="token string">'卫衣'</span><span class="token punctuation">,</span> <span class="token number">89.90</span><span class="token punctuation">,</span> <span class="token number">1500</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'女装/女士精品'</span><span class="token punctuation">,</span> <span class="token string">'牛仔裤'</span><span class="token punctuation">,</span> <span class="token number">89.90</span><span class="token punctuation">,</span> <span class="token number">3500</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'女装/女士精品'</span><span class="token punctuation">,</span> <span class="token string">'百褶裙'</span><span class="token punctuation">,</span> <span class="token number">29.90</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'女装/女士精品'</span><span class="token punctuation">,</span> <span class="token string">'呢绒外套'</span><span class="token punctuation">,</span> <span class="token number">399.90</span><span class="token punctuation">,</span> <span class="token number">1200</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'户外运动'</span><span class="token punctuation">,</span> <span class="token string">'自行车'</span><span class="token punctuation">,</span> <span class="token number">399.90</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'户外运动'</span><span class="token punctuation">,</span> <span class="token string">'山地自行车'</span><span class="token punctuation">,</span> <span class="token number">1399.90</span><span class="token punctuation">,</span> <span class="token number">2500</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'户外运动'</span><span class="token punctuation">,</span> <span class="token string">'登山杖'</span><span class="token punctuation">,</span> <span class="token number">59.90</span><span class="token punctuation">,</span> <span class="token number">1500</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'户外运动'</span><span class="token punctuation">,</span> <span class="token string">'骑行装备'</span><span class="token punctuation">,</span> <span class="token number">399.90</span><span class="token punctuation">,</span> <span class="token number">3500</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'户外运动'</span><span class="token punctuation">,</span> <span class="token string">'运动外套'</span><span class="token punctuation">,</span> <span class="token number">799.90</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'户外运动'</span><span class="token punctuation">,</span> <span class="token string">'滑板'</span><span class="token punctuation">,</span> <span class="token number">499.90</span><span class="token punctuation">,</span> <span class="token number">1200</span><span class="token punctuation">,</span> <span class="token string">'2020-11-10 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需求分析：需要根据表中category分类或者根据id分类,取每个分类中的价格前3的价格信息。考虑使用子查询或者窗口函数</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220613182339418.png"></p><p>普通的嵌套查询：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id<span class="token punctuation">,</span>category<span class="token punctuation">,</span>name<span class="token punctuation">,</span>price<span class="token punctuation">,</span>stock <span class="token keyword">from</span> goods <span class="token keyword">where</span> category_id <span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">order</span> <span class="token keyword">by</span> price <span class="token keyword">desc</span> <span class="token keyword">limit</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">as</span> t<span class="token keyword">union</span> <span class="token keyword">all</span> <span class="token keyword">select</span> <span class="token operator">*</span><span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id<span class="token punctuation">,</span>category<span class="token punctuation">,</span>name<span class="token punctuation">,</span>price<span class="token punctuation">,</span>stock <span class="token keyword">from</span> goods <span class="token keyword">where</span> category_id <span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">order</span> <span class="token keyword">by</span> price <span class="token keyword">desc</span> <span class="token keyword">limit</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">as</span> t1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>窗口函数查询：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> row_number<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">over</span> <span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> category_id <span class="token keyword">order</span> <span class="token keyword">by</span> price <span class="token keyword">desc</span> <span class="token punctuation">)</span> <span class="token keyword">as</span> row_id<span class="token punctuation">,</span> id<span class="token punctuation">,</span>category_id<span class="token punctuation">,</span>NAME<span class="token punctuation">,</span>price<span class="token punctuation">,</span>stock <span class="token keyword">from</span> goods <span class="token punctuation">)</span> k <span class="token keyword">where</span> row_id<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>相比之下，窗口函数的执行效率更高，且简洁易懂</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqoop的配置和使用</title>
      <link href="/2022/05/31/sqoop%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/05/31/sqoop%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="sqoop"><a href="#sqoop" class="headerlink" title="sqoop"></a>sqoop</h1><p>Apache Sqoop(TM) 是一种工具，设计用于在 <a href="http://hadoop.apache.org/">Apache Hadoop</a>和结构化数据存储（如关系数据库）之间高效传输批量数据。</p><p>Sqoop是一款开源的工具，主要用于在Hadoop(Hive)与传统的数据库(mysql、postgresql…)间进行数据的传递，可以将一个关系型数据库（例如 ： MySQL ,Oracle ,Postgres等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。</p><h2 id="一、sqoop的安装"><a href="#一、sqoop的安装" class="headerlink" title="一、sqoop的安装"></a>一、sqoop的安装</h2><p>下载地址:<a href="http://archive.apache.org/dist/sqoop/1.4.7/">http://archive.apache.org/dist/sqoop/1.4.7/</a></p><p>官方文档:<a href="https://sqoop.apache.org/docs/1.4.7/SqoopUserGuide.html#_introduction">https://sqoop.apache.org/docs/1.4.7/SqoopUserGuide.html#_introduction</a></p><p>1.4.7版本支持hadoop2.6及以上的版本 </p><p><strong>部署环境</strong>：hadoop3.0x mysql5.7.29</p><p><strong>需要的驱动</strong>：mysql-connector-java-8.0.23.jar （5.0x版本会报错）</p><h4 id="1-解压对应的包到指定目录"><a href="#1-解压对应的包到指定目录" class="headerlink" title="1.解压对应的包到指定目录"></a>1.解压对应的包到指定目录</h4><p>$ tar -zxvf sqoop-1.4.7.bin__hadoop-2.6.0.tar.gz -C &#x2F;opt&#x2F;module&#x2F;</p><h4 id="2-重命名配置文件"><a href="#2-重命名配置文件" class="headerlink" title="2.重命名配置文件"></a>2.重命名配置文件</h4><p>mv sqoop-env-template.sh sqoop-env.sh</p><h4 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3.修改配置文件"></a>3.修改配置文件</h4><p>export HADOOP_COMMON_HOME&#x3D;&#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3</p><p>export HADOOP_MAPRED_HOME&#x3D;&#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3</p><p>export HIVE_HOME&#x3D;&#x2F;opt&#x2F;module&#x2F;hive</p><p>export ZOOKEEPER_HOME&#x3D;&#x2F;opt&#x2F;module&#x2F;zookeeper-3.5.7</p><p>export ZOOCFGDIR&#x3D;&#x2F;opt&#x2F;module&#x2F;zookeeper-3.5.7</p><p>export HBASE_HOME&#x3D;&#x2F;opt&#x2F;module&#x2F;hbase-2.1.0</p><h4 id="4-拷贝jdbc驱动"><a href="#4-拷贝jdbc驱动" class="headerlink" title="4.拷贝jdbc驱动"></a>4.拷贝jdbc驱动</h4><p>cp mysql-connector-java-8.0.23.jar &#x2F;opt&#x2F;module&#x2F;sqoop&#x2F;lib&#x2F;</p><h4 id="5-验证Sqoop"><a href="#5-验证Sqoop" class="headerlink" title="5.验证Sqoop"></a>5.验证Sqoop</h4><p>bin&#x2F;sqoop help</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220531163501934.png"></p><h4 id="6-验证是否可以连接数据库"><a href="#6-验证是否可以连接数据库" class="headerlink" title="6.验证是否可以连接数据库"></a>6.验证是否可以连接数据库</h4><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220531163614604.png"></p><h4 id="7-配置HIVE相关参数（可选）"><a href="#7-配置HIVE相关参数（可选）" class="headerlink" title="7.配置HIVE相关参数（可选）"></a>7.配置HIVE相关参数（可选）</h4><p>修改环境变量  配置hive相关参数</p><p>#HIVE<br>export HIVE_HOME&#x3D;&#x2F;opt&#x2F;module&#x2F;hive<br>export PATH&#x3D;$PATH:$HIVE_HOME&#x2F;bin<br>export HIVE_CONF_DIR&#x3D;$HIVE_HOME&#x2F;conf</p><h2 id="二、Sqoop的快速上手"><a href="#二、Sqoop的快速上手" class="headerlink" title="二、Sqoop的快速上手"></a>二、Sqoop的快速上手</h2><p>参数介绍</p><p><strong>公用参数：数据库连接</strong></p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220531164514437.png"><strong>公用参数：import</strong></p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220531164541462.png"><strong>公用参数：export</strong></p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220531164607565.png"><strong>公用参数：hive</strong></p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220531164642597.png"></p><p><strong>其余参数：</strong></p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220531164713135.png"></p><h4 id="2-1全表导入"><a href="#2-1全表导入" class="headerlink" title="2.1全表导入"></a>2.1全表导入</h4><p>mysql密码要保证正确  集群已启动</p><pre class="line-numbers language-sql"><code class="language-sql"> bin<span class="token operator">/</span>sqoop <span class="token keyword">import</span> \<span class="token comment" spellcheck="true">--connect jdbc:mysql://hadoop102:3306/company \</span><span class="token comment" spellcheck="true">--username root \</span><span class="token comment" spellcheck="true">--password hadoop \</span><span class="token comment" spellcheck="true">--table staff \</span><span class="token comment" spellcheck="true">--target-dir /opt/spw \</span><span class="token comment" spellcheck="true">--num-mappers 1 \</span><span class="token comment" spellcheck="true">--fields-terminated-by "\t"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220531164129423.png"></p><h4 id="2-2查询导入"><a href="#2-2查询导入" class="headerlink" title="2.2查询导入"></a>2.2查询导入</h4><pre class="line-numbers language-sql"><code class="language-sql">bin<span class="token operator">/</span>sqoop <span class="token keyword">import</span> \<span class="token comment" spellcheck="true">--connect jdbc:mysql://hadoop102:3306/company \</span><span class="token comment" spellcheck="true">--username root \</span><span class="token comment" spellcheck="true">--password hadoop \</span><span class="token comment" spellcheck="true">--target-dir /user/company1 \</span><span class="token comment" spellcheck="true">--num-mappers 1 \</span><span class="token comment" spellcheck="true">--fields-terminated-by "\t" \</span><span class="token comment" spellcheck="true">--query "select name,sex from staff where id = 1 and \$CONDITIONS;" </span><span class="token punctuation">(</span>反斜杠 不用加表<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3导入指定的列"><a href="#2-3导入指定的列" class="headerlink" title="2.3导入指定的列"></a>2.3导入指定的列</h4><pre class="line-numbers language-sql"><code class="language-sql">bin<span class="token operator">/</span>sqoop <span class="token keyword">import</span> \<span class="token comment" spellcheck="true">--connect jdbc:mysql://hadoop102:3306/company \</span><span class="token comment" spellcheck="true">--username root \</span><span class="token comment" spellcheck="true">--password hadoop \</span><span class="token comment" spellcheck="true">--target-dir /user/company \</span><span class="token comment" spellcheck="true">--delete-target-dir \</span><span class="token comment" spellcheck="true">--num-mappers 1 \</span><span class="token comment" spellcheck="true">--fields-terminated-by "\t" \</span><span class="token comment" spellcheck="true">--columns id,sex \</span><span class="token comment" spellcheck="true">--table staff</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4导入至hive"><a href="#2-4导入至hive" class="headerlink" title="2.4导入至hive"></a>2.4导入至hive</h4><pre class="line-numbers language-sql"><code class="language-sql">bin<span class="token operator">/</span>sqoop <span class="token keyword">import</span> \<span class="token comment" spellcheck="true">--connect jdbc:mysql://hadoop102:3306/company \</span><span class="token comment" spellcheck="true">--username root \</span><span class="token comment" spellcheck="true">--password hadoop \</span><span class="token comment" spellcheck="true">--table staff \</span><span class="token comment" spellcheck="true">--num-mappers 1 \</span><span class="token comment" spellcheck="true">--hive-import \</span><span class="token comment" spellcheck="true">--fields-terminated-by "\t" \</span><span class="token comment" spellcheck="true">--hive-overwrite \</span><span class="token comment" spellcheck="true">--hive-database itheima \</span><span class="token comment" spellcheck="true">--hive-table staff_hive</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 大数据生态圈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题-回溯法</title>
      <link href="/2022/05/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
      <url>/2022/05/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="0-1背包问题是子集选取问题。"><a href="#0-1背包问题是子集选取问题。" class="headerlink" title="0-1背包问题是子集选取问题。"></a><strong>0-1背包问题是子集选取问题。</strong></h3><p>一般情况下，0-1背包问题是NP完全问题。0-1背包问题的解空间可以用子集树表示。解0-1背包问题的回溯法与解装载问题的回溯法十分相似。在搜索解空间树时，只要其左儿子节点是一个可行的节点，搜索就进入其左子树;而当右子树中有可能包含最优解时才进入右子树搜索，否则将右子树剪去。设r是当前剩余物品价值总和；cp是当前价值；bestp是当前最优价值。当cp+r&lt;&#x3D;bestp时，可剪去右子树。计算右子树中解的上界的更好的办法是，将剩余物品依其单位重量价值排序，然后依次装入物品，直至装不下时，再装入该物品的一部分而装满背包，由此得到的价值是右子树的上界。  </p><p>0–1背包的一个实例：n&#x3D;5, c&#x3D;10, w&#x3D;{2, 2, 6, 5, 4}, v(p)&#x3D;{6, 3, 5, 4, 6}的0-1背包问题的最优解和最优值。&lt;w为重量，v为价值量，n为物品个数，c为背包容量&gt;</p><h2 id="回溯法基本思想"><a href="#回溯法基本思想" class="headerlink" title="回溯法基本思想"></a>回溯法基本思想</h2><p>确定了解空间的组织结构后，【回溯法从开始节点（根节点）出发，以深度优先搜索整个解空间。这个开始的节点为活节点，同时成为当前的扩展节点。在当前的扩展节点处，搜素向纵深方向移至一个新节点。这个新节点就成为新的活节点，并成为当前扩展节点。如果当前节点处不能再向纵深方向移动，则当前扩展节点为死节点。此时，应往回移动到最近的一个活节点处。回溯法以这种方式递归的在解空间中搜素，直至找到所有符合要求的解或解空间中已无活节点。】（即深度优先搜素）</p><p>回溯法的典型实例——0-1背包问题<br>为了方便理解回溯法运算的流程，以0-1背包问题为例进行分析；</p><p>问题：<br>给定n种物品和一背包。物品i的重量是wi，其价值为vi，背包的容量为C。问:应如何选择装入背包的物品，使得装入背包中物品的总价值最大?</p><p>首先考虑贪心法，为了得到最大的价值，将所有物品按照单位价值（Vi&#x2F;Wi）降序排列（例如采用希尔排序，时间复杂度为），在放入物品时优先考虑单位价值更高的物品。在搜索到空间树中的某个结点P时，已经确定了P及其前面的结点取值，进而判断从P继续扩展下去是否获得更大的价值，如果不能，该结点无需扩展，可以进行回溯了。下面的函数结合了贪心法判断从某一点扩展开去可能获得的最大的价值。</p><pre><code>int Bound(int *Values, int *Weights,int n,int maxWeight,int num,int current_Weight,int current_profit)&#123;    int i = num + 1;    for (; i &lt; n; i++)    &#123;        if (current_Weight + Weights[i] &lt; maxWeight)        &#123;            current_profit += Values[i];            current_Weight += Weights[i];        &#125;        else        &#123;            current_profit += (Values[i] / Weights[i])*(maxWeight - current_Weight);            current_Weight = maxWeight;            return current_profit;        &#125;    &#125;     return current_profit;&#125;int *Knapsack(int *Values,int *Weights,int n,int maxWeight)&#123;    int *X = new int[n];    int *Y = new int[n];    int Weight = 0;    int Profit = 0;     int current_weight=0, current_profit=0;     int i = 0;    while (1)    &#123;        while (i&lt;n&amp;&amp;t_weight + Weights[i] &lt;= maxWeight)        &#123;            X[i] = SELECT;            current_profit += Values[i];            current_weight += Weights[i];            i++;        &#125;        //---上面的循环中，如果是由于i=n结束的，那么说明深度搜索已经搜索到了最底层        if (i &gt;= n)        &#123;            Weight = current_weight;            Profit = current_profit;            i = n;            for (int j = 0; j &lt; n; j++)                 //------------把数组X挪给Y；            &#123;                Y[j] = X[j];            &#125;        &#125;        //否则就是由于第i个物品在当前情况下无法放入背包        else        &#123;            X[i] = UNSELECT;        &#125;                 while (Bound(Values, Weights, n, maxWeight, i, current_weight, current_profit) &lt;= Profit)//如果不可能获得更大的价值，那么这个点就不需要进行扩展了；        &#123;            while (i != 0 &amp;&amp; X[i] != SELECT)//进行回溯            &#123;                i--;            &#125;            if (i == 0)   //当回溯到i=0时候，所有情况都遍历了            &#123;                return Y;            &#125;             X[i] = UNSELECT;            current_profit -= Values[i];            current_weight -= Weights[i];        &#125;        i++;    &#125;    &#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongoDB的安装和部署</title>
      <link href="/2022/05/11/mongoDB%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%83%A8%E7%BD%B2/"/>
      <url>/2022/05/11/mongoDB%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB数据库安装及配置环境"><a href="#MongoDB数据库安装及配置环境" class="headerlink" title="MongoDB数据库安装及配置环境"></a><a href="https://so.csdn.net/so/search?q=MongoDB&spm=1001.2101.3001.7020">MongoDB</a>数据库安装及配置环境</h1><h2 id="一-MongoDB的下载与安装"><a href="#一-MongoDB的下载与安装" class="headerlink" title="一. MongoDB的下载与安装"></a>一. MongoDB的下载与安装</h2><h2 id="windows端"><a href="#windows端" class="headerlink" title="windows端"></a>windows端</h2><h3 id="1-1-下载地址"><a href="#1-1-下载地址" class="headerlink" title="1.1 下载地址"></a>1.1 下载地址</h3><p><a href="https://www.mongodb.com/download-center/community?jmp=docs">https://www.mongodb.com/download-center/community?jmp=docs</a></p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220512172251154.png"></p><p>MongoDB 有两个服务器版本：<em>社区</em>版和 <em>企业版</em>。</p><h4 id="若想选择其他版本-可点击-Current-releases-amp-packages-自行下载"><a href="#若想选择其他版本-可点击-Current-releases-amp-packages-自行下载" class="headerlink" title="若想选择其他版本 可点击  Current releases &amp; packages 自行下载"></a>若想选择其他版本 可点击  Current releases &amp; packages 自行下载</h4><h4 id="打开-MongoDB-Shell-下载页面。"><a href="#打开-MongoDB-Shell-下载页面。" class="headerlink" title="打开 MongoDB Shell 下载页面。"></a>打开 MongoDB Shell 下载页面。</h4><h4 id="下载mongosh适用于您的操作系统的安装存档。"><a href="#下载mongosh适用于您的操作系统的安装存档。" class="headerlink" title="下载mongosh适用于您的操作系统的安装存档。"></a>下载<code>mongosh</code>适用于您的操作系统的安装存档。</h4><p>安装 “install mongoDB compass” 勾选（当然你也可以选择安装它，可能需要更久的安装时间），MongoDB Compass 是一个图形界面管理工具</p><h4 id="从下载的存档中提取文件"><a href="#从下载的存档中提取文件" class="headerlink" title="从下载的存档中提取文件"></a>从下载的存档中提取文件</h4><h4 id="将mongosh二进制文件添加到您的PATH环境变量中"><a href="#将mongosh二进制文件添加到您的PATH环境变量中" class="headerlink" title="将mongosh二进制文件添加到您的PATH环境变量中"></a>将<code>mongosh</code>二进制文件添加到您的<code>PATH</code>环境变量中</h4><p>确保提取的MongoDB Shell二进制文件位于文件系统中的所需位置，然后将该位置添加到<code>PATH</code> 环境变量中。</p><p>要将MongoDB Shell二进制文件的位置添加到您的 <code>PATH</code>环境变量中：</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511202542447.png"></p><h2 id="二、连接到远程服务器"><a href="#二、连接到远程服务器" class="headerlink" title="二、连接到远程服务器"></a>二、连接到远程服务器</h2><p>要使用MongoDB Shell ，您必须具有要连接的 MongoDB 部署。</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511203240401.png"></p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511203412464.png"></p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511203520850.png"></p><p>托管在云服务上可能要花费3-5min</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511203714885.png"></p><p>可以选择托管在云平台上  但只有512M的集群  如果要更多的存储空间 则要付费</p><p>默认情况下，MongoDB Atlas集群不需要能够启动与您的应用程序环境的连接。如果您希望启用具有 <a href="https://www.mongodb.com/docs/atlas/security-ldaps/#std-label-ldaps-authentication-authorization">LDAP 身份验证和授权</a>的Atlas集群，您必须允许从Atlas集群直接访问您的安全LDAP的网络访问。只要公共DNS主机名指向Atlas集群可以访问的 IP，您就可以允许使用公共或私有 IP 访问您的LDAP 。</p><p>简单来说就是通过ip来访问云服务</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511205759816.png"></p><p>连接说明中点第一个 然后就可以通过mongoDB compass连接上</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511205900562.png"></p><p>然后你会发现有三个集群节点可用 这也体现了分布式的特点</p><p>打开cmd</p><p>查看版本:mongod –version </p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511205950224.png"></p><p>进入shell :mongo, 默认端口为27017</p><p>mongod –dbpath 任意路径 默认就在根目录data下</p><p><strong>DataGrip</strong> 是JetBrains公司开发的数据库管理客户端工具 支持多种数据库连接 </p><p>特别棒的功能就是代码的智能提示 简直不要太好  可自行前往官网下载 </p><p>点击 new -&gt; data source mongodb 然后复制原本在compass上的url 点击test </p><p>如果没问题的话就可以连接上了</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511211000869.png"></p><p>show dbs</p><p>这两个数据库都是系统自带的，不建议更改，可以自己创个数据库 然后添加数据，这里就不做过多说明。</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220511211206249.png"></p><p>到此为止，win端的mongodb的安装已经顺利成功</p><h2 id="Linux端的安装和数据迁移"><a href="#Linux端的安装和数据迁移" class="headerlink" title="Linux端的安装和数据迁移"></a>Linux端的安装和数据迁移</h2><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/100.png"></p><p>选择centos7版本的进行解压安装</p><p>1.新建文件夹 mkdir &#x2F;data  mkdir -p &#x2F;data&#x2F;db </p><p>2.解压:tar -zxvf xx -C   &#x2F;data</p><p>配置环境变量</p><pre class="line-numbers language-js"><code class="language-js">vim <span class="token operator">/</span>etc<span class="token operator">/</span>profile<span class="token comment" spellcheck="true">//拉到最下方</span><span class="token keyword">export</span> MONGODB_HOME <span class="token operator">=</span><span class="token operator">/</span>data<span class="token operator">/</span>mongodb<span class="token operator">/</span>bin<span class="token keyword">export</span> $PATH<span class="token punctuation">:</span>$MONGODB_HOME<span class="token operator">/</span>bin<span class="token comment" spellcheck="true">//更新环境变量</span>source <span class="token operator">/</span>etc<span class="token operator">/</span>profile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入mongo 直接报错 可以看见版本号但是 进不去mongo shell</p><p>报错信息如下：</p><p>Error: couldn’t connect to server 127.0.0.1:27017, connection attempt failed: SocketException: Error connecting to 127.0.0.1:27017 :: caused by :: Connection refused :</p><p>这时候我们将一台主机当做服务端  另一台当做客户端     通过客户端连接上服务端这样就可以正常访问   这里的本地模式并不是连接到windows上的本地  是linux的本地</p><p>bin&#x2F;mongod</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/101.png"></p><p>在另外一台输入</p><p>mongo </p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/102.png"></p><p>连接成功！ </p><p>当然在linux也可以连接之前在云端部署的MONGDB集群  具体操作如下</p><p>我们在官网登入自己的账户 点击command Line Tools</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/104.png"></p><p>点进去 然后选择 i have the MongoDB shell installed</p><p>然后复制一段代码 将mongosh 改为 mongo即可</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/105.png"></p><p>出现以下代码则说明连接成功</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/106.png"></p><p><strong>Q:第二次连接远程的时候连接不上 我们登入官网</strong> </p><p>点击NetWork Access 选择edit 将里面的连接方式改成运行任何地方的连接</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/107.png"></p><h3 id="如何导入数据"><a href="#如何导入数据" class="headerlink" title="如何导入数据"></a>如何导入数据</h3><p>首先要确保有mongorestore命令 如果没有的话则需要去官网下载工具包</p><p>mongodb-database-tools-rhel70-x86_64-100.5.2</p><p>解压到当前的bin目录下</p><p>mongorestore 如果可以Tab出来就代表没什么问题</p><p>mongorestore dump </p><p>即可导入成功</p><p>我们再重新登入客户端 </p><p>show dbs 就可以看见导入的数据库了 </p>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>集(set)和映射(Map)</title>
      <link href="/2022/04/25/%E9%9B%86set%E5%92%8C%E6%98%A0%E5%B0%84Map/"/>
      <url>/2022/04/25/%E9%9B%86set%E5%92%8C%E6%98%A0%E5%B0%84Map/</url>
      
        <content type="html"><![CDATA[<p>默认情况下 你使用的set or map 都是不可变的对象   如果可变需要提前声明</p><p>以下是创建可变的集合</p><pre class="line-numbers language-scala"><code class="language-scala"><span class="token keyword">package</span> com<span class="token punctuation">.</span>heima<span class="token punctuation">.</span>arrp<span class="token keyword">import</span> scala<span class="token punctuation">.</span>collection<span class="token punctuation">.</span>mutable<span class="token comment" spellcheck="true">/** * @author lyc * @date 2022/4/25 11:30   * @version V1.0.0 */</span><span class="token keyword">object</span> Map_prc <span class="token punctuation">{</span>  <span class="token keyword">def</span> map<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> map01 <span class="token operator">=</span> mutable<span class="token punctuation">.</span>Map<span class="token punctuation">(</span><span class="token string">"aa"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> set01 <span class="token operator">=</span> mutable<span class="token punctuation">.</span>Set<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="set集合的基本使用"><a href="#set集合的基本使用" class="headerlink" title="set集合的基本使用"></a>set集合的基本使用</h2><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220425113431055.png"></p><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h3><ol><li><code>var 变量=Set()</code> （创建空的Set集合）</li><li><code>var 变量=Set[类型]()</code>  &#x2F;&#x2F;写死后里面的元素只能是set规定的数据类型</li></ol><p>scala内部能简化的全部帮你简化了</p><h3 id="2-差集和补集"><a href="#2-差集和补集" class="headerlink" title="2.差集和补集"></a>2.差集和补集</h3><ol><li>&amp;返回两个集合的交集</li><li>&amp;~返回两个集合的差集</li><li>++合并两个集合</li><li>diff比较两个集合的差集</li></ol><h3 id="3-遍历"><a href="#3-遍历" class="headerlink" title="3.遍历"></a>3.遍历</h3><ul><li>通过for（i &lt;- x )</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis概述</title>
      <link href="/2022/04/15/redis%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/04/15/redis%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Redis是用C语言开发的一个开源的高性能基于内存运行的键值对NoSQL数据库</p><p>Redis（Remote Dictionary Server 远程字段服务）是一个开源的使用ANSI C语言编写、支持网络、科技与<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>亦可持久化的日志型、key-value数据库，并提供多种语言的API。</p><p>(1) 支持数据的持久化，可以将数据保存在磁盘中，重启之后可以再次加载到内存中使用<br>(2) 支持多种数据类型，除了KV类型的数据，还支持list、set、<a href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a>等数据结构<br>(3) 支持master-slave模式的数据备份</p><h2 id="二、Redis应用场景"><a href="#二、Redis应用场景" class="headerlink" title="二、Redis应用场景"></a>二、Redis应用场景</h2><ol><li>热点数据加速查询(主要场景)，如热点商品、热点信息等访问量较高的数据</li><li>即时信息查询，如公交到站信息、在线人数信息等</li><li>时效性信息控制，如验证码控制、投票控制等</li><li>分布式数据共享，如分布式集群架构中的session分离消息队列</li></ol><h3 id="1-NoSQL技术"><a href="#1-NoSQL技术" class="headerlink" title="1.NoSQL技术"></a>1.NoSQL技术</h3><p>为了克服上述问题，java web项目通常会引入NoSQL技术，这是一种基于内存的数据库，并且提供一定的持久化功能。</p><p>Redis和MongoDB是当前使用最广泛的NoSQL， 而就Redis技术而言，它的性能十分优越，可以支持每秒十几万的读写操作，其性能远超数据库，并且还支持集群、。分布式、主从同步等配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还支持一定的事务能力，这保证了高并发的场景下数据的安全和一致性。</p><h3 id="2-高并发和快速原因"><a href="#2-高并发和快速原因" class="headerlink" title="2.高并发和快速原因"></a>2.高并发和快速原因</h3><p>Redis是基于内存的，内存的读写速度非常快；<br>Redis是单线程的，省去了很多上下文切换线程的时间；<br>Redis使用多路复用技术，可以处理并发的连接。非IO内部实现采用epoll，采用了epoll自己实现的简单的事件框架。epoll的读写、关闭、连接都转化为事件，然后利用epoll的多路复用特性，绝不在IO上浪费一点时间。</p><h3 id="3-单线程的优劣势"><a href="#3-单线程的优劣势" class="headerlink" title="3.单线程的优劣势"></a>3.单线程的优劣势</h3><p>1、优势</p><p>代码更清晰，处理逻辑更简单</p><p>不用考虑各种锁的问题，不存在加锁和释放锁的操作，没有因为可能出现死锁而导致的性能消耗</p><p>不存在多线程切换而消耗CPU</p><p>2、劣势</p><p>无法发挥多核CPU性能优势，不过可以通过单击开多个Redis实例来完善。</p><h3 id="4-Redis高并发总结"><a href="#4-Redis高并发总结" class="headerlink" title="4.Redis高并发总结"></a>4.Redis高并发总结</h3><p>1、Redis是纯内存数据库，一般都是简单存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快；</p><p>2、Redis使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成事件，减少了线程切换时上下文切换和竞争。</p><p>3、Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。</p><p>4、Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如跳表，使用有序的数据结构加快读写的速度。</p><p>5、Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</p><h2 id="三、Redis基础知识"><a href="#三、Redis基础知识" class="headerlink" title="三、Redis基础知识"></a>三、Redis基础知识</h2><p>Redis采用单线程机制进行工作</p><p>Redis默认拥有16个数据库，数据库编号从0开始，默认使用0号数据库</p><p>使用select 数据库编号 可以切换使用的数据库</p><p>dbsize 命令查看当前数据库key的数量</p><p>keys * 命令查看当前数据库所有的key</p><p>flushdb 命令清空当前数据库</p><p>flushall 命令清空所有数据库</p><p>Redis中所有数据库使用同一个密码，默认没有密码，Redis认为安全层面应该由Linux来保证</p><p>Redis中所有索引都是从0开始</p><p>Redis默认端口是6379</p>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文数</title>
      <link href="/2022/04/10/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
      <url>/2022/04/10/%E5%9B%9E%E6%96%87%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>例如，121 是回文，而 123 不是。</p><pre><code>输入：x = 121输出：true</code></pre><pre><code>输入：x = -121输出：false解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</code></pre><p>解法一：</p><p>利用StringBuffer </p><p>思路 ： 负数肯定不是回文数 直接返回false </p><p>创建 StringBuff对象 进行比较 </p><p>通过String.valueof 方法 转成一个字符串进行 比较 </p><pre class="line-numbers language-java"><code class="language-java">     <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        StringBuffer s<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解法二：<br>数学（推荐）</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>num<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            cur <span class="token operator">=</span> cur<span class="token operator">*</span><span class="token number">10</span> <span class="token operator">+</span>num<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>            num <span class="token operator">/=</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cur<span class="token operator">==</span>x<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scala的伴生对象</title>
      <link href="/2022/04/06/scala%E7%9A%84%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1/"/>
      <url>/2022/04/06/scala%E7%9A%84%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h1><p>​    一个class和object具有同样的名字。这个object称为<strong>伴生对象</strong>，这个class称为<strong>伴生类</strong></p><ul><li>伴生对象必须要和伴生类一样的名字；</li><li>伴生对象和伴生类在同一个scala源文件中；</li><li>伴生对象和伴生类可以互相访问<strong>private</strong>属性。</li></ul><p>作用 ：让伴生类更好访问到伴生对象的私有属性和方法</p><p>一旦私有 main方法直接不能调  严格的权限控制</p><h2 id="1-单例对象-object"><a href="#1-单例对象-object" class="headerlink" title="1.单例对象(object)"></a>1.单例对象(object)</h2><p>scala中是没有static关键字的，要想定义类似于Java中的static变量、static方法，就要使用到scala中的单例对象了, 也就是object。</p><h2 id="2-定义单例对象"><a href="#2-定义单例对象" class="headerlink" title="2.定义单例对象"></a>2.定义单例对象</h2><p>object 单例对象名{ } &#x2F;&#x2F; 定义一个单例对象 也可以解释为什么main方法是静态的了</p><p>网上说的什么伴生对像之间可以互相访问跟情侣一样同生死 只有伴生类能够访问伴生对象中的私有属性和对象  我尝试了 一下 明明只有类可以访问到 对象访问不到类的东西。</p><p>但后来慢慢发现我放了一个错误</p><p>伴生对象不实例化类的对象，怎么访问伴生类中定义的私有属性？不实例化 伴生对象是类的一个傀儡</p><p>就是必须要在伴生对象的中定义个方法去实例化它</p><h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><p>class Person{</p><p>}</p><p> var op ：person &#x3D;  new Person（）实例化后才能调用</p><p>但我们一般都是在main方法中实例化的 （java的思维） 真的sorry</p><h2 id="3-案例1-2-3"><a href="#3-案例1-2-3" class="headerlink" title="3.案例1 2 3"></a>3.案例1 2 3</h2><p>ps：可以试着运行下</p><p>可以尝试着把伴生对象理解 成用static 修饰的类</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>atiguigu<span class="token punctuation">.</span>prc<span class="token comment" spellcheck="true">/** * @author lyc * @date 2022/4/10 20:50   * @version V1.0.0 */</span>object Logger <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//单例对象 不能带参数 不能实例化 没有机会向单例对象传参</span>  <span class="token comment" spellcheck="true">//在第一次调用的时候进行 初始化</span>  <span class="token comment" spellcheck="true">//静态方法 一加上private就没办法访问了</span>    def <span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token operator">:</span>String<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token string">"info:$msg"</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>  def <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span><span class="token punctuation">{</span>    Logger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"林杰"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//为什么要有 object定义main方法 因为static 被scala完全给隔绝了</span><span class="token comment" spellcheck="true">//scala是高度化的面向对象语言 不允许静态和非静态属性和方法 糅杂在一起 所以就用一个</span><span class="token comment" spellcheck="true">//object 单例对象</span><span class="token comment" spellcheck="true">//程序入口</span>object LoggerTest<span class="token punctuation">{</span>  def <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span>String<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span>    Logger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"林杰1"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//类名.方法名</span>    val obj <span class="token operator">:</span>Test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    obj<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>atiguigu<span class="token punctuation">.</span>prc<span class="token comment" spellcheck="true">/** * @author lyc * @date 2022/4/10 20:56   * @version V1.0.0 */</span><span class="token keyword">class</span> <span class="token class-name">AccountInfo</span> <span class="token punctuation">{</span>  var id <span class="token operator">=</span><span class="token number">0</span>  id <span class="token operator">=</span> AccountInfo<span class="token punctuation">.</span><span class="token function">newUniqueNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//之间的特点 互相访问对方的私有属性和方法</span><span class="token comment" spellcheck="true">//称为类的伴生对象</span>object AccountInfo<span class="token punctuation">{</span>  <span class="token keyword">private</span> var last_num <span class="token operator">=</span><span class="token number">0</span>  <span class="token keyword">private</span>  def <span class="token function">newUniqueNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">{</span>    last_num <span class="token operator">+=</span><span class="token number">2</span>    last_num  <span class="token punctuation">}</span><span class="token punctuation">}</span>object  compannionTest<span class="token punctuation">{</span>  def <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span>String<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span>    var obj <span class="token operator">:</span>AccountInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AccountInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>id<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>atiguigu<span class="token punctuation">.</span>prc<span class="token comment" spellcheck="true">/** * @author lyc * @date 2022/4/10 21:15   * @version V1.0.0 */</span><span class="token comment" spellcheck="true">//类自带无参的构造器 开发者把这些觉得重复的东西全部省略了</span><span class="token comment" spellcheck="true">//set get 底层封装起来了</span><span class="token comment" spellcheck="true">// 有参构造函数 直接 给class（）java中是不允许的！！</span><span class="token comment" spellcheck="true">//scala中的构造器 有两种</span><span class="token comment" spellcheck="true">// 主构造函数 和 辅助构造函数</span><span class="token comment" spellcheck="true">// 记住一点 辅助构造函数是在 类中的  定义必须以this开头 以下是具体例子</span><span class="token comment" spellcheck="true">// 调用辅助构造函数 根据传参来区分是第几个辅助构造函数</span>object Constructorc <span class="token punctuation">{</span>  def <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span>String<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span>    val obj <span class="token operator">:</span>Const <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Const</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>    var obj1 <span class="token operator">:</span>Confuse <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Confuse</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>a<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Const</span><span class="token punctuation">{</span>  var a <span class="token operator">=</span> <span class="token number">10</span>  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1调用无参的构造函数"</span><span class="token punctuation">)</span>  <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  def <span class="token keyword">this</span><span class="token punctuation">(</span>a1<span class="token operator">:</span>Int<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//调用主构造函数 必须的一步！！！</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2调用有参的构造函数"</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a1  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//有参的构造函数</span><span class="token comment" spellcheck="true">//如果用 var就是放在类里面的一个属性 不带则为参数 注意一下</span><span class="token comment" spellcheck="true">//class Confuse{</span><span class="token comment" spellcheck="true">// int a</span><span class="token keyword">class</span> <span class="token class-name">Confuse</span><span class="token punctuation">(</span>a <span class="token operator">:</span>Int<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2022/04/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/04/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><pre><code>输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4</code></pre><pre class="line-numbers language-java"><code class="language-java">   <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span><span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// // 当left==right，区间[left, right]依然有效，所以用 &lt;=</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left<span class="token operator">+</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 防止溢出 等同于(left + right)/2</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//target 在左区间，所以[left, mid - 1]</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>                left <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// target 在右区间，所以[mid + 1, right]</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//数组中找到目标值，直接返回下标</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组去重</title>
      <link href="/2022/04/05/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
      <url>/2022/04/05/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<p>数组去重也是比经典的一个算法 这里演示了三种不同的数组去重操作</p><p>1.利用Hashset本身无序的特性进行去重</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test04</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span>arr<span class="token punctuation">)</span><span class="token punctuation">{</span>            set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.利用ArrayList进行去重</p><pre><code>    public void remove() &#123;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        int[] arr = &#123;1, 2, 3, 4, 5, 6, 2, 3, 4&#125;;        for (int i :arr)&#123;            if (!list.contains(i))&#123;                list.add(i);            &#125;        &#125;        System.out.println(list);    &#125;&#125;</code></pre><p>3.双重for循环</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> Arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>x<span class="token operator">&lt;</span>temp<span class="token punctuation">.</span>length<span class="token punctuation">;</span>x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">boolean</span> flag<span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> y<span class="token operator">=</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>y<span class="token operator">&lt;</span>temp<span class="token punctuation">.</span>length<span class="token punctuation">;</span>y<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">==</span>temp<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    flag<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span>               Arr<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>temp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除LinkedList中的重复项</title>
      <link href="/2022/04/02/%E5%88%A0%E9%99%A4LinkedList%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/2022/04/02/%E5%88%A0%E9%99%A4LinkedList%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="CHARACTER"><a href="#CHARACTER" class="headerlink" title="CHARACTER"></a>CHARACTER</h1><p>Q:LinkedList 去除重复元素</p><p>阿牛最近在学习 <code>LinkedList</code> 的知识，现在他想要测试一下自己究竟学会了多少，他成功的发现了自己并没有掌握相关知识点，现在需要你帮助他完成这道题目，给定六个字符串，将这些字符串存放在 <code>LinkedList</code> 中，然后将 <code>LinkedList</code> 中重复的元素删除，最后将 <code>LinkedList</code> 中所有元素用迭代器方式打印在标准输出流（控制台）中，请你帮助她完成这道题目。</p><p>挺简单的一道题 代码如下 </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Iterator<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>LinkedList<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//解法一</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Permanent</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> LinkedList<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">Weighting</span><span class="token punctuation">(</span>LinkedList<span class="token operator">&lt;</span>String<span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LinkedList<span class="token operator">&lt;</span>String<span class="token operator">></span>linkedList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> iterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            String str <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>linkedList<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                linkedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> linkedList<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//解法二</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Permanent</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> LinkedList<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">Weighting</span><span class="token punctuation">(</span>LinkedList<span class="token operator">&lt;</span>String<span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            HashSet set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Iterator iter <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                String str <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    iter<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> list<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala中的Map集合</title>
      <link href="/2022/03/31/Scala%E4%B8%AD%E7%9A%84Map%E9%9B%86%E5%90%88/"/>
      <url>/2022/03/31/Scala%E4%B8%AD%E7%9A%84Map%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="不可变MAP"><a href="#不可变MAP" class="headerlink" title="不可变MAP"></a>不可变MAP</h1><p>Map(映射)是一种可迭代的键值对（key&#x2F;value）结构。<br>所有的值都可以通过键来获取。<br>Map 中的键都是唯一的。<br>Map 也叫哈希表（Hash tables）。<br>Map 有两种类型，可变与不可变，区别在于可变对象可以修改它，而不可变对象不可以。<br>默认情况下 Scala 使用不可变 Map。如果你需要使用可变集合，你需要显式的引入 import scala.collection.mutable.Map 类<br>在Scala中你可以同时使用可变与不可变 Map,不可变的直接使用 Map,可变的使用 mutable.Map.以下实例演示了不可变 Map 的应用：</p><pre class="line-numbers language-java"><code class="language-java">def <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span>String<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span> val p<span class="token operator">:</span> Map<span class="token punctuation">[</span>String<span class="token punctuation">,</span> Int<span class="token punctuation">]</span> <span class="token operator">=</span> Map<span class="token punctuation">[</span>String<span class="token punctuation">,</span> Int<span class="token punctuation">]</span><span class="token punctuation">(</span>   <span class="token string">"CK"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">15</span><span class="token punctuation">,</span>   <span class="token string">"PH"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">25</span><span class="token punctuation">,</span>   <span class="token string">"PW"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">35</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两种获取值的方式</p><pre class="line-numbers language-java"><code class="language-java">   val values<span class="token operator">:</span> Option<span class="token punctuation">[</span>Int<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"PH"</span><span class="token punctuation">)</span>   <span class="token function">println</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span>get<span class="token punctuation">)</span>          val age <span class="token operator">:</span>Int  <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span><span class="token string">"PW"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">println</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span>         <span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>keys<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//返回所有的key;</span>  <span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>values<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//返回所有的value;</span>  <span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>isEmpty<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//当map为空时,返回true;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="可变MAP"><a href="#可变MAP" class="headerlink" title="可变MAP"></a>可变MAP</h1><p>​    </p><pre><code>  def main(args: Array[String]): Unit = &#123;    val personalMap  = scala.collection.mutable.Map[String,Int](      &quot;kw&quot; -&gt;7,      &quot;dk&quot;-&gt;20    )    for(kb&lt;-personalMap)&#123;      val key =kb._1;      val value = kb._2      println(key+value)    &#125;    personalMap.foreach(x=&gt;println(x))  &#125;</code></pre><pre class="line-numbers language-java"><code class="language-java">def <span class="token function">map3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//不可变Map+var关键词修饰例子</span>  var a<span class="token operator">:</span>scala<span class="token punctuation">.</span>collection<span class="token punctuation">.</span>mutable<span class="token punctuation">.</span>Map<span class="token punctuation">[</span>String<span class="token punctuation">,</span>Int<span class="token punctuation">]</span><span class="token operator">=</span>scala<span class="token punctuation">.</span>collection<span class="token punctuation">.</span>mutable<span class="token punctuation">.</span><span class="token function">Map</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"k2"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//初始化构造函数</span>  a <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token string">"k3"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//添加元素</span>  a <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token string">"k4"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//添加元素</span>  a <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">100</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//已经存在添加元素会覆盖</span>  a <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">100</span><span class="token punctuation">,</span><span class="token string">"k9"</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">9</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//添加多个元素</span>  a <span class="token operator">-=</span> <span class="token punctuation">(</span><span class="token string">"k2"</span><span class="token punctuation">,</span><span class="token string">"k1"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//删除元素</span>  a <span class="token operator">++</span><span class="token operator">=</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token string">"CA"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token string">"CO"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//追加集合</span>  a <span class="token operator">--</span><span class="token operator">=</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token string">"AL"</span><span class="token punctuation">,</span> <span class="token string">"AZ"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//删除集合</span>   a<span class="token punctuation">.</span><span class="token function">retain</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> k<span class="token operator">==</span><span class="token string">"k1"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//只保留等于k1元素，其他的删除</span>  a<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"put1"</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//put</span>  a<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"k2"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//remove</span>  a<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//清空</span>  <span class="token function">a</span><span class="token punctuation">(</span><span class="token string">"k3"</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">100</span><span class="token comment" spellcheck="true">//支持</span>   <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"k6"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//是否包含某元素</span>  <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//打印大小</span>  <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//根据key读取元素，不存在就替换成默认值</span>  a<span class="token punctuation">.</span>foreach<span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span>i<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//遍历打印1</span>  <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>k<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">-</span>a <span class="token punctuation">)</span> <span class="token function">println</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>v<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//遍历打印2</span>  <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>isEmpty<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//判断是否为空</span>  a<span class="token punctuation">.</span>keys<span class="token punctuation">.</span><span class="token function">foreach</span><span class="token punctuation">(</span>println<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//只打印key</span>  a<span class="token punctuation">.</span>values<span class="token punctuation">.</span><span class="token function">foreach</span><span class="token punctuation">(</span>println<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//只打印value</span>  a<span class="token operator">=</span>scala<span class="token punctuation">.</span>collection<span class="token punctuation">.</span>mutable<span class="token punctuation">.</span><span class="token function">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//引用能变</span>  <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>size<span class="token punctuation">)</span>  a<span class="token punctuation">.</span>toSeq<span class="token punctuation">.</span><span class="token function">sortBy</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>_1<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//排序 key</span>  a<span class="token punctuation">.</span>toSeq<span class="token punctuation">.</span><span class="token function">sortBy</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>_2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//排序 value</span>  a<span class="token punctuation">.</span>toSeq<span class="token punctuation">.</span><span class="token function">sortWith</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>_1<span class="token operator">></span>_<span class="token punctuation">.</span>_1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//降序排序 key</span>  a<span class="token punctuation">.</span>toSeq<span class="token punctuation">.</span><span class="token function">sortWith</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>_2<span class="token operator">></span>_<span class="token punctuation">.</span>_2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//降序排序 value</span>        <span class="token comment" spellcheck="true">//下面自定义按英文字母或数字排序</span>  implicit  val KeyOrdering<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Ordering</span><span class="token punctuation">[</span>String<span class="token punctuation">]</span> <span class="token punctuation">{</span>    override def <span class="token function">compare</span><span class="token punctuation">(</span>x<span class="token operator">:</span> String<span class="token punctuation">,</span> y<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token punctuation">{</span>      x<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>toSeq<span class="token punctuation">.</span>sorted<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于StringBuider的使用</title>
      <link href="/2022/03/30/%E5%85%B3%E4%BA%8EStringBuider%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/03/30/%E5%85%B3%E4%BA%8EStringBuider%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="String与StringBuilder的区别"><a href="#String与StringBuilder的区别" class="headerlink" title="String与StringBuilder的区别"></a>String与StringBuilder的区别</h1><h2 id="1-String"><a href="#1-String" class="headerlink" title="1.String"></a>1.String</h2><p>String类位于Java的lang包下 无需导包即可调用</p><p>String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间</p><p>每创建一个String对象就要在栈中 开辟空间 当修改String的值的时候 会在堆中新开辟一块空间 造成空间的浪费</p><h4 id="用String类创建对象通常有两种形式："><a href="#用String类创建对象通常有两种形式：" class="headerlink" title="用String类创建对象通常有两种形式："></a>用String类创建对象通常有两种形式：</h4><p>1、String str &#x3D; “abc”</p><p>2、String str1 &#x3D; new String(“abc”);</p><p>方法1：通过字面量直接给字符串进行赋值，在栈中创建字符串str时，会先在字符串常量池中检查是否已有该字符串，如果没有则创建并存入字符串常量池中，如果已存在则直接从常量池中获取。</p><p>方法2：创建的字符串，不管内存有没有为“abc”字符串分配内存，都会在内存中重新分配一个内存区域存放“abc”，然后用str1指向它，相当于内存中有两个“abc”，只是存放的地址不一样。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>1、public String();</p><p>String类的无参构造方法，用来创建空字符串的String类；</p><p>案例：String str &#x3D; new String();</p><p>2、public String(String value);</p><p>用已知的字符串value值来创建一个字符串对象；</p><p>案例：String str1 &#x3D; new String(“aaa”);</p><p>3、public String(char[] value)</p><p>用字符数组value创建一个String对象。</p><p>案例：char[] value &#x3D; {“ab”,”cd”,”efg”};</p><h2 id="2-StringBuffer"><a href="#2-StringBuffer" class="headerlink" title="2. StringBuffer"></a>2. StringBuffer</h2><p> StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量 </p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/20180411092328691"></p><p><img src="C:\Users\lyc\AppData\Roaming\Typora\typora-user-images\image-20220330183450896.png"></p><p>我们调用equals方法  显而易见结果是false</p><p>一些常用的方法 看参数 你应该就知道如何使用  无非就是增删改查 类型转换 多练即可掌握</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220330183812261.png"></p><p> (1) String中的是常量(final)数组，只能被赋值一次。<br>   比如：new String(“abc”)使得value[]&#x3D;{‘a’,’b’,’c’}(查看jdk String 就是这么实现的)，之后这个String对象中的value[]再也不能改变了。这也正是大家常说的，String是不可变的原因 。<br>   注意：这个对初学者来说有个误区，有人说String str1&#x3D;new String(“abc”); str1&#x3D;new String(“cba”);不是改变了字符串str1吗？那么你有必要先搞懂对象引用和对象本身的区别。这里我简单的说明一下，对象本身指的是存放在堆空间中的该对象的实例数据(非静态非常量字段)。而对象引用指的是堆中对象本身所存放的地址，一般方法区和Java栈中存储的都是对象引用，而非对象本身的数据。</p><p>   (2) StringBuffer中的value[]就是一个很普通的数组，而且可以通过append()方法将新字符串加入value[]末尾。这样也就改变了value[]的内容和大小了。</p><p>   比如：new StringBuffer(“abc”)使得value[]&#x3D;{‘a’,’b’,’c’,’’,’’…}(注意构造的长度是str.length()+16)。如果再将这个对象append(“abc”)，那么这个对象中的value[]&#x3D;{‘a’,’b’,’c’,’a’,’b’,’c’,’’….}。这也就是为什么大家说 StringBuffer是可变字符串 的涵义了。从这一点也可以看出，StringBuffer中的value[]完全可以作为字符串的缓冲区功能。其累加性能是很不错的</p><p>   总结，讨论String和StringBuffer可不可变。本质上是指对象中的value[]字符数组可不可变，而不是对象引用可不可变。 </p><h2 id="3-StringBuilder"><a href="#3-StringBuilder" class="headerlink" title="3.StringBuilder"></a>3.StringBuilder</h2><p>程序开发过程中，我们常常碰到字符串连接的情况，方便和直接的方式是通过”+”符号来实现，但是这种方式达到目的的效率比较低，且每执行一次都会创建一个String对象，即耗时，又浪费空间。使用<a href="https://so.csdn.net/so/search?q=StringBuilder%E7%B1%BB&spm=1001.2101.3001.7020">StringBuilder类</a>就可以避免这种问题的发生，下面就Stringbuilder的使用做个简要的总结：</p><p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&spm=1001.2101.3001.7020">线程安全</a>的（不能同步访问）。</p><p>由于 StringBuilder 相较于 StringBuffer 有速度优势，<strong>所以多数情况下建议使用 StringBuilder 类</strong>。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p><h3 id="String和StringBuilder的区别："><a href="#String和StringBuilder的区别：" class="headerlink" title="String和StringBuilder的区别："></a>String和StringBuilder的区别：</h3><p>   ●String：内容不可变   </p><p>   ●StringBuilder：内容是可变的</p><p>好处：效率高   但线程不安全</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1.无参数  stringBuilder  s&#x3D;new stringBuilder();</p><p>实例化时会有一个默认的16字符的空间，当追加字符超过16个字符时，会新开一个翻倍的空间，而原油空间会浪费掉</p><p>2.有参数：stringBulider s&#x3D;new stringBuilder(20);</p><p>可以在实例化的时候创建一个固定大小的空间，避免资源的浪费。</p><p>常见的方法：</p><p>StringBuilder的常见用法。</p><p>1、初始化一个StringBuilder。</p><pre><code>StringBuilder sb = new StringBuilder()；</code></pre><p>2、填充：使用append() 来追加字符串填充到sb中：</p><pre><code>  sb.append(&quot;xxxx&quot;).append(&quot; xxx&quot;)....可继续延伸</code></pre><p>3、删除sb里面的已有的内容：</p><pre><code>  sb.delete(0,sb.length());将删除sb里面从0开始到结尾的所有内容，也可以自己定义区间</code></pre><p>4、sb里面的内容要显示时需要转换成String类型</p><pre><code>  System.out.println(sb.toString());r reverse() 返回相反的字符序列</code></pre><p>5.reverse 可以反转</p><h2 id="4-从源码出发（进阶）吊打面试官"><a href="#4-从源码出发（进阶）吊打面试官" class="headerlink" title="4.从源码出发（进阶）吊打面试官"></a>4.从源码出发（进阶）吊打面试官</h2><p>stringbuffer和stringbuild区别<br>1、StringBuffer 与 StringBuilder 是长度可变得。<br>2、只是StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。<br>3、在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全。而StringBuffer则每次都需要判断锁，效率相对更低。</p><p>public final class String implements java.io.Serializable, Comparable<String>, CharSequence {<br>    &#x2F;** The value is used for character storage. *&#x2F;<br>    private final char value[];</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** Cache the hash code for the string */</span><span class="token keyword">private</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Default to 0</span><span class="token comment" spellcheck="true">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span>6849794470754667710L<span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">&lt;=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Note: offset or count might be near -1>>>1.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">></span> value<span class="token punctuation">.</span>length <span class="token operator">-</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>offset <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> offset<span class="token operator">+</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个被final关键字修饰的char[]数组，所以实现细节上也是不允许改变，这就是String类的Immutable（不可变）属性(你知道String类为什么不能被继承吗？)，导致每次对String的操作都会生成新的String对象导致每次对String的操作都会生成新的String对象，这样不仅效率低下，而且大量浪费有限的内存空间。<br>2、StringBuffer和StringBuild</p><p>public final class StringBuilder    extends AbstractStringBuilder    implements java.io.Serializable, CharSequence {}</p><p>public final class StringBuffer    extends AbstractStringBuilder    implements java.io.Serializable, CharSequence {}</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>    <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span><span class="token punctuation">,</span> Comparable<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** The value is used for character storage. */</span><span class="token comment" spellcheck="true">//final修饰的char数组</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractStringBuilder</span> <span class="token keyword">implements</span> <span class="token class-name">Appendable</span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * The value is used for character storage.     */</span>    <span class="token comment" spellcheck="true">//stringbuilder和stringbuffer都继承了AbstractStringBuilder 但AbstractStringBuilder 中的     </span><span class="token comment" spellcheck="true">//char数组没有使用final修饰，这就是为什么string是不可变，但stringbuffer和stringbuilder是可变的</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/**     * The count is the number of characters used.     */</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/**     * This no-arg constructor is necessary for serialization of subclasses.     */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过Stringbuffer和Stringbuilder的源码和类结构图，可以发现Stringbuilder和Stringbuffer都是继承了abstractStringbuilder这个抽象类，然后实现了Serializable, CharSequence接口。其次Stringbuilder和Stringbuffer的内部实现其实跟String是一样的，都是通过一个char类型的数组进行存储字符串的，但是是String类中的char数组是final修饰的，是不可变的，而StringBuilder和StringBuffer中的char数组没有被final修饰，是可变的。这就是StringBuilder和StringBuffer和String的区别。</p><p>在多线程编程中有个概念叫原子操作，原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有切换到任何的一个其他的线程）。上述代码中的count+&#x3D;len就不是一个原子操作，它等同于count&#x3D;count+len，比如在上诉代码中，执行到count的值为99998的时候，新建一个len长度为1，但是当有两个线程同时执行到了count+&#x3D;len的时候，他们的count的值都是99998，然后分别各自都执行了count+&#x3D;len，则执行完之后的值都是99999，然后将值赋给count，则count最后的结果是99999，不是正确的100000，所以在多线程中执行stringbuilder的值始终会小于正确的结果。但是StringBuilder和stringbuffer都是继承了abstractstringbuilder为什么结果不一样呢。既然abstractstringbuilder中的append方法肯定都是一样的,再来看看stringbuffer中的</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token comment" spellcheck="true">//append操作被synchronized 关键字修饰了</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> StringBuffer <span class="token function">append</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        toStringCache <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>   <span class="token comment" spellcheck="true">//append操作被synchronized 关键字修饰了</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> StringBuffer <span class="token function">append</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        toStringCache <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现stringbuffer中的append操作被synchronized关键字修饰了。这个关键字肯定不会陌生，主要用来保证多线程中的线程同步和保证数据的准确性。所以再多线程中使用stringbuffer是线程安全的。在AbstractStringBuilder的append方法中有这样的两个个操作:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>count <span class="token operator">+</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//1</span>str<span class="token punctuation">.</span><span class="token function">getChars</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> value<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>转到第一个操作方法的源码，可以发现这是一个是检查StringBuilder对象的原数组的大小是否能装下新的字符串的方法，如果装不下了就new一个新的数组，新的数组的容量是原来char数组的两倍，再通过CopyOf()方法将原数组的内容复制到新数组。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * For positive values of {@code minimumCapacity}, this method     * behaves like {@code ensureCapacity}, however it is never     * synchronized.     * If {@code minimumCapacity} is non positive due to numeric     * overflow, this method throws {@code OutOfMemoryError}.     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minimumCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// overflow-conscious code</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minimumCapacity <span class="token operator">-</span> value<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            value <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span>                    <span class="token function">newCapacity</span><span class="token punctuation">(</span>minimumCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后第二步操作是将String对象里面char数组里面的内容拷贝到StringBuilder对象的char数组里面。getchars源码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getChars</span><span class="token punctuation">(</span><span class="token keyword">int</span> srcBegin<span class="token punctuation">,</span> <span class="token keyword">int</span> srcEnd<span class="token punctuation">,</span> <span class="token keyword">char</span> dst<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> dstBegin<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//1       </span> <span class="token keyword">if</span> <span class="token punctuation">(</span>srcBegin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>srcBegin<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//2   </span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>srcEnd <span class="token operator">></span> value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>srcEnd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//3   </span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>srcBegin <span class="token operator">></span> srcEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>srcEnd <span class="token operator">-</span> srcBegin<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> srcBegin<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> dstBegin<span class="token punctuation">,</span> srcEnd <span class="token operator">-</span> srcBegin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到原来在这里会抛出StringIndexOutOfBoundsException的异常。假设前面的代码中有两个线程a和线程b同时执行了append方法，并且都执行完了ensureCapacityInternal()方法，这个时候count的值为99997，如果当线程a执行完了，则轮到线程2继续执行，线程b执行完了append方法之后，count变成了99998，这个时候如果线程a执行到了上面的getchars方法的时候线程a得到的count的值就是99998了，而它本来的值应该是99997，所以在这个时候就会抛出ArrayIndexOutOfBoundsException的异常了。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建mybatis指南</title>
      <link href="/2022/03/27/%E6%90%AD%E5%BB%BAmybatis%E6%8C%87%E5%8D%97/"/>
      <url>/2022/03/27/%E6%90%AD%E5%BB%BAmybatis%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="一、搭建MyBatis"><a href="#一、搭建MyBatis" class="headerlink" title="一、搭建MyBatis"></a>一、<strong>搭建</strong>MyBatis</h1><h2 id="1-开发环境"><a href="#1-开发环境" class="headerlink" title="1.开发环境"></a>1.开发环境</h2><p>IDEA version : 2021.2.2</p><p>mysql version ：8.0.23</p><p>mybatis version : 3.5.2</p><p>maven version : 3.5.7</p><h2 id="2-创建maven工程"><a href="#2-创建maven工程" class="headerlink" title="2.创建maven工程"></a>2.创建maven工程</h2><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220327134903258.png"></p><p>next-&gt;Name(存放路径)-&gt;groupID(com.lyc.mybatis)-&gt;finish</p><p>加入依赖</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.11<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.5.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>8.0.25<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.13.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-创建数据库连接信息配置文件"><a href="#3-创建数据库连接信息配置文件" class="headerlink" title="3.创建数据库连接信息配置文件"></a>3.创建数据库连接信息配置文件</h2><p>在项目中的src&#x2F;main&#x2F;resources目录下创建db.properties</p><pre class="line-numbers language-sql"><code class="language-sql">driver <span class="token operator">=</span> com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>cj<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>Driverurl <span class="token operator">=</span> jdbc:mysql:<span class="token comment" spellcheck="true">//localhost:3306/mybatis?serverTimezone=UTC&amp;\</span>            characterEncoding<span class="token operator">=</span>utf8<span class="token operator">&amp;</span>useUnicode<span class="token operator">=</span><span class="token boolean">true</span><span class="token operator">&amp;</span>useSSL<span class="token operator">=</span><span class="token boolean">false</span>username <span class="token operator">=</span> rootpassword <span class="token operator">=</span> <span class="token number">123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-创建MyBatis的核心配置文件"><a href="#4-创建MyBatis的核心配置文件" class="headerlink" title="4.创建MyBatis的核心配置文件"></a>4.创建MyBatis的核心配置文件</h2><p>在项目中的src&#x2F;main&#x2F;resources目录下创建MyBatis的核心配置文件</p><p>用于项目的环境配置，如数据库连接相关配置等。建议命名为mybatis-config.xml</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?></span> <span class="token doctype">&lt;!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>db.properties<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!--设置连接数据库的环境--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environments</span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environment</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManager</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POOLED<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driver<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${driver}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${url}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${username}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${password}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataSource</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environment</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environments</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--引入映射文件--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mappers/UserMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数详细：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?></span>  xml的版本号<span class="token doctype">&lt;!DOCTYPE configuration  mybatis中的约束  dtd文件        PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"></span>configuration 根标签environments 可嵌套多个单数标签 <span class="token comment" spellcheck="true">&lt;!--设置连接数据库的环境--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--引入映射文件--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManager</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> 事务的管理方式以jdbc的方式进行管理<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POOLED<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> 数据库连接池 下一次使用直接调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-创建POJO实体"><a href="#5-创建POJO实体" class="headerlink" title="5.创建POJO实体"></a>5.创建POJO实体</h2><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220327143310015.png"></p><p>这是我们的表中的数据 跟实体类的属性要一致（默认的映射规则）-&gt;为属性名赋值</p><p>在src&#x2F;main&#x2F;java 目录下创建com.lyc.mybatis.pojo包 在pojo包下创建User类 该类用于封装User对象的属性 如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> uid<span class="token punctuation">;</span>    <span class="token keyword">private</span> String uname<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> uage<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getUid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> uid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUid</span><span class="token punctuation">(</span><span class="token keyword">int</span> uid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>uid <span class="token operator">=</span> uid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getUname</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> uname<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUname</span><span class="token punctuation">(</span>String uname<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>uname <span class="token operator">=</span> uname<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getUage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> uage<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUage</span><span class="token punctuation">(</span><span class="token keyword">int</span> uage<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>uage <span class="token operator">=</span> uage<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-创建mapper接口"><a href="#6-创建mapper接口" class="headerlink" title="6.创建mapper接口"></a>6.创建mapper接口</h2><p>MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要</p><p>提供实现类。</p><p>在src&#x2F;main&#x2F;java&#x2F;com.lyc.mybatis下创建mapper文件夹</p><p>在文件夹下创建UserMapper接口</p><pre><code>int insertUser();</code></pre><h2 id="7-创建映射文件UserMapper-xml"><a href="#7-创建映射文件UserMapper-xml" class="headerlink" title="7.创建映射文件UserMapper.xml"></a>7.创建映射文件UserMapper.xml</h2><p>在src&#x2F;main&#x2F;resources下创建一个mappers文件夹 在文件下创建映射文件UserMapper.xml</p><p>用于配置真正的sql与java对象之间的映射  </p><p><strong>1.MyBatis映射文件用于编写SQL，访问以及操作表中的数据</strong></p><p><strong>2、MyBatis中可以面向接口操作数据，要保证两个一致：</strong> </p><p>a&gt;mapper接口的全类名和映射文件的命名空间（namespace）保持一致</p><p>b&gt;mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token comment" spellcheck="true">&lt;!--sql与java之间的映射 --></span><span class="token doctype">&lt;!DOCTYPE mapper        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.lyc.mybatis.mapper.UserMapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>insertUser<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        insert into users values (4,'王五',19)    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>映射文件的命名规则：</p><p>表所对应的实体类的类名+Mapper.xml</p><p>例如：表t_user，映射的实体类为Users，所对应的映射文件为UsersMapper.xml</p><h2 id="8-测试"><a href="#8-测试" class="headerlink" title="8.测试"></a>8.测试</h2><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220327152644515.png"></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> com<span class="token punctuation">.</span>lyc<span class="token punctuation">.</span>mybatis<span class="token punctuation">.</span>mapper<span class="token punctuation">.</span>UserMapper<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Resources<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>session<span class="token punctuation">.</span>SqlSession<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>session<span class="token punctuation">.</span>SqlSessionFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>session<span class="token punctuation">.</span>SqlSessionFactoryBuilder<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStream<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapperTest01</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">TestMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//读取MyBatis的核心配置文件 InputStream is = Resources.g</span>        InputStream resourceAsStream <span class="token operator">=</span>   Resources<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"mybatis-config.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">////通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象</span>        SqlSessionFactoryBuilder sqlSessionFactoryBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SqlSessionFactory sqlSessionFactory <span class="token operator">=</span> sqlSessionFactoryBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>resourceAsStream<span class="token punctuation">)</span><span class="token punctuation">;</span>        SqlSession session <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                UserMapper mapper <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>UserMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配 映射文件中的SQL标            签，并执行标签中的SQL语句</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">insertUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//事务提交</span>        session<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result"</span><span class="token operator">+</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> ORM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql中的聚合函数易混淆的概念</title>
      <link href="/2022/03/20/mysql%E4%B8%AD%E7%9A%84%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/03/20/mysql%E4%B8%AD%E7%9A%84%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h1><p>与其他查询不同，普通的查询做的都是横向查询，它们都是根据条件一行一行的进行判断，而使用聚合函数查询是纵向查询，</p><p>它是对一列的值进行计算，然后返回一个单一的值；另外聚合函数会忽略空值。</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/11.png"></p><h3 id="从案例引出问题："><a href="#从案例引出问题：" class="headerlink" title="从案例引出问题："></a>从案例引出问题：</h3><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220320154124681.png"></p><p>我们基于以上表作为查询：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> product<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 返回18 没有任何问题</span><span class="token keyword">select</span> pid<span class="token punctuation">,</span><span class="token function">min</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span> <span class="token keyword">from</span> product <span class="token punctuation">;</span><span class="token keyword">select</span> pid<span class="token punctuation">,</span><span class="token function">max</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span> <span class="token keyword">from</span> product <span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 此时不报错 pid显示结果都为1  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Q；为什么会产生这种现象？</p><p>因为聚合函数是对列进行操作和pid字段没有产生联系 ，系统pid默认的值全为1</p><p>此时我们可以考虑子查询＋AND 来解决类似hive里的窗口函数的功能</p><pre><code>select pid ,price from product where price = (select min(price) from product);</code></pre><p>聚合函数一般会和分组查询group by 结合使用</p><p>格式：</p><p>select 字段1,字段2… from 表名 group by 分组字段 having 分组条件;</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 1 统计各个分类商品的个数</span><span class="token keyword">select</span> category_id <span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> product <span class="token keyword">group</span> <span class="token keyword">by</span> category_id <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220320160246892.png"></p><p>执行结果如上：</p><p>执行顺序是先分组 再进行count聚合  </p><p>注意：如果要进行分组的话，则SELECT子句之后，只能出现分组的字段和统计函数，其他的字段不能出现</p><h3 id="having与where的区别"><a href="#having与where的区别" class="headerlink" title="having与where的区别"></a>having与where的区别</h3><ul><li><p>分组之后对统计结果进行筛选的话必须使用having，不能使用where</p></li><li><p>where子句用来筛选 FROM 子句中指定的操作所产生的   行 </p></li><li><p>group  by  子句用来分组 WHERE 子句的输出。 </p></li><li><p>having 子句用来从分组的结果中筛选行</p></li></ul><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> category_id <span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> product <span class="token keyword">where</span> price<span class="token operator">></span><span class="token number">300</span> <span class="token keyword">group</span> <span class="token keyword">by</span> category_id <span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">select</span> category_id <span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> product <span class="token keyword">group</span> <span class="token keyword">by</span> category_id <span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 思考以上语句哪条会有问题？</span><span class="token comment" spellcheck="true">-- 答案是都没问题 where首先把不满足的行去掉后进行分组，筛选出特定的组 </span><span class="token comment" spellcheck="true">-- 另一个也是将条件不满足的筛选掉 只不过是分组后进行 顺序问题</span><span class="token comment" spellcheck="true">-- 执行顺序where>group by>count(*) > having </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="一些注意的点"><a href="#一些注意的点" class="headerlink" title="一些注意的点"></a>一些注意的点</h3><p>mysql 5.6环境下除了count(*)为特例（不忽略null值）外，其余聚集函数确实是忽略null值</p><p>聚合函数默认忽略字段为null的记录 要想列值为null的记录也参与计算，必须使用ifnull函数对null值做替换  这里不做过多演示</p><p>使用Group By子句返回的组没有特定的顺序，可以使用Order By子句指定次序。</p><p>group by和order by连用的确会出现问题</p><h4 id="Group-by中子查询order-by排序失效问题分析"><a href="#Group-by中子查询order-by排序失效问题分析" class="headerlink" title="Group by中子查询order by排序失效问题分析"></a>Group by中子查询order by排序失效问题分析</h4><p>依然要考虑执行顺序</p><p><strong>获取sql分组中id最大的记录</strong></p><p>select id,name from (select id,name from tt order by id desc) as t group by name</p><p>从from开始执行顺序   group by的执行顺序&gt; select  每个组默认取了第一条数据。</p><pre><code>// 表数据如下：id,name1,name12,name13,name24,name2select id,name from (select id,name from tt order by id desc) as t group by name// 输出结果如下：id,name1,name13,name2</code></pre><p>这是为什么呢？因为mysql 5.6之后版本对排序的sql解析做了优化，子查询中的排序是会被忽略的，所以上面的order by id desc未起到作用。如果子语句中排序不做优化那不就可以了么，查阅资料发现可以在子语句中加上limit来避免这种优化（加上limit相当于临时表限定了取值范围不会进行优化，如果是全表的话就被优化掉了）。</p><p>正确写法：</p><pre><code>// 加上limitselect id,name from (select id,name from tt order by id desc limit 1024) as t group by name // 输出结果如下：id,name2,name14,name2</code></pre>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 聚合函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList底层结构和源码分析</title>
      <link href="/2022/03/19/ArrayList%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2022/03/19/ArrayList%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h1><p>1）允许添加任意的元素 包括null 多个</p><p>2） ArrayList是由数组来实现数据存储的</p><p>3）Array在多线程中是不安全的 建议使用vector</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>数组是数据结构基本的数据结构 java封装了一系列数组的方法</p><p>数组中存储的内存是连续的 插入和删除困难 查询方便</p><ul><li>ArrayList中维护了一个Object类型的数组elementData</li><li>无参构造器：自动扩容机制 ele-&gt;0（default）-&gt;10（First add）-&gt;15(second add)-&gt;15x1.5-&gt;15x1.5x1.5</li><li>有参构造器：指定大小（size）-&gt;size*1.5(First add) -&gt; sizex1.5X1.5(second add)</li></ul><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><ul><li>Tip：英语对于看源码和理解有一定的帮助</li></ul><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h4><pre class="line-numbers language-java"><code class="language-java">     <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建指定长度的object数组</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//空数组</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>            <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将集合转换成数组</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> ArrayList<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//如果不是object数组类型</span>                elementData <span class="token operator">=</span> a<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> size<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//拷贝一下</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// replace with empty array.</span>            elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * This helper method split out from add(E) to keep method * bytecode size under 35 (the -XX:MaxInlineSize default value), * which helps when add(E) is called in a C1-compiled loop. */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        elementData <span class="token operator">=</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    size <span class="token operator">=</span> s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return {@code true} (as specified by {@link Collection#add}) */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//改进后的直接自增</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException {@inheritDoc} */</span><span class="token comment" spellcheck="true">//指定位置添加</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> s<span class="token punctuation">;</span>    Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> size<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span>elementData <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>elementData<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>        elementData <span class="token operator">=</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将index之后的所有元素移动一位</span>    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                     elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                     s <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>    size <span class="token operator">=</span> s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//扩容的入口方法 DEFAULTCAPACITY_EMPTY_ELEMENTDATA  默认为10</span><span class="token comment" spellcheck="true">//判断是你的值大还是它的值大 就返回你的值</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> elementData<span class="token punctuation">.</span>length            <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA                 <span class="token operator">&amp;&amp;</span> minCapacity <span class="token operator">&lt;=</span> DEFAULT_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            modCount<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//数组扩容方法</span>   <span class="token keyword">private</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> elementData <span class="token operator">!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> ArraysSupport<span class="token punctuation">.</span><span class="token function">newLength</span><span class="token punctuation">(</span>oldCapacity<span class="token punctuation">,</span>                    minCapacity <span class="token operator">-</span> oldCapacity<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* minimum growth */</span>                    oldCapacity <span class="token operator">>></span> <span class="token number">1</span>           <span class="token comment" spellcheck="true">/* preferred growth */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">grow</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//第一次其实是  0*any=0    </span><span class="token comment" spellcheck="true">//用0.5倍来扩容</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>modCount++;用来记录修改的记录</p><pre><code>return elementData = Arrays.copyOf(elementData, newCapacity);</code></pre><p>进行扩容</p><p>使用扩容机制来确定扩容到多大</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于HashList的深入探究</title>
      <link href="/2022/03/15/%E5%85%B3%E4%BA%8EHashList%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6/"/>
      <url>/2022/03/15/%E5%85%B3%E4%BA%8EHashList%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220315223146221.png"></p><h2 id="HashSet本质是HashMap"><a href="#HashSet本质是HashMap" class="headerlink" title="HashSet本质是HashMap"></a>HashSet本质是HashMap</h2><p>HashSet是一个不允许有重复元素的集合。</p><p>它实现了set接口 可以存放null值，但是只能有一个null</p><p>和ArrayList不同的是：HashSet 是无序的，即不会记录插入的顺序。</p><p>HashSet是非同步的。如果多个线程同时访问一个<a href="https://so.csdn.net/so/search?q=%E5%93%88%E5%B8%8C&spm=1001.2101.3001.7020">哈希</a> set，<br>而其中至少一个线程修改了该 set，那么它必须 保持外部同步。这通常是通过对自然封装该 set 的对象执行同步操作来完成的。<br>如果不存在这样的对象，则应该使用 Collections.synchronizedSet 方法来“包装” set。最好在创建时完成这一操作，<br>以防止对该 set 进行意外的不同步访问：</p><pre><code>HashSet set = new HashSet();//1.add方法返回的是一个boolean值 添加成功则为true 失败为false//2.remove的方法指定删除对象</code></pre><h2 id="HASHMAP"><a href="#HASHMAP" class="headerlink" title="HASHMAP"></a>HASHMAP</h2><p>HashMap底层是数组+链表+红黑树</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/20160605101246837.png"></p><h3 id="数组元素Node-lt-K-V-gt-实现了Entry接口"><a href="#数组元素Node-lt-K-V-gt-实现了Entry接口" class="headerlink" title="数组元素Node&lt;K,V&gt;实现了Entry接口"></a>数组元素Node&lt;K,V&gt;实现了Entry接口</h3><pre><code>//Node是单向链表，它实现了Map.Entry接口static class Node&lt;k,v&gt; implements Map.Entry&lt;k,v&gt; &#123;    final int hash;    final K key;    V value;    Node&lt;k,v&gt; next;    //构造函数Hash值 键 值 下一个节点    Node(int hash, K key, V value, Node&lt;k,v&gt; next) &#123;        this.hash = hash;        this.key = key;        this.value = value;        this.next = next;    &#125;     public final K getKey()        &#123; return key; &#125;    public final V getValue()      &#123; return value; &#125;    public final String toString() &#123; return key + = + value; &#125;     public final int hashCode() &#123;        return Objects.hashCode(key) ^ Objects.hashCode(value);    &#125;     public final V setValue(V newValue) &#123;        V oldValue = value;        value = newValue;        return oldValue;    &#125;    //判断两个node是否相等,若key和value都相等，返回true。可以与自身比较为true    public final boolean equals(Object o) &#123;        if (o == this)            return true;        if (o instanceof Map.Entry) &#123;            Map.Entry&lt;!--?,?--&gt; e = (Map.Entry&lt;!--?,?--&gt;)o;            if (Objects.equals(key, e.getKey()) &amp;&amp;                Objects.equals(value, e.getValue()))                return true;        &#125;        return false;    &#125;</code></pre><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><pre><code>//红黑树static final class TreeNode&lt;k,v&gt; extends LinkedHashMap.Entry&lt;k,v&gt; &#123;    TreeNode&lt;k,v&gt; parent;  // 父节点    TreeNode&lt;k,v&gt; left; //左子树    TreeNode&lt;k,v&gt; right;//右子树    TreeNode&lt;k,v&gt; prev;    // needed to unlink next upon deletion    boolean red;    //颜色属性    TreeNode(int hash, K key, V val, Node&lt;k,v&gt; next) &#123;        super(hash, key, val, next);    &#125;     //返回当前节点的根节点    final TreeNode&lt;k,v&gt; root() &#123;        for (TreeNode&lt;k,v&gt; r = this, p;;) &#123;            if ((p = r.parent) == null)                return r;            r = p;        &#125;    &#125;</code></pre><p>HashMap有四个构造函数可供我们使用</p><pre><code>//默认无参构造，指定一个默认的加载因子public HashMap() &#123;    this.loadFactor = DEFAULT_LOAD_FACTOR; &#125;//可指定容量的有参构造，但是需要注意当前我们指定的容量并不一定就是实际的容量，下面会说public HashMap(int initialCapacity) &#123;    //同样使用默认加载因子    this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;//可指定容量和加载因子，但是笔者不建议自己手动指定非0.75的加载因子public HashMap(int initialCapacity, float loadFactor) &#123;    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                           initialCapacity);    if (initialCapacity &gt; MAXIMUM_CAPACITY)        initialCapacity = MAXIMUM_CAPACITY;    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                                           loadFactor);    this.loadFactor = loadFactor;    //这里就是把我们指定的容量改为一个大于它的的最小的2次幂值，如传过来的容量是14，则返回16    this.threshold = tableSizeFor(initialCapacity);&#125;//可传入一个已有的mappublic HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;    this.loadFactor = DEFAULT_LOAD_FACTOR;    putMapEntries(m, false);&#125;//把传入的map里边的元素都加载到当前mapfinal void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;    int s = m.size();    if (s &gt; 0) &#123;        if (table == null) &#123; // pre-size            float ft = ((float)s / loadFactor) + 1.0F;            int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?                     (int)ft : MAXIMUM_CAPACITY);            if (t &gt; threshold)                threshold = tableSizeFor(t);        &#125;        else if (s &gt; threshold)            resize();        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;            K key = e.getKey();            V value = e.getValue();    putVal(hash(key), key, value, false, evict);        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的基本运用</title>
      <link href="/2022/03/10/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%94%A8/"/>
      <url>/2022/03/10/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="认识单链表"><a href="#认识单链表" class="headerlink" title="认识单链表"></a>认识单链表</h1><p>单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。<br>链表中的数据是以节点来表示的，每个节点的构成：data域（数据元素）+next域（下一个结点的存储位置）。<br>单链表与数组相比的最大差别是：单链表的数据元素存放在内存空间的地址是不连续的，<br>而数组的数据元素存放的地址在内存空间中是连续的，<br>这也是为什么根据索引无法像数组那样直接就能查询到数据元素。</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/109.png" alt="109"></p><h2 id="基本操作如下"><a href="#基本操作如下" class="headerlink" title="基本操作如下"></a>基本操作如下</h2><pre><code>public class LinkList &#123;    private static final LinkNode NULL = null;private LinkNode Head = new LinkNode();//先初始化一个头结点，头结点为空    LinkList() &#123;        Init_LinkNode();&#125;//内部类节点LinkNode    class LinkNode &#123;        int data;        LinkNode next=null;        LinkNode()&#123;        &#125;        LinkNode(int elem)&#123;            data=elem;        &#125;        LinkNode(int elem,LinkNode nextval)&#123;            data=elem;            next=nextval;        &#125;        LinkNode(LinkNode nextval)&#123;            next=nextval;        &#125;    &#125;        //1.单链表的初始化    public void Init_LinkNode() &#123;        LinkNode head = null;    &#125;//2.    判断表是否为空 public boolean isEmpty() &#123;//通过判断头结点的下一结点地址是否为空，即可判断单链表是否为空        if(this.Head.next == null) &#123;           return true;         &#125;        return false;    &#125;    //3.返回单链表的长度    public int Length_LinkList() &#123;        int j=0;        LinkNode tmp=Head; //head节点不能动，需要一个tmp辅助遍历        while(tmp != null) &#123;            j++;            tmp=tmp.next;        &#125;        return j;    &#125;        //4.返回第i个元素        public LinkNode Get_LinkList(int i) &#123;            LinkNode p = Head;            int a = 0;            while (p.next != null &amp;&amp; a &lt; i) &#123;                p = p.next;                a++;            &#125;            if (a == i) &#123;                return p;            &#125; else &#123;                return null;            &#125;        &#125;       //5.删除第i个元素        public int Delete_LinkList(int i) &#123;                LinkNode p;                LinkNode s;            p=Get_LinkList(i-1);            if(p==null)&#123;                System.out.println(&quot;第i-1个结点不存在&quot;);                return -1;            &#125;else if (p.next==null)&#123;                System.out.println(&quot;第i个结点不存在&quot;);                return 0;            &#125;else&#123;                s=p.next;                p.next=s.next;                return 1;            &#125;        &#125; //6.在第i个位置插入元素        public int  Insert_LinkList(int i,int x) &#123;        LinkNode p,s;        p=Get_LinkList(i-1);            if(p==null)&#123;                System.out.println(&quot;参数i错误&quot;);                return 0;            &#125;else &#123;                s=new LinkNode();                s.data=x;                s.next=p.next;                p.next=s;                return 1;            &#125;&#125;        //7.把表中的元素打印出来            public void display()&#123;                LinkNode tmp=Head;                while (tmp!=null) &#123;                    System.out.println(tmp.data+&quot;  &quot;);                    tmp=tmp.next;                &#125;                System.out.println();            &#125;&#125;</code></pre><h1 id="顺序表与单链表的比较"><a href="#顺序表与单链表的比较" class="headerlink" title="顺序表与单链表的比较"></a>顺序表与单链表的比较</h1><h2 id="顺序表的优点："><a href="#顺序表的优点：" class="headerlink" title="顺序表的优点："></a>顺序表的优点：</h2><p>其存储结构为随机存取结构，逻辑关系可直接用数组元素下标表示。</p><h2 id="顺序表的缺点："><a href="#顺序表的缺点：" class="headerlink" title="顺序表的缺点："></a>顺序表的缺点：</h2><p>①线性表的长度不确定，难以事先确定数组长度。<br>②存储空间必须是连续的，易造成存储空间的“碎片”现象。③插入和删除操作需要移动大量元素。</p><h2 id="单链表的优点："><a href="#单链表的优点：" class="headerlink" title="单链表的优点："></a>单链表的优点：</h2><p>①元素的存储单元是任意的，可连续也可不连续。②不需要限定长度。</p><h2 id="单链表的缺点"><a href="#单链表的缺点" class="headerlink" title="单链表的缺点"></a>单链表的缺点</h2><p>：①其查找时间复杂度为O(n)。②存放元素时需要另外开辟一个指针域的空间。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
