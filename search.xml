<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Zookeeper的基本介绍</title>
      <link href="/2022/03/19/zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/03/19/zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Zookeeper："><a href="#Zookeeper：" class="headerlink" title="Zookeeper："></a>Zookeeper：</h1><p>官方文档上这么解释zookeeper，它是一个分布式服务框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：<strong>统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理</strong>。  </p><p>上面的解释有点抽象，简单来说zookeeper&#x3D;文件系统+监听通知机制。  </p><p>每个子目录项如 NameService 都被称作为 znode(目录节点)，和文件系统一样，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode，唯一的不同在于znode是可以存储<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE&spm=1001.2101.3001.7020">数据</a>的。</p><h4 id="四种类型的znode："><a href="#四种类型的znode：" class="headerlink" title="四种类型的znode："></a>四种类型的znode：</h4><ul><li><h5 id="PERSISTENT-持久化目录节点"><a href="#PERSISTENT-持久化目录节点" class="headerlink" title="PERSISTENT-持久化目录节点"></a>PERSISTENT-持久化目录节点</h5></li></ul><p>客户端与zookeeper断开连接后，该节点依旧存在</p><ul><li><h5 id="PERSISTENT-SEQUENTIAL-持久化顺序编号目录节点"><a href="#PERSISTENT-SEQUENTIAL-持久化顺序编号目录节点" class="headerlink" title="PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点"></a>PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点</h5></li></ul><p>客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号</p><ul><li><h5 id="EPHEMERAL-临时目录节点"><a href="#EPHEMERAL-临时目录节点" class="headerlink" title="EPHEMERAL-临时目录节点"></a>EPHEMERAL-临时目录节点</h5></li></ul><p>客户端与zookeeper断开连接后，该节点被删除</p><ul><li><h5 id="EPHEMERAL-SEQUENTIAL-临时顺序编号目录节点"><a href="#EPHEMERAL-SEQUENTIAL-临时顺序编号目录节点" class="headerlink" title="EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点"></a>EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点</h5></li></ul><p>客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</p><h4 id="监听通知机制"><a href="#监听通知机制" class="headerlink" title="监听通知机制"></a>监听通知机制</h4><p>客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。</p><p>就这么简单，下面我们看看Zookeeper能做点什么呢？</p><p>zookeeper功能非常强大，可以实现诸如<a href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F&spm=1001.2101.3001.7020">分布式</a>应用配置管理、统一命名服务、状态同步服务、集群管理等功能，我们这里拿比较简单的分布式应用配置管理为例来说明。</p><p>假设我们的程序是分布式部署在多台机器上，如果我们要改变程序的配置文件，需要逐台机器去修改，非常麻烦，现在把这些配置全部放到zookeeper上去，保存在 zookeeper 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到 zookeeper 的通知，然后从 zookeeper 获取新的配置信息应用到系统中。</p><h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><p>先给自己选票+1；后面再根据myid开始选票；</p><ul><li><p>崩溃恢复：主要就是Leader选举过程。</p></li><li><p>数据同步：Leader服务器与其他服务器进行数据同步。</p></li><li><p>消息广播：Leader服务器将数据发送给其他服务器。</p></li></ul><p>Q:集群中为什么要有主节点</p><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，</p><p>其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点</p><h2 id="leader-选举过程"><a href="#leader-选举过程" class="headerlink" title="leader 选举过程"></a>leader 选举过程</h2><p>有两种情况会发起Leader选举：</p><ol><li><p>服务器启动的时候</p></li><li><p>服务器运行的时候当Leader宕机</p></li></ol><h4 id="第一次选举规则："><a href="#第一次选举规则：" class="headerlink" title="第一次选举规则："></a><strong>第一次选举规则：</strong></h4><p>投票过半数时，id大的胜出</p><h4 id="第二次选举规则："><a href="#第二次选举规则：" class="headerlink" title="第二次选举规则："></a><strong>第二次选举规则：</strong></h4><p>Epoch 大的直接胜出</p><p>若相同 ID 大的直接胜出</p><p>事物id相同 服务器id大的胜出</p><h3 id="Q-生产集群安装多少台zookeeper合适："><a href="#Q-生产集群安装多少台zookeeper合适：" class="headerlink" title="Q:生产集群安装多少台zookeeper合适："></a>Q:生产集群安装多少台zookeeper合适：</h3><p>10台服务器：3台zk;</p><p>20台：5台zk</p><p>100台：11台zk</p><p>服务器台数多的时候，可靠性比较高 坏处：提高通信延时</p><p>paxos算法：一种消息传递且具有高度容错特性的一致性算法</p><h3 id="Q-Zookeeper-怎么保证主从节点的状态同步？"><a href="#Q-Zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="Q:Zookeeper 怎么保证主从节点的状态同步？"></a>Q:Zookeeper 怎么保证主从节点的状态同步？</h3><p>Zookeeper 的核心是原子广播机制，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。</p><p>paxos算法解决的问题：就是如何快速在一个分布式系统中对某一个数据进行达成一致，且保证不论发生任何异常</p><p>都不会破坏系统的一致性</p><p>例如：机器宕机</p>]]></content>
      
      
      <categories>
          
          <category> 大数据生态圈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于super关键字和this的区别</title>
      <link href="/2022/03/17/%E5%85%B3%E4%BA%8Esuper%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8Cthis%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/03/17/%E5%85%B3%E4%BA%8Esuper%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8Cthis%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="一、super-与-this-用法"><a href="#一、super-与-this-用法" class="headerlink" title="一、super 与 this 用法"></a>一、super 与 this 用法</h2><h4 id="关于super"><a href="#关于super" class="headerlink" title="关于super"></a>关于super</h4><ol><li><p>主要存在于子类方法中，用于指向子类对象中父类对象。</p></li><li><p>调用父类的属性和方法</p></li><li><p>访问父类的构造函数</p></li></ol><ul><li><p>关于super你首先需要明白的是，如果父类和子类都有一个同名方法</p><p> 在没有重写的情况下，优先调用的是父类的方法</p></li><li><p>只有重写后才会优先调用子类的 这时候就可以使用super关键字来调用</p></li><li><p>super（形参列表）的使用，必须声明在<a href="https://so.csdn.net/so/search?q=%E5%AD%90%E7%B1%BB&spm=1001.2101.3001.7020">子类</a>构造器的首行。</p></li></ul><p><strong>例子</strong></p><p>我们可以注意到父类和子类都有相同的成员变量age，（super.age）就是访问的是Person类中的age </p><p>如果不加super 就近原则就是Student类的age</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    int age = 12;</span><br><span class="line">&#125;</span><br><span class="line">class Student extends Person &#123;</span><br><span class="line">    int age = 18;</span><br><span class="line">    void display() &#123;</span><br><span class="line">        System.out.println(&quot;学生年龄：&quot; + super.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student stu = new Student();</span><br><span class="line">        stu.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h4><p>​    1 this相当于是指向当前对象本身</p><p>​    2 形参与成员变量重名，用this来区分</p><p>​    3 this关键字也可以在构造函数中调用其他构造函数 但是必须定义在构造函数的第一行 这一点与super的用法非常相似  this（）调用其他构造函数时，必须放在定义的构造函数第一行。如果随意放在普通方法的第一行，则立马报错</p><p><strong>例子</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">private String name;</span><br><span class="line">private int age;</span><br><span class="line">Person(String name)</span><br><span class="line">&#123;</span><br><span class="line">//成员变量和局部变量重名，可以用关键字this区分</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">public void speak()</span><br><span class="line">&#123;</span><br><span class="line">        //输出时，会默认为成员增加this关键字，用来代表具体对象的数据</span><br><span class="line">System.out.println(this.name+&quot;：&quot;+this.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">private String name;</span><br><span class="line">private int age;</span><br><span class="line">Person()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;baby&quot;;</span><br><span class="line">age = 1;</span><br><span class="line">System.out.println(&quot;Person run&quot;);</span><br><span class="line">&#125;</span><br><span class="line">Person(String name)</span><br><span class="line">&#123;</span><br><span class="line">//成员变量和局部变量重名，可以用关键字this区分</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person(String name,int age)</span><br><span class="line">&#123;</span><br><span class="line">//调用其他构造函数时，只能定义在构造函数的第一行，因为初始化动作要先执行</span><br><span class="line">this();</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">public void speak()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(this.name+&quot;：&quot;+this.age);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class ThisDemo </span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args) </span><br><span class="line">&#123;</span><br><span class="line">Person p = new Person(&quot;小强&quot;,10);</span><br><span class="line">p.speak();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果Person run 小强：10</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <strong>虽然我们在 Person(String name,int age) 构造函数中调用了 Person() 构造函数，但是最后的输出结果，仅输出了 Person run ，成员变量的内容还是我们在新建对象时，传递进去的参数，并不是 Person() 中初始化的内容。成员变量传进去的参数所被覆盖了</strong></p><h4 id="二、关于一些细节"><a href="#二、关于一些细节" class="headerlink" title="二、关于一些细节"></a>二、关于一些细节</h4><p>为了看的更直观 我们直接用代码进行说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    public Animal() &#123;</span><br><span class="line">        System.out.println(&quot;Animal类的无参数构造函数执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    public Cat() &#123;</span><br><span class="line">        System.out.println(&quot;Cat类的无参数构造函数执行&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Test &#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            Cat c1 = new Cat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 在实例化对象的时候 直接就把构造器的方法全执行了</span><br><span class="line">//上面的隐藏了一个super(); 你写不写都行 但为了看的方便我们还是需要在子类的构造器中写一下的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么又引出一个问题 父类有多个构造器我们怎么知道super调用的是哪个?</p><p>1.父类是无参构造器 super（）；</p><p>2.父类是有参构造器super(name,age); 调用相同形参的</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于HashList的深入探究</title>
      <link href="/2022/03/15/%E5%85%B3%E4%BA%8EHashList%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6/"/>
      <url>/2022/03/15/%E5%85%B3%E4%BA%8EHashList%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220315223146221.png"></p><h2 id="HashSet本质是HashMap"><a href="#HashSet本质是HashMap" class="headerlink" title="HashSet本质是HashMap"></a>HashSet本质是HashMap</h2><p>HashSet是一个不允许有重复元素的集合。</p><p>它实现了set接口 可以存放null值，但是只能有一个null</p><p>和ArrayList不同的是：HashSet 是无序的，即不会记录插入的顺序。</p><p>HashSet是非同步的。如果多个线程同时访问一个<a href="https://so.csdn.net/so/search?q=%E5%93%88%E5%B8%8C&spm=1001.2101.3001.7020">哈希</a> set，而其中至少一个线程修改了该 set，那么它必须 保持外部同步。这通常是通过对自然封装该 set 的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用 Collections.synchronizedSet 方法来“包装” set。最好在创建时完成这一操作，以防止对该 set 进行意外的不同步访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HashSet set = new HashSet();</span><br><span class="line">//1.add方法返回的是一个boolean值 添加成功则为true 失败为false</span><br><span class="line">//2.remove的方法指定删除对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="HASHMAP"><a href="#HASHMAP" class="headerlink" title="HASHMAP"></a>HASHMAP</h2><p>HashMap底层是数组+链表+红黑树</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/20160605101246837.png"></p><h3 id="数组元素Node-lt-K-V-gt-实现了Entry接口"><a href="#数组元素Node-lt-K-V-gt-实现了Entry接口" class="headerlink" title="数组元素Node&lt;K,V&gt;实现了Entry接口"></a>数组元素Node&lt;K,V&gt;实现了Entry接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//Node是单向链表，它实现了Map.Entry接口</span><br><span class="line">static class Node&lt;k,v&gt; implements Map.Entry&lt;k,v&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;k,v&gt; next;</span><br><span class="line">    //构造函数Hash值 键 值 下一个节点</span><br><span class="line">    Node(int hash, K key, V value, Node&lt;k,v&gt; next) &#123;</span><br><span class="line">        this.hash = hash;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public final K getKey()        &#123; return key; &#125;</span><br><span class="line">    public final V getValue()      &#123; return value; &#125;</span><br><span class="line">    public final String toString() &#123; return key + = + value; &#125;</span><br><span class="line"> </span><br><span class="line">    public final int hashCode() &#123;</span><br><span class="line">        return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public final V setValue(V newValue) &#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断两个node是否相等,若key和value都相等，返回true。可以与自身比较为true</span><br><span class="line">    public final boolean equals(Object o) &#123;</span><br><span class="line">        if (o == this)</span><br><span class="line">            return true;</span><br><span class="line">        if (o instanceof Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;!--?,?--&gt; e = (Map.Entry&lt;!--?,?--&gt;)o;</span><br><span class="line">            if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//红黑树</span><br><span class="line">static final class TreeNode&lt;k,v&gt; extends LinkedHashMap.Entry&lt;k,v&gt; &#123;</span><br><span class="line">    TreeNode&lt;k,v&gt; parent;  // 父节点</span><br><span class="line">    TreeNode&lt;k,v&gt; left; //左子树</span><br><span class="line">    TreeNode&lt;k,v&gt; right;//右子树</span><br><span class="line">    TreeNode&lt;k,v&gt; prev;    // needed to unlink next upon deletion</span><br><span class="line">    boolean red;    //颜色属性</span><br><span class="line">    TreeNode(int hash, K key, V val, Node&lt;k,v&gt; next) &#123;</span><br><span class="line">        super(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //返回当前节点的根节点</span><br><span class="line">    final TreeNode&lt;k,v&gt; root() &#123;</span><br><span class="line">        for (TreeNode&lt;k,v&gt; r = this, p;;) &#123;</span><br><span class="line">            if ((p = r.parent) == null)</span><br><span class="line">                return r;</span><br><span class="line">            r = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>HashMap有四个构造函数可供我们使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//默认无参构造，指定一个默认的加载因子</span><br><span class="line">public HashMap() &#123;</span><br><span class="line">this.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//可指定容量的有参构造，但是需要注意当前我们指定的容量并不一定就是实际的容量，下面会说</span><br><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">//同样使用默认加载因子</span><br><span class="line">this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//可指定容量和加载因子，但是笔者不建议自己手动指定非0.75的加载因子</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">if (initialCapacity &lt; 0)</span><br><span class="line">throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">   initialCapacity);</span><br><span class="line">if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">   loadFactor);</span><br><span class="line">this.loadFactor = loadFactor;</span><br><span class="line">//这里就是把我们指定的容量改为一个大于它的的最小的2次幂值，如传过来的容量是14，则返回16</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//可传入一个已有的map</span><br><span class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">putMapEntries(m, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//把传入的map里边的元素都加载到当前map</span><br><span class="line">final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;</span><br><span class="line">int s = m.size();</span><br><span class="line">if (s &gt; 0) &#123;</span><br><span class="line">if (table == null) &#123; // pre-size</span><br><span class="line">float ft = ((float)s / loadFactor) + 1.0F;</span><br><span class="line">int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?</span><br><span class="line"> (int)ft : MAXIMUM_CAPACITY);</span><br><span class="line">if (t &gt; threshold)</span><br><span class="line">threshold = tableSizeFor(t);</span><br><span class="line">&#125;</span><br><span class="line">else if (s &gt; threshold)</span><br><span class="line">resize();</span><br><span class="line">for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">K key = e.getKey();</span><br><span class="line">V value = e.getValue();putVal(hash(key), key, value, false, evict);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dp动态规划</title>
      <link href="/2022/03/13/dp%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/"/>
      <url>/2022/03/13/dp%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划算法（Dynamic-Programming）"><a href="#动态规划算法（Dynamic-Programming）" class="headerlink" title="动态规划算法（Dynamic Programming）"></a>动态规划算法（Dynamic Programming）</h2><ol><li><p>是将复杂问题拆分成子问题，并在子问题的基础上，求解复杂问题，子问题之间不是独立的，而是相互依存的。<br>动态规划算法有两种实现形式：递归，非递归</p></li><li><p>动态规划是求解决策过程最优化的数学方法。利用各个阶段之间的关系，逐个求解，最终求得全局最优解，<br>需要确认原问题与子问题、动态规划状态、边界状态、边界状态结值、状态转移方程。</p></li></ol><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>在解决问题之前，为描述方便，首先定义一些变量：Vi表示第 i 个物品的价值，<br>Wi表示第 i 个物品的体积，定义V(i,j)：<br>当前背包容量 j，前 i 个物品最佳组合对应的价值，<br>同时背包问题抽象化（X1，X2，…，Xn，其中 Xi 取0或1，表示第 i 个物品选或不选）。</p><p>1、建立模型，即求max(V1X1+V2X2+…+VnXn)；</p><p>2、寻找约束条件，W1X1+W2X2+…+WnXn&lt;capacity；</p><p>3、寻找递推关系式，面对当前商品有两种可能性：</p><p>包的容量比该商品体积小，装不下，此时的价值与前i-1个的价值是一样的，即V(i,j)&#x3D;V(i-1,j)；<br>还有足够的容量可以装该商品，但装了也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即V(i,j)&#x3D;max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝。</p><p>首先假设每个物品重量是 2 2 4 6 3,我们假设 i 表示将要决策第几个物品是否装入背包，cw表示当前背包中物品的总重量<br>，然后用(i,cw)。比如，(2,2)表示将要决策第2个物品是否要装入背包，决策前，背包的总重为2.</p><p>我们可以从递归树明显的看出，有些子问题的求解是重复的，重复的计算必然会造成性能的丢失，如果我们能保留之前的结果，<br>计算之前先检索一下，如果有计算过，那么直接拿过来用，肯定会提升一下性能。</p><p>首先将整体求解分为n个阶段，每个阶段会决策一个物品是否放到包里。<br>不论放入还是不放入，背包的重量假设都造成了变化，而这些不同的变化，也就对应着递归树的节点<br>合并重复的节点，避免节点指数级增长<br>基于这一层的节点，推导出下一层的状态集合<br>然后用上面的思路，代入到0-1背包问题中做一个思路引导：</p><p>首先我们创建一个布尔类型的二维数组states[n][w]，记录每个节点的不同状态。n代表第n个物品，w代表背包能承受的最大质量。<br>第0个(假设物品序列从0开始计算)物品的重量是2，放入，就是states[0][2]，不放入，就是states[0][0]，但是因为最大重量w是9，所以上面两个表达式的结果都是true。<br>然后是第一个物品，重量也是2，那么造成的结果就是，states[1][4],states[1][2],states[1][2],states[1][0]<br>然后我们发现，有两个表达式重复了，所以合并掉，其他三个因为重量小于9，所以也是true<br>不断继续，最后只需要选择最接近9还是true的就可以了。</p><p>这里演示的是c语言的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int w[5] = &#123; 0 , 2 , 3 , 4 , 5 &#125;;//商品的体积2、3、4、5</span><br><span class="line">int v[5] = &#123; 0 , 3 , 4 , 5 , 6 &#125;;//商品的价值3、4、5、6</span><br><span class="line">int bagV = 8;        //背包大小</span><br><span class="line">int dp[5][9] = &#123; &#123; 0 &#125; &#125;;        //动态规划表</span><br><span class="line"> </span><br><span class="line">for (int i = 1; i &lt;= 4; i++) &#123;</span><br><span class="line">for (int j = 1; j &lt;= bagV; j++) &#123;</span><br><span class="line">if (j &lt; w[i])</span><br><span class="line">dp[i][j] = dp[i - 1][j];</span><br><span class="line">else</span><br><span class="line">dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//动态规划表的输出</span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">for (int j = 0; j &lt; 9; j++) &#123;</span><br><span class="line">cout &lt;&lt; dp[i][j] &lt;&lt; &#x27; &#x27;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上面的方法可以求出背包问题的最优解，但还不知道这个最优解由哪些商品组成，故要根据最优解回溯找出解的组成，根据填表的原理可以有如下的寻解方式：</p><p>V(i,j)&#x3D;V(i-1,j)时，说明没有选择第i 个商品，则回到V(i-1,j)；<br>V(i,j)&#x3D;V(i-1,j-w(i))+v(i)时，说明装了第i个商品，该商品是最优解组成的一部分，随后我们得回到装该商品之前，即回到V(i-1,j-w(i))；<br>一直遍历到i＝0结束为止，所有解的组成都会找到。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hive的配置</title>
      <link href="/2022/03/10/hive%E4%B8%93%E9%A2%98/"/>
      <url>/2022/03/10/hive%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="认识hive的基本配置"><a href="#认识hive的基本配置" class="headerlink" title="认识hive的基本配置"></a>认识hive的基本配置</h1><h5 id="Metastore"><a href="#Metastore" class="headerlink" title="Metastore"></a>Metastore</h5><ol><li><p>Metastores是元数据服务，元数据的服务组件，这个组件存储着hive的元数据。<br>作用：管理metadata元数据，让客户端通过连接Metastore服务，再由metastore去<br>连接MySQL数据库存取元数据。可以间接保证数据的安全。</p></li><li><p>有了metastore服务，就可以有多个客户端同时连接，而且这些客户端不需要知道<br>MySQL数据库的用户名和密码，只需要连接metastore 服务即可。</p></li></ol><h5 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h5><p>关于数据的数据或者叫做用来描述数据的数据或者叫做信息的信息。可以理解为最小的数据单元。<br>元数据可以为数据说明其元素或属性（名称、大小、数据类型、等），或其结构（长度、字段、数据列）</p><h3 id="Metastore启动方式"><a href="#Metastore启动方式" class="headerlink" title="Metastore启动方式"></a>Metastore启动方式</h3><p>Metastore的启动方式有三种：</p><p><strong>（1）嵌入模式</strong></p><p>内嵌模式使用的是内嵌的Derby数据库来存储元数据，也不需要额外起Metastore服务。<br>数据库和Metastore服务都嵌入在主Hive Server进程中。这个是默认的，配置简单，<br>但是一次只能一个客户端连接，适用于用来实验，不适用于生产环境。</p><p>解压hive安装包 bin&#x2F;hive 启动即可使用</p><p>缺点：不同路径启动hive，每一个hive拥有一套自己的元数据，无法共享。</p><p><strong>（2）本地模式</strong></p><p>本地模式采用外部数据库来存储元数据，目前支持的数据库有：<br>MySQL、Postgres、Oracle、MS SQL Server.在这里我们使用MySQL。</p><p>本地模式不需要单独起metastore服务，用的是跟hive在同一个进程里的metastore服务。<br>也就是说当你启动一个hive 服务，里面默认会帮我们启动一个metastore线程服务。<br>hive根据hive.metastore.uris，如果为空，则为本地模式。</p><p>缺点是：每启动一次hive服务，都内置启动了一个metastore。</p><p><strong>（3）远程模式</strong></p><p>远程模式下，需要单独起metastore服务（hive –service metastore），然后每个客户端</p><p>都在配置文件里配置连接到该metastore服务。</p><p>远程模式的metastore服务和hive运行在不同的进程里。</p><p>在生产环境中，建议用远程模式来配置Hive Metastore。</p><p>在这种情况下，其他依赖hive的软件都可以通过** Metastore访问hive。**</p><p>远程模式下，需要配置hive.metastore.uris 参数来指定metastore服务运行的机器ip和端口，<br>并且需要单独手动启动metastore服务，如有多个metastore服务器，URI之间用逗号分隔。</p><h2 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h2><p>本次安装的hive版本为3.0x 基于Hadoop3.0x进行远程模式的搭建</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p><strong>基本的hadoop集群环境要确保能够正常启动</strong></p><h4 id="1-防火墙管理"><a href="#1-防火墙管理" class="headerlink" title="1.防火墙管理"></a>1.防火墙管理</h4><p><strong>(1)防火墙状态查询</strong>：systemctl status firewalld.service<br><strong>(2)防火墙关闭</strong>：systemctl stop firewalld.service<br><strong>(3)禁止防火墙开机启动</strong>：systemctl disable firewalld.service</p><h4 id="2-mysql安装配置成功"><a href="#2-mysql安装配置成功" class="headerlink" title="2.mysql安装配置成功"></a>2.mysql安装配置成功</h4><p>Mysql安装配置成功并能使用 mysql -uroot -p 进行登入</p><h4 id="3-JAVA-JDK配置"><a href="#3-JAVA-JDK配置" class="headerlink" title="3.JAVA JDK配置"></a>3.JAVA JDK配置</h4><p>JDK安装配置成功，并能查看java 版本信息</p><h4 id="4-Hadoop与hive整合"><a href="#4-Hadoop与hive整合" class="headerlink" title="4.Hadoop与hive整合"></a>4.Hadoop与hive整合</h4><p>因为Hive需要把数据存储在HDFS上，并且通过MapReduce作为执行引擎处理数据；<br>修改Hadoop中core-site.xml，并且Hadoop集群同步配置文件，重启生效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- 整合hive --&gt;</span><br><span class="line">  &lt;property&gt;  </span><br><span class="line">  &lt;name&gt;hadoop.proxyuser.root.hosts&lt;/name&gt;  </span><br><span class="line">  &lt;value&gt;*&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;  </span><br><span class="line">  &lt;name&gt;hadoop.proxyuser.root.groups&lt;/name&gt;  </span><br><span class="line">  &lt;value&gt;*&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-hive的jar包准备"><a href="#5-hive的jar包准备" class="headerlink" title="5.hive的jar包准备"></a>5.hive的jar包准备</h4><p>地址：<a href="http://archive.apache.org/dist/hive/hive-3.1.0/">http://archive.apache.org/dist/hive/hive-3.1.0/</a><br>选择apache-hive-3.1.0-bin.tar.gz 进行下载</p><h2 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h2><h5 id="上传解压安装包"><a href="#上传解压安装包" class="headerlink" title="上传解压安装包"></a>上传解压安装包</h5><ol><li>解压hive安装包<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-hive-3.1.0-bin.tar.gz  -C </span><br><span class="line">mv apache-hive-3.1.0-bin hive</span><br></pre></td></tr></table></figure></li><li>解决hadoop、hive之间guava版本差异</li></ol><p>进入hive目录 将guava-27.0-jre.jar 拷贝至lib目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf lib/guava-19.0.jar</span><br><span class="line">cp /export/server/hadoop-3.1.3/share/hadoop/common/lib/guava-27.0-jre.jar ./lib/</span><br></pre></td></tr></table></figure><ol start="3"><li>添加mysql jdbc驱动到hive安装包lib&#x2F;文件下<br>下载地址：<a href="https://maven.ityuan.com/maven2/mysql/mysql-connector-java/5.1.32">https://maven.ityuan.com/maven2/mysql/mysql-connector-java/5.1.32</a></li></ol><h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><p>可参照自己的文件存放的位置进行修改<br>cd &#x2F;export&#x2F;server&#x2F;hive&#x2F;conf&#x2F;<br>mv hive-env.sh.template hive-env.sh<br>vim hive-env.sh<br>export HADOOP_HOME&#x3D;&#x2F;export&#x2F;server&#x2F;hadoop-3.1.0<br>export HIVE_CONF_DIR&#x3D;&#x2F;export&#x2F;server&#x2F;hive&#x2F;conf<br>export HIVE_AUX_JARS_PATH&#x3D;&#x2F;export&#x2F;server&#x2F;hive&#x2F;lib</p><p>修改conf路径下的hive-site.xml</p><p>vim hive-site.xml (配置路径与mysql)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!-- 存储元数据mysql相关配置 --&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;</span><br><span class="line">        &lt;value&gt; jdbc:mysql://hadoop102:3306/hive?createDatabaseIfNotExist=true&amp;amp;useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;root&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- H2S运行绑定host --&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hive.server2.thrift.bind.host&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop102&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 远程模式部署metastore 服务地址 --&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hive.metastore.uris&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;thrift://hadoop102:9083&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 关闭元数据存储授权  --&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hive.metastore.event.db.notification.api.auth&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 关闭元数据存储版本的验证 --&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hive.metastore.schema.verification&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="初始化metadata"><a href="#初始化metadata" class="headerlink" title="初始化metadata"></a>初始化metadata</h3><p>cd &#x2F;export&#x2F;server&#x2F;hive<br>bin&#x2F;schematool -initSchema -dbType mysql -verbos<br>初始化成功会在mysql中创建74张表</p><h2 id="hiveserver2"><a href="#hiveserver2" class="headerlink" title="hiveserver2"></a>hiveserver2</h2><p>Hive发展至今，总共历经了两代客户端工具。</p><ol><li><p>第一代客户端（deprecated不推荐使用）：$HIVE_HOME&#x2F;bin&#x2F;hive, 是一个 shellUtil。<br>主要功能：一是可用于以交互或批处理模式运行Hive查询；二是用于Hive相关服务的启动，比如metastore服务。</p></li><li><p>第二代客户端（recommended 推荐使用）：$HIVE_HOME&#x2F;bin&#x2F;beeline，是一个JDBC客户端，<br>是官方强烈推荐使用的Hive命令行工具，和第一代客户端相比，性能加强安全性提高。</p></li></ol><p>Q:为什么我们要使用hiveserver2？</p><p>HiveServer2支持多客户端的并发和身份认证，旨在为开放API客户端如JDBC、ODBC提供更好的支持。</p><p>HiveServer2通过Metastore服务读写元数据。所以在远程模式下，启动HiveServer2之前<strong>必须先首先启动metastore服务</strong></p><h3 id="配置bin-x2F-hive-客户端（可选）"><a href="#配置bin-x2F-hive-客户端（可选）" class="headerlink" title="配置bin&#x2F;hive 客户端（可选）"></a>配置bin&#x2F;hive 客户端（可选）</h3><p>上传hive安装包到另一个机器上，比如node3<br>cd &#x2F;export&#x2F;server&#x2F;tar zxvf apache-hive-3.1.0-bin.tar.gzmv apache-hive-3.1.0-bin hive#</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 解决hadoop、hive之间guava版本差异</span><br><span class="line">cd /export/server/hive/rm -rf lib/guava-19.0.jarcp </span><br><span class="line">/export/server/hadoop-3.1.3/share/hadoop/common/lib/guava-27.0-jre.jar ./lib/</span><br><span class="line"></span><br><span class="line"># 修改hive环境变量文件 添加Hadoop_HOME</span><br><span class="line">cd /export/server/hive/conf</span><br><span class="line">mv hive-env.sh.template hive-env.sh</span><br><span class="line">vim hive-env.sh</span><br><span class="line">export HADOOP_HOME=/export/server/hadoop-3.1.4</span><br><span class="line"></span><br><span class="line"># 添加metastore服务地址</span><br><span class="line">cd /export/server/hive/conf/</span><br><span class="line">vim  hive-site.xml</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;   </span><br><span class="line"> &lt;name&gt;hive.metastore.uris&lt;/name&gt; </span><br><span class="line">   &lt;value&gt;thrift://hadoop102:9083&lt;/value&gt;</span><br><span class="line"> &lt;/property&gt;</span><br><span class="line">  &lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>hive经过发展，推出了第二代客户端beeline，但是beeline客户端不是直接访问metastore服务的，而是需要单独启动hiveserver2服务。<br>在hive安装的服务器上，首先启动metastore服务，然后启动hiveserver2服务。</p><h2 id="hive的使用"><a href="#hive的使用" class="headerlink" title="hive的使用"></a>hive的使用</h2><p>后台挂起 可使用jps命令查看是否开启 正常的话就是runjar<br>注意hivesever2开启后要等一段时间才可以使用 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup /export/servers/hive/bin/hive --service metastore &amp;</span><br><span class="line">nohup /export/servers/hive/bin/hive --service hiveserver2 &amp;</span><br></pre></td></tr></table></figure><p>cd 到hive的bin目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">! connect jdbc:hive2://hadoop:10000</span><br><span class="line">Enter username for jdbc:hive2://hadoop102:10000: root</span><br><span class="line">Enter password for jdbc:hive2://node1:10000: Connected to: Apache Hive (version 3.1.0)</span><br></pre></td></tr></table></figure><p>创建一个数据库<br>如果可以创建则表明成功，后续自行使用idea连接hive即可</p><h3 id="一些BUG解决方案"><a href="#一些BUG解决方案" class="headerlink" title="一些BUG解决方案"></a>一些BUG解决方案</h3><ol><li>User: root is not allowed to impersonate root(state&#x3D;08S01,code&#x3D;0)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;hadoop.proxyuser.root.hosts&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;*&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;hadoop.proxyuser.root.groups&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;*&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></li></ol><p>在hive的conf下修改配置文件hive-site.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;hive.server2.enable.doAs&lt;/name&gt;</span><br><span class="line">&lt;value&gt;false&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">端口号</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;hive.server2.thrift.port&lt;/name&gt;</span><br><span class="line">&lt;value&gt;10000&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>hdfs dfs -chmod -R 777 &#x2F;tmp</p><ol start="2"><li>Permission denied: user&#x3D;root, access&#x3D;WRITE, inode&#x3D;”&#x2F;user”:hdfs:supergroup:drwxr-xr-x</li></ol><p>众所周知，HDFS文件系统的目录基本都属于supergroup用户组，<br>所以我们就把就把用户添加到该用户组，即可解决很多权限问题，<br>例如连接Hive却无法操作的创建库、表的问题…</p><p><strong>解决hive中root权限不能写的问题</strong></p><p>1、在Linux执行如下命令增加supergroup<br>sudo groupadd supergroup</p><p>2、将用户增加到supergroup中<br>sudo usermod -a -G supergroup root</p><p>3、同步系统的权限信息到HDFS文件系统<br>hdfs dfsadmin -refreshUserToGroupsMappings</p><p>4、查看属于supergroup用户组的用户<br>grep ‘supergroup:’ &#x2F;etc&#x2F;group</p><p>重新连接 发现问题解决！</p>]]></content>
      
      
      <categories>
          
          <category> 大数据生态圈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HIVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的基本运用</title>
      <link href="/2022/03/10/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%94%A8/"/>
      <url>/2022/03/10/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="认识单链表"><a href="#认识单链表" class="headerlink" title="认识单链表"></a>认识单链表</h1><p>单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。<br>链表中的数据是以节点来表示的，每个节点的构成：data域（数据元素）+next域（下一个结点的存储位置）。<br>单链表与数组相比的最大差别是：单链表的数据元素存放在内存空间的地址是不连续的，<br>而数组的数据元素存放的地址在内存空间中是连续的，<br>这也是为什么根据索引无法像数组那样直接就能查询到数据元素。</p><h2 id="基本操作如下"><a href="#基本操作如下" class="headerlink" title="基本操作如下"></a>基本操作如下</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">public class LinkList &#123;</span><br><span class="line">    private static final LinkNode NULL = null;</span><br><span class="line">private LinkNode Head = new LinkNode();</span><br><span class="line">//先初始化一个头结点，头结点为空</span><br><span class="line">    LinkList() &#123;</span><br><span class="line">        Init_LinkNode();</span><br><span class="line">&#125;</span><br><span class="line">//内部类节点LinkNode</span><br><span class="line">    class LinkNode &#123;</span><br><span class="line"></span><br><span class="line">    int data;</span><br><span class="line"></span><br><span class="line">    LinkNode next=null;</span><br><span class="line"></span><br><span class="line">    LinkNode()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LinkNode(int elem)&#123;</span><br><span class="line"></span><br><span class="line">        data=elem;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkNode(int elem,LinkNode nextval)&#123;</span><br><span class="line"></span><br><span class="line">        data=elem;</span><br><span class="line"></span><br><span class="line">        next=nextval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LinkNode(LinkNode nextval)&#123;</span><br><span class="line"></span><br><span class="line">        next=nextval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    //1.单链表的初始化</span><br><span class="line">    public void Init_LinkNode() &#123;</span><br><span class="line">        LinkNode head = null;</span><br><span class="line">    &#125;</span><br><span class="line">//2.判断表是否为空</span><br><span class="line"> public boolean isEmpty() &#123;</span><br><span class="line">//通过判断头结点的下一结点地址是否为空，即可判断单链表是否为空</span><br><span class="line">    if(this.Head.next == null) &#123;  </span><br><span class="line">     return true; </span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //3.返回单链表的长度</span><br><span class="line">    public int Length_LinkList() &#123;</span><br><span class="line">        int j=0;</span><br><span class="line">        LinkNode tmp=Head; </span><br><span class="line">//head节点不能动，需要一个tmp辅助遍历</span><br><span class="line">        while(tmp != null) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            tmp=tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        //4.返回第i个元素</span><br><span class="line">        public LinkNode Get_LinkList(int i) &#123;</span><br><span class="line">            LinkNode p = Head;</span><br><span class="line">            int a = 0;</span><br><span class="line">            while (p.next != null &amp;&amp; a &lt; i) &#123;</span><br><span class="line">                p = p.next;</span><br><span class="line">                a++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (a == i) &#123;</span><br><span class="line">                return p;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">//5.删除第i个元素</span><br><span class="line">        public int Delete_LinkList(int i) &#123;</span><br><span class="line">                LinkNode p;</span><br><span class="line">                LinkNode s;</span><br><span class="line">            p=Get_LinkList(i-1);</span><br><span class="line">            if(p==null)&#123;</span><br><span class="line">                System.out.println(&quot;第i-1个结点不存在&quot;);</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;else if (p.next==null)&#123;</span><br><span class="line">                System.out.println(&quot;第i个结点不存在&quot;);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                s=p.next;</span><br><span class="line">                p.next=s.next;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> //6.在第i个位置插入元素</span><br><span class="line">        public int  Insert_LinkList(int i,int x) &#123;</span><br><span class="line">        LinkNode p,s;</span><br><span class="line">        p=Get_LinkList(i-1);</span><br><span class="line">            if(p==null)&#123;</span><br><span class="line">                System.out.println(&quot;参数i错误&quot;);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                s=new LinkNode();</span><br><span class="line">                s.data=x;</span><br><span class="line">                s.next=p.next;</span><br><span class="line">                p.next=s;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        //7.把表中的元素打印出来</span><br><span class="line">            public void display()&#123;</span><br><span class="line">                LinkNode tmp=Head;</span><br><span class="line">                while (tmp!=null) &#123;</span><br><span class="line">                    System.out.println(tmp.data+&quot;  &quot;);</span><br><span class="line">                    tmp=tmp.next;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="顺序表与单链表的比较"><a href="#顺序表与单链表的比较" class="headerlink" title="顺序表与单链表的比较"></a>顺序表与单链表的比较</h1><h2 id="顺序表的优点："><a href="#顺序表的优点：" class="headerlink" title="顺序表的优点："></a>顺序表的优点：</h2><p>其存储结构为随机存取结构，逻辑关系可直接用数组元素下标表示。</p><h2 id="顺序表的缺点："><a href="#顺序表的缺点：" class="headerlink" title="顺序表的缺点："></a>顺序表的缺点：</h2><p>①线性表的长度不确定，难以事先确定数组长度。<br>②存储空间必须是连续的，易造成存储空间的“碎片”现象。③插入和删除操作需要移动大量元素。</p><h2 id="单链表的优点："><a href="#单链表的优点：" class="headerlink" title="单链表的优点："></a>单链表的优点：</h2><p>①元素的存储单元是任意的，可连续也可不连续。②不需要限定长度。</p><h2 id="单链表的缺点"><a href="#单链表的缺点" class="headerlink" title="单链表的缺点"></a>单链表的缺点</h2><p>：①其查找时间复杂度为O(n)。②存放元素时需要另外开辟一个指针域的空间。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识数组</title>
      <link href="/2022/03/09/%E8%AE%A4%E8%AF%86%E6%95%B0%E7%BB%84/"/>
      <url>/2022/03/09/%E8%AE%A4%E8%AF%86%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h3 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h3><p>其实所谓的数组指的就是一组相关类型的变量集合，并且这些变量可以按照统一的方式进行操作。数组本身属于引用数据类型，那么既然是引用数据类型，<br>这里面实际又会牵扯到内存分配，而数组的定义语法有如下两类。</p><p>数组动态初始化：<br>声明并开辟数组：<br>数据类型 [] 数组名称 &#x3D; new 数据类型[长度];<br>数据类型 [] 数组名称 &#x3D; new 数据类型[长度];<br>分布进行数组空间开辟（实例化）<br>| Tables | Are |<br>| ————- |:————-?<br>| 声明数组： | 数组类型 数组名称[] &#x3D; null; | | | 数组类型 [] 数组名称 &#x3D;null; | | 开辟数组空间： | 数组名称 &#x3D;new&#96; 数组类型[长度]; |<br>那么当数组开辟空间之后，就可以采用如下的方式的操作：</p><p>数组的访问通过索引完成，即：“数组名称[索引]”，但是需要注意的是，数组的索引从0开始，<br>所以索引的范围就是0 ~ 数组长度-1，例如开辟了3个空间的数组，<br>所以可以使用的索引是：0,1,2，如果此时访问的时候超过了数组的索引范围，<br>会产生java.lang.ArrayIndexOutOfBoundsException 异常信息；<br>当我们数组采用动态初始化开辟空间后，数组里面的每一个元素都是该数组对应数据类型的默认值；<br>数组本身是一个有序的集合操作，所以对于数组的内容操作往往会采用循环的模式完成，数组是一个有限的数据集合，所以应该使用 for 循环。<br>在 Java 中提供有一种动态取得数组长度的方式：数组名称.length；</p><h2 id="1-1认识数组"><a href="#1-1认识数组" class="headerlink" title="1.1认识数组"></a>1.1认识数组</h2><p>数组Array，标志是[ ] ,用于储存多个相同类型数据的集合<br>想要获取数组中的元素值，可以通过脚标（下标）来获取<br>数组下标是从0开始的,下标的最大值是数组的长度减1</p><h2 id="1-2-创建数组"><a href="#1-2-创建数组" class="headerlink" title="1.2 创建数组"></a>1.2 创建数组</h2><p>数组的创建方式一般分为动态初始化和静态初始化</p><p>动态初始化<br>int[] a &#x3D; new int[5];<br>静态初始化<br>int[] b &#x3D; new int[]{1,2,3,4,5};<br>int[] c &#x3D; {1,2,3,4,5};</p><h2 id="1-3-创建数组过程分析"><a href="#1-3-创建数组过程分析" class="headerlink" title="1.3 创建数组过程分析"></a>1.3 创建数组过程分析</h2><p>程序创建数组 int[] a &#x3D; new int[5]; 时发生了什么?</p><p>1.在内存中开辟连续的空间,用来存放数据,长度是5<br>2.给数组完成初始化过程,给每个元素赋予默认值,int类型默认值是0<br>3.数组完成初始化会分配一个唯一的地址值<br>4.把唯一的地址值交给引用类型的变量a去保存</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
