<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>搭建mybatis指南</title>
      <link href="/2022/03/27/%E6%90%AD%E5%BB%BAmybatis%E6%8C%87%E5%8D%97/"/>
      <url>/2022/03/27/%E6%90%AD%E5%BB%BAmybatis%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="一、搭建MyBatis"><a href="#一、搭建MyBatis" class="headerlink" title="一、搭建MyBatis"></a>一、<strong>搭建</strong>MyBatis</h1><h2 id="1-开发环境"><a href="#1-开发环境" class="headerlink" title="1.开发环境"></a>1.开发环境</h2><p>IDEA version : 2021.2.2</p><p>mysql version ：8.0.23</p><p>mybatis version : 3.5.2</p><p>maven version : 3.5.7</p><h2 id="2-创建maven工程"><a href="#2-创建maven工程" class="headerlink" title="2.创建maven工程"></a>2.创建maven工程</h2><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220327134903258.png"></p><p>next-&gt;Name(存放路径)-&gt;groupID(com.lyc.mybatis)-&gt;finish</p><p>加入依赖</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.11<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.5.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>8.0.25<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.13.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-创建数据库连接信息配置文件"><a href="#3-创建数据库连接信息配置文件" class="headerlink" title="3.创建数据库连接信息配置文件"></a>3.创建数据库连接信息配置文件</h2><p>在项目中的src&#x2F;main&#x2F;resources目录下创建db.properties</p><pre class="line-numbers language-sql"><code class="language-sql">driver <span class="token operator">=</span> com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>cj<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>Driverurl <span class="token operator">=</span> jdbc:mysql:<span class="token comment" spellcheck="true">//localhost:3306/mybatis?serverTimezone=UTC&amp;\</span>            characterEncoding<span class="token operator">=</span>utf8<span class="token operator">&amp;</span>useUnicode<span class="token operator">=</span><span class="token boolean">true</span><span class="token operator">&amp;</span>useSSL<span class="token operator">=</span><span class="token boolean">false</span>username <span class="token operator">=</span> rootpassword <span class="token operator">=</span> <span class="token number">123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-创建MyBatis的核心配置文件"><a href="#4-创建MyBatis的核心配置文件" class="headerlink" title="4.创建MyBatis的核心配置文件"></a>4.创建MyBatis的核心配置文件</h2><p>在项目中的src&#x2F;main&#x2F;resources目录下创建MyBatis的核心配置文件</p><p>用于项目的环境配置，如数据库连接相关配置等。建议命名为mybatis-config.xml</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?></span> <span class="token doctype">&lt;!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>db.properties<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!--设置连接数据库的环境--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environments</span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environment</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManager</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POOLED<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driver<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${driver}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${url}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${username}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${password}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataSource</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environment</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environments</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--引入映射文件--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mappers/UserMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数详细：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?></span>  xml的版本号<span class="token doctype">&lt;!DOCTYPE configuration  mybatis中的约束  dtd文件        PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"></span>configuration 根标签environments 可嵌套多个单数标签 <span class="token comment" spellcheck="true">&lt;!--设置连接数据库的环境--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--引入映射文件--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManager</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> 事务的管理方式以jdbc的方式进行管理<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POOLED<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> 数据库连接池 下一次使用直接调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-创建POJO实体"><a href="#5-创建POJO实体" class="headerlink" title="5.创建POJO实体"></a>5.创建POJO实体</h2><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220327143310015.png"></p><p>这是我们的表中的数据 跟实体类的属性要一致（默认的映射规则）-&gt;为属性名赋值</p><p>在src&#x2F;main&#x2F;java 目录下创建com.lyc.mybatis.pojo包 在pojo包下创建User类 该类用于封装User对象的属性 如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> uid<span class="token punctuation">;</span>    <span class="token keyword">private</span> String uname<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> uage<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getUid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> uid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUid</span><span class="token punctuation">(</span><span class="token keyword">int</span> uid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>uid <span class="token operator">=</span> uid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getUname</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> uname<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUname</span><span class="token punctuation">(</span>String uname<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>uname <span class="token operator">=</span> uname<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getUage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> uage<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUage</span><span class="token punctuation">(</span><span class="token keyword">int</span> uage<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>uage <span class="token operator">=</span> uage<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-创建mapper接口"><a href="#6-创建mapper接口" class="headerlink" title="6.创建mapper接口"></a>6.创建mapper接口</h2><p>MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要</p><p>提供实现类。</p><p>在src&#x2F;main&#x2F;java&#x2F;com.lyc.mybatis下创建mapper文件夹</p><p>在文件夹下创建UserMapper接口</p><pre><code>int insertUser();</code></pre><h2 id="7-创建映射文件UserMapper-xml"><a href="#7-创建映射文件UserMapper-xml" class="headerlink" title="7.创建映射文件UserMapper.xml"></a>7.创建映射文件UserMapper.xml</h2><p>在src&#x2F;main&#x2F;resources下创建一个mappers文件夹 在文件下创建映射文件UserMapper.xml</p><p>用于配置真正的sql与java对象之间的映射  </p><p><strong>1.MyBatis映射文件用于编写SQL，访问以及操作表中的数据</strong></p><p><strong>2、MyBatis中可以面向接口操作数据，要保证两个一致：</strong> </p><p>a&gt;mapper接口的全类名和映射文件的命名空间（namespace）保持一致</p><p>b&gt;mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token comment" spellcheck="true">&lt;!--sql与java之间的映射 --></span><span class="token doctype">&lt;!DOCTYPE mapper        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.lyc.mybatis.mapper.UserMapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>insertUser<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        insert into users values (4,'王五',19)    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>映射文件的命名规则：</p><p>表所对应的实体类的类名+Mapper.xml</p><p>例如：表t_user，映射的实体类为Users，所对应的映射文件为UsersMapper.xml</p><h2 id="8-测试"><a href="#8-测试" class="headerlink" title="8.测试"></a>8.测试</h2><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220327152644515.png"></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> com<span class="token punctuation">.</span>lyc<span class="token punctuation">.</span>mybatis<span class="token punctuation">.</span>mapper<span class="token punctuation">.</span>UserMapper<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Resources<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>session<span class="token punctuation">.</span>SqlSession<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>session<span class="token punctuation">.</span>SqlSessionFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>session<span class="token punctuation">.</span>SqlSessionFactoryBuilder<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStream<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapperTest01</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">TestMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//读取MyBatis的核心配置文件 InputStream is = Resources.g</span>        InputStream resourceAsStream <span class="token operator">=</span>   Resources<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"mybatis-config.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">////通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象</span>        SqlSessionFactoryBuilder sqlSessionFactoryBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SqlSessionFactory sqlSessionFactory <span class="token operator">=</span> sqlSessionFactoryBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>resourceAsStream<span class="token punctuation">)</span><span class="token punctuation">;</span>        SqlSession session <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                UserMapper mapper <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>UserMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配 映射文件中的SQL标            签，并执行标签中的SQL语句</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">insertUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//事务提交</span>        session<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result"</span><span class="token operator">+</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> ORM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql中的聚合函数易混淆的概念</title>
      <link href="/2022/03/20/mysql%E4%B8%AD%E7%9A%84%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/03/20/mysql%E4%B8%AD%E7%9A%84%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h1><p>与其他查询不同，普通的查询做的都是横向查询，它们都是根据条件一行一行的进行判断，而使用聚合函数查询是纵向查询，</p><p>它是对一列的值进行计算，然后返回一个单一的值；另外聚合函数会忽略空值。</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/11.png"></p><h3 id="从案例引出问题："><a href="#从案例引出问题：" class="headerlink" title="从案例引出问题："></a>从案例引出问题：</h3><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220320154124681.png"></p><p>我们基于以上表作为查询：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> product<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 返回18 没有任何问题</span><span class="token keyword">select</span> pid<span class="token punctuation">,</span><span class="token function">min</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span> <span class="token keyword">from</span> product <span class="token punctuation">;</span><span class="token keyword">select</span> pid<span class="token punctuation">,</span><span class="token function">max</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span> <span class="token keyword">from</span> product <span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 此时不报错 pid显示结果都为1  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Q；为什么会产生这种现象？</p><p>因为聚合函数是对列进行操作和pid字段没有产生联系 ，系统pid默认的值全为1</p><p>此时我们可以考虑子查询＋AND 来解决类似hive里的窗口函数的功能</p><pre><code>select pid ,price from product where price = (select min(price) from product);</code></pre><p>聚合函数一般会和分组查询group by 结合使用</p><p>格式：</p><p>select 字段1,字段2… from 表名 group by 分组字段 having 分组条件;</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 1 统计各个分类商品的个数</span><span class="token keyword">select</span> category_id <span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> product <span class="token keyword">group</span> <span class="token keyword">by</span> category_id <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220320160246892.png"></p><p>执行结果如上：</p><p>执行顺序是先分组 再进行count聚合  </p><p>注意：如果要进行分组的话，则SELECT子句之后，只能出现分组的字段和统计函数，其他的字段不能出现</p><h3 id="having与where的区别"><a href="#having与where的区别" class="headerlink" title="having与where的区别"></a>having与where的区别</h3><ul><li><p>分组之后对统计结果进行筛选的话必须使用having，不能使用where</p></li><li><p>where子句用来筛选 FROM 子句中指定的操作所产生的   行 </p></li><li><p>group  by  子句用来分组 WHERE 子句的输出。 </p></li><li><p>having 子句用来从分组的结果中筛选行</p></li></ul><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> category_id <span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> product <span class="token keyword">where</span> price<span class="token operator">></span><span class="token number">300</span> <span class="token keyword">group</span> <span class="token keyword">by</span> category_id <span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">select</span> category_id <span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> product <span class="token keyword">group</span> <span class="token keyword">by</span> category_id <span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 思考以上语句哪条会有问题？</span><span class="token comment" spellcheck="true">-- 答案是都没问题 where首先把不满足的行去掉后进行分组，筛选出特定的组 </span><span class="token comment" spellcheck="true">-- 另一个也是将条件不满足的筛选掉 只不过是分组后进行 顺序问题</span><span class="token comment" spellcheck="true">-- 执行顺序where>group by>count(*) > having </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="一些注意的点"><a href="#一些注意的点" class="headerlink" title="一些注意的点"></a>一些注意的点</h3><p>mysql 5.6环境下除了count(*)为特例（不忽略null值）外，其余聚集函数确实是忽略null值</p><p>聚合函数默认忽略字段为null的记录 要想列值为null的记录也参与计算，必须使用ifnull函数对null值做替换  这里不做过多演示</p><p>使用Group By子句返回的组没有特定的顺序，可以使用Order By子句指定次序。</p><p>group by和order by连用的确会出现问题</p><h4 id="Group-by中子查询order-by排序失效问题分析"><a href="#Group-by中子查询order-by排序失效问题分析" class="headerlink" title="Group by中子查询order by排序失效问题分析"></a>Group by中子查询order by排序失效问题分析</h4><p>依然要考虑执行顺序</p><p><strong>获取sql分组中id最大的记录</strong></p><p>select id,name from (select id,name from tt order by id desc) as t group by name</p><p>从from开始执行顺序   group by的执行顺序&gt; select  每个组默认取了第一条数据。</p><pre><code>// 表数据如下：id,name1,name12,name13,name24,name2select id,name from (select id,name from tt order by id desc) as t group by name// 输出结果如下：id,name1,name13,name2</code></pre><p>这是为什么呢？因为mysql 5.6之后版本对排序的sql解析做了优化，子查询中的排序是会被忽略的，所以上面的order by id desc未起到作用。如果子语句中排序不做优化那不就可以了么，查阅资料发现可以在子语句中加上limit来避免这种优化（加上limit相当于临时表限定了取值范围不会进行优化，如果是全表的话就被优化掉了）。</p><p>正确写法：</p><pre><code>// 加上limitselect id,name from (select id,name from tt order by id desc limit 1024) as t group by name // 输出结果如下：id,name2,name14,name2</code></pre>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 聚合函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList底层结构和源码分析</title>
      <link href="/2022/03/19/ArrayList%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2022/03/19/ArrayList%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h1><p>1）允许添加任意的元素 包括null 多个</p><p>2） ArrayList是由数组来实现数据存储的</p><p>3）Array在多线程中是不安全的 建议使用vector</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>数组是数据结构基本的数据结构 java封装了一系列数组的方法</p><p>数组中存储的内存是连续的 插入和删除困难 查询方便</p><ul><li>ArrayList中维护了一个Object类型的数组elementData</li><li>无参构造器：自动扩容机制 ele-&gt;0（default）-&gt;10（First add）-&gt;15(second add)-&gt;15x1.5-&gt;15x1.5x1.5</li><li>有参构造器：指定大小（size）-&gt;size*1.5(First add) -&gt; sizex1.5X1.5(second add)</li></ul><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><ul><li>Tip：英语对于看源码和理解有一定的帮助</li></ul><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h4><pre class="line-numbers language-java"><code class="language-java">     <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建指定长度的object数组</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//空数组</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>            <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将集合转换成数组</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> ArrayList<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//如果不是object数组类型</span>                elementData <span class="token operator">=</span> a<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> size<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//拷贝一下</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// replace with empty array.</span>            elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * This helper method split out from add(E) to keep method * bytecode size under 35 (the -XX:MaxInlineSize default value), * which helps when add(E) is called in a C1-compiled loop. */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        elementData <span class="token operator">=</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    size <span class="token operator">=</span> s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return {@code true} (as specified by {@link Collection#add}) */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//改进后的直接自增</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException {@inheritDoc} */</span><span class="token comment" spellcheck="true">//指定位置添加</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> s<span class="token punctuation">;</span>    Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> size<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span>elementData <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>elementData<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>        elementData <span class="token operator">=</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将index之后的所有元素移动一位</span>    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                     elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                     s <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>    size <span class="token operator">=</span> s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//扩容的入口方法 DEFAULTCAPACITY_EMPTY_ELEMENTDATA  默认为10</span><span class="token comment" spellcheck="true">//判断是你的值大还是它的值大 就返回你的值</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> elementData<span class="token punctuation">.</span>length            <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA                 <span class="token operator">&amp;&amp;</span> minCapacity <span class="token operator">&lt;=</span> DEFAULT_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            modCount<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//数组扩容方法</span>   <span class="token keyword">private</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> elementData <span class="token operator">!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> ArraysSupport<span class="token punctuation">.</span><span class="token function">newLength</span><span class="token punctuation">(</span>oldCapacity<span class="token punctuation">,</span>                    minCapacity <span class="token operator">-</span> oldCapacity<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* minimum growth */</span>                    oldCapacity <span class="token operator">>></span> <span class="token number">1</span>           <span class="token comment" spellcheck="true">/* preferred growth */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">grow</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//第一次其实是  0*any=0    </span><span class="token comment" spellcheck="true">//用0.5倍来扩容</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>modCount++;用来记录修改的记录</p><pre><code>return elementData = Arrays.copyOf(elementData, newCapacity);</code></pre><p>进行扩容</p><p>使用扩容机制来确定扩容到多大</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper的基本介绍</title>
      <link href="/2022/03/19/zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/03/19/zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Zookeeper："><a href="#Zookeeper：" class="headerlink" title="Zookeeper："></a>Zookeeper：</h1><p>官方文档上这么解释zookeeper，它是一个分布式服务框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：<strong>统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理</strong>。  </p><p>上面的解释有点抽象，简单来说zookeeper&#x3D;文件系统+监听通知机制。  </p><p>每个子目录项如 NameService 都被称作为 znode(目录节点)，和文件系统一样，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode，唯一的不同在于znode是可以存储<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE&spm=1001.2101.3001.7020">数据</a>的。</p><h4 id="四种类型的znode："><a href="#四种类型的znode：" class="headerlink" title="四种类型的znode："></a>四种类型的znode：</h4><ul><li><h5 id="PERSISTENT-持久化目录节点"><a href="#PERSISTENT-持久化目录节点" class="headerlink" title="PERSISTENT-持久化目录节点"></a>PERSISTENT-持久化目录节点</h5></li></ul><p>客户端与zookeeper断开连接后，该节点依旧存在</p><ul><li><h5 id="PERSISTENT-SEQUENTIAL-持久化顺序编号目录节点"><a href="#PERSISTENT-SEQUENTIAL-持久化顺序编号目录节点" class="headerlink" title="PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点"></a>PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点</h5></li></ul><p>客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号</p><ul><li><h5 id="EPHEMERAL-临时目录节点"><a href="#EPHEMERAL-临时目录节点" class="headerlink" title="EPHEMERAL-临时目录节点"></a>EPHEMERAL-临时目录节点</h5></li></ul><p>客户端与zookeeper断开连接后，该节点被删除</p><ul><li><h5 id="EPHEMERAL-SEQUENTIAL-临时顺序编号目录节点"><a href="#EPHEMERAL-SEQUENTIAL-临时顺序编号目录节点" class="headerlink" title="EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点"></a>EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点</h5></li></ul><p>客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</p><h4 id="监听通知机制"><a href="#监听通知机制" class="headerlink" title="监听通知机制"></a>监听通知机制</h4><p>客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。</p><p>就这么简单，下面我们看看Zookeeper能做点什么呢？</p><p>zookeeper功能非常强大，可以实现诸如<a href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F&spm=1001.2101.3001.7020">分布式</a>应用配置管理、统一命名服务、状态同步服务、集群管理等功能，我们这里拿比较简单的分布式应用配置管理为例来说明。</p><p>假设我们的程序是分布式部署在多台机器上，如果我们要改变程序的配置文件，需要逐台机器去修改，非常麻烦，现在把这些配置全部放到zookeeper上去，保存在 zookeeper 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到 zookeeper 的通知，然后从 zookeeper 获取新的配置信息应用到系统中。</p><h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><p>先给自己选票+1；后面再根据myid开始选票；</p><ul><li><p>崩溃恢复：主要就是Leader选举过程。</p></li><li><p>数据同步：Leader服务器与其他服务器进行数据同步。</p></li><li><p>消息广播：Leader服务器将数据发送给其他服务器。</p></li></ul><p>Q:集群中为什么要有主节点</p><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，</p><p>其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点</p><h2 id="leader-选举过程"><a href="#leader-选举过程" class="headerlink" title="leader 选举过程"></a>leader 选举过程</h2><p>有两种情况会发起Leader选举：</p><ol><li><p>服务器启动的时候</p></li><li><p>服务器运行的时候当Leader宕机</p></li></ol><h4 id="第一次选举规则："><a href="#第一次选举规则：" class="headerlink" title="第一次选举规则："></a><strong>第一次选举规则：</strong></h4><p>投票过半数时，id大的胜出</p><h4 id="第二次选举规则："><a href="#第二次选举规则：" class="headerlink" title="第二次选举规则："></a><strong>第二次选举规则：</strong></h4><p>Epoch 大的直接胜出</p><p>若相同 ID 大的直接胜出</p><p>事物id相同 服务器id大的胜出</p><h3 id="Q-生产集群安装多少台zookeeper合适："><a href="#Q-生产集群安装多少台zookeeper合适：" class="headerlink" title="Q:生产集群安装多少台zookeeper合适："></a>Q:生产集群安装多少台zookeeper合适：</h3><p>10台服务器：3台zk;</p><p>20台：5台zk</p><p>100台：11台zk</p><p>服务器台数多的时候，可靠性比较高 坏处：提高通信延时</p><p>paxos算法：一种消息传递且具有高度容错特性的一致性算法</p><h3 id="Q-Zookeeper-怎么保证主从节点的状态同步？"><a href="#Q-Zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="Q:Zookeeper 怎么保证主从节点的状态同步？"></a>Q:Zookeeper 怎么保证主从节点的状态同步？</h3><p>Zookeeper 的核心是原子广播机制，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。</p><p>paxos算法解决的问题：就是如何快速在一个分布式系统中对某一个数据进行达成一致，且保证不论发生任何异常</p><p>都不会破坏系统的一致性</p><p>例如：机器宕机</p>]]></content>
      
      
      <categories>
          
          <category> 大数据生态圈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于super关键字和this的区别</title>
      <link href="/2022/03/17/%E5%85%B3%E4%BA%8Esuper%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8Cthis%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/03/17/%E5%85%B3%E4%BA%8Esuper%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8Cthis%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="一、super-与-this-用法"><a href="#一、super-与-this-用法" class="headerlink" title="一、super 与 this 用法"></a>一、super 与 this 用法</h2><h4 id="关于super"><a href="#关于super" class="headerlink" title="关于super"></a>关于super</h4><ol><li><p>主要存在于子类方法中，用于指向子类对象中父类对象。</p></li><li><p>调用父类的属性和方法</p></li><li><p>访问父类的构造函数</p></li></ol><ul><li><p>关于super你首先需要明白的是，如果父类和子类都有一个同名方法</p><p> 在没有重写的情况下，优先调用的是父类的方法</p></li><li><p>只有重写后才会优先调用子类的 这时候就可以使用super关键字来调用</p></li><li><p>super（形参列表）的使用，必须声明在<a href="https://so.csdn.net/so/search?q=%E5%AD%90%E7%B1%BB&spm=1001.2101.3001.7020">子类</a>构造器的首行。</p></li></ul><p><strong>例子</strong></p><p>我们可以注意到父类和子类都有相同的成员变量age，（super.age）就是访问的是Person类中的age </p><p>如果不加super 就近原则就是Student类的age</p><pre><code>class Person &#123;    int age = 12;&#125;class Student extends Person &#123;    int age = 18;    void display() &#123;        System.out.println(&quot;学生年龄：&quot; + super.age);    &#125;&#125;class Test &#123;    public static void main(String[] args) &#123;        Student stu = new Student();        stu.display();    &#125;&#125;</code></pre><h4 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h4><p>​    1 this相当于是指向当前对象本身</p><p>​    2 形参与成员变量重名，用this来区分</p><p>​    3 this关键字也可以在构造函数中调用其他构造函数 但是必须定义在构造函数的第一行 这一点与super的用法非常相似  this（）调用其他构造函数时，必须放在定义的构造函数第一行。如果随意放在普通方法的第一行，则立马报错</p><p><strong>例子</strong></p><pre><code>class Person&#123;    private String name;    private int age;    Person(String name)    &#123;        //成员变量和局部变量重名，可以用关键字this区分        this.name = name;    &#125;    public void speak()    &#123;        //输出时，会默认为成员增加this关键字，用来代表具体对象的数据        System.out.println(this.name+&quot;：&quot;+this.age);    &#125;&#125;</code></pre><pre><code>class Person&#123;    private String name;    private int age;    Person()    &#123;        name = &quot;baby&quot;;        age = 1;        System.out.println(&quot;Person run&quot;);    &#125;    Person(String name)    &#123;        //成员变量和局部变量重名，可以用关键字this区分        this.name = name;    &#125;    Person(String name,int age)    &#123;        //调用其他构造函数时，只能定义在构造函数的第一行，因为初始化动作要先执行        this();        this.name = name;        this.age = age;    &#125;    public void speak()    &#123;        System.out.println(this.name+&quot;：&quot;+this.age);    &#125; &#125;  class ThisDemo &#123;    public static void main(String[] args)     &#123;        Person p = new Person(&quot;小强&quot;,10);        p.speak();    &#125;&#125;//输出结果Person run 小强：10</code></pre><p> <strong>虽然我们在 Person(String name,int age) 构造函数中调用了 Person() 构造函数，但是最后的输出结果，仅输出了 Person run ，成员变量的内容还是我们在新建对象时，传递进去的参数，并不是 Person() 中初始化的内容。成员变量传进去的参数所被覆盖了</strong></p><h4 id="二、关于一些细节"><a href="#二、关于一些细节" class="headerlink" title="二、关于一些细节"></a>二、关于一些细节</h4><p>为了看的更直观 我们直接用代码进行说明</p><pre><code>public class Animal &#123;    public Animal() &#123;        System.out.println(&quot;Animal类的无参数构造函数执行&quot;);    &#125;&#125;class Cat extends Animal &#123;    public Cat() &#123;        System.out.println(&quot;Cat类的无参数构造函数执行&quot;);        &#125;    &#125;    class Test &#123;        public static void main(String[] args) &#123;            Cat c1 = new Cat();        &#125;    &#125;// 在实例化对象的时候 直接就把构造器的方法全执行了//上面的隐藏了一个super(); 你写不写都行 但为了看的方便我们还是需要在子类的构造器中写一下的</code></pre><p>那么又引出一个问题 父类有多个构造器我们怎么知道super调用的是哪个?</p><p>1.父类是无参构造器 super（）；</p><p>2.父类是有参构造器super(name,age); 调用相同形参的</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于HashList的深入探究</title>
      <link href="/2022/03/15/%E5%85%B3%E4%BA%8EHashList%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6/"/>
      <url>/2022/03/15/%E5%85%B3%E4%BA%8EHashList%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/image-20220315223146221.png"></p><h2 id="HashSet本质是HashMap"><a href="#HashSet本质是HashMap" class="headerlink" title="HashSet本质是HashMap"></a>HashSet本质是HashMap</h2><p>HashSet是一个不允许有重复元素的集合。</p><p>它实现了set接口 可以存放null值，但是只能有一个null</p><p>和ArrayList不同的是：HashSet 是无序的，即不会记录插入的顺序。</p><p>HashSet是非同步的。如果多个线程同时访问一个<a href="https://so.csdn.net/so/search?q=%E5%93%88%E5%B8%8C&spm=1001.2101.3001.7020">哈希</a> set，<br>而其中至少一个线程修改了该 set，那么它必须 保持外部同步。这通常是通过对自然封装该 set 的对象执行同步操作来完成的。<br>如果不存在这样的对象，则应该使用 Collections.synchronizedSet 方法来“包装” set。最好在创建时完成这一操作，<br>以防止对该 set 进行意外的不同步访问：</p><pre><code>HashSet set = new HashSet();//1.add方法返回的是一个boolean值 添加成功则为true 失败为false//2.remove的方法指定删除对象</code></pre><h2 id="HASHMAP"><a href="#HASHMAP" class="headerlink" title="HASHMAP"></a>HASHMAP</h2><p>HashMap底层是数组+链表+红黑树</p><p><img src="https://raw.githubusercontent.com/kkl-opp/lucky/main/20160605101246837.png"></p><h3 id="数组元素Node-lt-K-V-gt-实现了Entry接口"><a href="#数组元素Node-lt-K-V-gt-实现了Entry接口" class="headerlink" title="数组元素Node&lt;K,V&gt;实现了Entry接口"></a>数组元素Node&lt;K,V&gt;实现了Entry接口</h3><pre><code>//Node是单向链表，它实现了Map.Entry接口static class Node&lt;k,v&gt; implements Map.Entry&lt;k,v&gt; &#123;    final int hash;    final K key;    V value;    Node&lt;k,v&gt; next;    //构造函数Hash值 键 值 下一个节点    Node(int hash, K key, V value, Node&lt;k,v&gt; next) &#123;        this.hash = hash;        this.key = key;        this.value = value;        this.next = next;    &#125;     public final K getKey()        &#123; return key; &#125;    public final V getValue()      &#123; return value; &#125;    public final String toString() &#123; return key + = + value; &#125;     public final int hashCode() &#123;        return Objects.hashCode(key) ^ Objects.hashCode(value);    &#125;     public final V setValue(V newValue) &#123;        V oldValue = value;        value = newValue;        return oldValue;    &#125;    //判断两个node是否相等,若key和value都相等，返回true。可以与自身比较为true    public final boolean equals(Object o) &#123;        if (o == this)            return true;        if (o instanceof Map.Entry) &#123;            Map.Entry&lt;!--?,?--&gt; e = (Map.Entry&lt;!--?,?--&gt;)o;            if (Objects.equals(key, e.getKey()) &amp;&amp;                Objects.equals(value, e.getValue()))                return true;        &#125;        return false;    &#125;</code></pre><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><pre><code>//红黑树static final class TreeNode&lt;k,v&gt; extends LinkedHashMap.Entry&lt;k,v&gt; &#123;    TreeNode&lt;k,v&gt; parent;  // 父节点    TreeNode&lt;k,v&gt; left; //左子树    TreeNode&lt;k,v&gt; right;//右子树    TreeNode&lt;k,v&gt; prev;    // needed to unlink next upon deletion    boolean red;    //颜色属性    TreeNode(int hash, K key, V val, Node&lt;k,v&gt; next) &#123;        super(hash, key, val, next);    &#125;     //返回当前节点的根节点    final TreeNode&lt;k,v&gt; root() &#123;        for (TreeNode&lt;k,v&gt; r = this, p;;) &#123;            if ((p = r.parent) == null)                return r;            r = p;        &#125;    &#125;</code></pre><p>HashMap有四个构造函数可供我们使用</p><pre><code>//默认无参构造，指定一个默认的加载因子public HashMap() &#123;    this.loadFactor = DEFAULT_LOAD_FACTOR; &#125;//可指定容量的有参构造，但是需要注意当前我们指定的容量并不一定就是实际的容量，下面会说public HashMap(int initialCapacity) &#123;    //同样使用默认加载因子    this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;//可指定容量和加载因子，但是笔者不建议自己手动指定非0.75的加载因子public HashMap(int initialCapacity, float loadFactor) &#123;    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                           initialCapacity);    if (initialCapacity &gt; MAXIMUM_CAPACITY)        initialCapacity = MAXIMUM_CAPACITY;    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                                           loadFactor);    this.loadFactor = loadFactor;    //这里就是把我们指定的容量改为一个大于它的的最小的2次幂值，如传过来的容量是14，则返回16    this.threshold = tableSizeFor(initialCapacity);&#125;//可传入一个已有的mappublic HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;    this.loadFactor = DEFAULT_LOAD_FACTOR;    putMapEntries(m, false);&#125;//把传入的map里边的元素都加载到当前mapfinal void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;    int s = m.size();    if (s &gt; 0) &#123;        if (table == null) &#123; // pre-size            float ft = ((float)s / loadFactor) + 1.0F;            int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?                     (int)ft : MAXIMUM_CAPACITY);            if (t &gt; threshold)                threshold = tableSizeFor(t);        &#125;        else if (s &gt; threshold)            resize();        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;            K key = e.getKey();            V value = e.getValue();    putVal(hash(key), key, value, false, evict);        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dp动态规划</title>
      <link href="/2022/03/13/dp%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/"/>
      <url>/2022/03/13/dp%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划算法（Dynamic-Programming）"><a href="#动态规划算法（Dynamic-Programming）" class="headerlink" title="动态规划算法（Dynamic Programming）"></a>动态规划算法（Dynamic Programming）</h2><ol><li><p>是将复杂问题拆分成子问题，并在子问题的基础上，求解复杂问题，子问题之间不是独立的，而是相互依存的。<br>动态规划算法有两种实现形式：递归，非递归</p></li><li><p>动态规划是求解决策过程最优化的数学方法。利用各个阶段之间的关系，逐个求解，最终求得全局最优解，<br>需要确认原问题与子问题、动态规划状态、边界状态、边界状态结值、状态转移方程。</p></li></ol><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>在解决问题之前，为描述方便，首先定义一些变量：Vi表示第 i 个物品的价值，<br>Wi表示第 i 个物品的体积，定义V(i,j)：<br>当前背包容量 j，前 i 个物品最佳组合对应的价值，<br>同时背包问题抽象化（X1，X2，…，Xn，其中 Xi 取0或1，表示第 i 个物品选或不选）。</p><p>1、建立模型，即求max(V1X1+V2X2+…+VnXn)；</p><p>2、寻找约束条件，W1X1+W2X2+…+WnXn&lt;capacity；</p><p>3、寻找递推关系式，面对当前商品有两种可能性：</p><p>包的容量比该商品体积小，装不下，此时的价值与前i-1个的价值是一样的，即V(i,j)&#x3D;V(i-1,j)；<br>还有足够的容量可以装该商品，但装了也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即V(i,j)&#x3D;max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝。</p><p>首先假设每个物品重量是 2 2 4 6 3,我们假设 i 表示将要决策第几个物品是否装入背包，cw表示当前背包中物品的总重量<br>，然后用(i,cw)。比如，(2,2)表示将要决策第2个物品是否要装入背包，决策前，背包的总重为2.</p><p>我们可以从递归树明显的看出，有些子问题的求解是重复的，重复的计算必然会造成性能的丢失，如果我们能保留之前的结果，<br>计算之前先检索一下，如果有计算过，那么直接拿过来用，肯定会提升一下性能。</p><p>首先将整体求解分为n个阶段，每个阶段会决策一个物品是否放到包里。<br>不论放入还是不放入，背包的重量假设都造成了变化，而这些不同的变化，也就对应着递归树的节点<br>合并重复的节点，避免节点指数级增长<br>基于这一层的节点，推导出下一层的状态集合<br>然后用上面的思路，代入到0-1背包问题中做一个思路引导：</p><p>首先我们创建一个布尔类型的二维数组states[n][w]，记录每个节点的不同状态。n代表第n个物品，w代表背包能承受的最大质量。<br>第0个(假设物品序列从0开始计算)物品的重量是2，放入，就是states[0][2]，不放入，就是states[0][0]，但是因为最大重量w是9，所以上面两个表达式的结果都是true。<br>然后是第一个物品，重量也是2，那么造成的结果就是，states[1][4],states[1][2],states[1][2],states[1][0]<br>然后我们发现，有两个表达式重复了，所以合并掉，其他三个因为重量小于9，所以也是true<br>不断继续，最后只需要选择最接近9还是true的就可以了。</p><p>这里演示的是c语言的代码</p><pre><code>#include&lt;iostream&gt;using namespace std;#include &lt;algorithm&gt; int main()&#123;    int w[5] = &#123; 0 , 2 , 3 , 4 , 5 &#125;;            //商品的体积2、3、4、5    int v[5] = &#123; 0 , 3 , 4 , 5 , 6 &#125;;            //商品的价值3、4、5、6    int bagV = 8;                            //背包大小    int dp[5][9] = &#123; &#123; 0 &#125; &#125;;                    //动态规划表     for (int i = 1; i &lt;= 4; i++) &#123;        for (int j = 1; j &lt;= bagV; j++) &#123;            if (j &lt; w[i])                dp[i][j] = dp[i - 1][j];            else                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);        &#125;    &#125;     //动态规划表的输出    for (int i = 0; i &lt; 5; i++) &#123;        for (int j = 0; j &lt; 9; j++) &#123;            cout &lt;&lt; dp[i][j] &lt;&lt; &#39; &#39;;        &#125;        cout &lt;&lt; endl;    &#125;     return 0;&#125;</code></pre><p>通过上面的方法可以求出背包问题的最优解，但还不知道这个最优解由哪些商品组成，故要根据最优解回溯找出解的组成，根据填表的原理可以有如下的寻解方式：</p><p>V(i,j)&#x3D;V(i-1,j)时，说明没有选择第i 个商品，则回到V(i-1,j)；<br>V(i,j)&#x3D;V(i-1,j-w(i))+v(i)时，说明装了第i个商品，该商品是最优解组成的一部分，随后我们得回到装该商品之前，即回到V(i-1,j-w(i))；<br>一直遍历到i＝0结束为止，所有解的组成都会找到。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hive的配置</title>
      <link href="/2022/03/10/hive%E4%B8%93%E9%A2%98/"/>
      <url>/2022/03/10/hive%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="认识hive的基本配置"><a href="#认识hive的基本配置" class="headerlink" title="认识hive的基本配置"></a>认识hive的基本配置</h1><h5 id="Metastore"><a href="#Metastore" class="headerlink" title="Metastore"></a>Metastore</h5><ol><li><p>Metastores是元数据服务，元数据的服务组件，这个组件存储着hive的元数据。<br>作用：管理metadata元数据，让客户端通过连接Metastore服务，再由metastore去<br>连接MySQL数据库存取元数据。可以间接保证数据的安全。</p></li><li><p>有了metastore服务，就可以有多个客户端同时连接，而且这些客户端不需要知道<br>MySQL数据库的用户名和密码，只需要连接metastore 服务即可。</p></li></ol><h5 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h5><p>关于数据的数据或者叫做用来描述数据的数据或者叫做信息的信息。可以理解为最小的数据单元。<br>元数据可以为数据说明其元素或属性（名称、大小、数据类型、等），或其结构（长度、字段、数据列）</p><h3 id="Metastore启动方式"><a href="#Metastore启动方式" class="headerlink" title="Metastore启动方式"></a>Metastore启动方式</h3><p>Metastore的启动方式有三种：</p><p><strong>（1）嵌入模式</strong></p><p>内嵌模式使用的是内嵌的Derby数据库来存储元数据，也不需要额外起Metastore服务。<br>数据库和Metastore服务都嵌入在主Hive Server进程中。这个是默认的，配置简单，<br>但是一次只能一个客户端连接，适用于用来实验，不适用于生产环境。</p><p>解压hive安装包 bin&#x2F;hive 启动即可使用</p><p>缺点：不同路径启动hive，每一个hive拥有一套自己的元数据，无法共享。</p><p><strong>（2）本地模式</strong></p><p>本地模式采用外部数据库来存储元数据，目前支持的数据库有：<br>MySQL、Postgres、Oracle、MS SQL Server.在这里我们使用MySQL。</p><p>本地模式不需要单独起metastore服务，用的是跟hive在同一个进程里的metastore服务。<br>也就是说当你启动一个hive 服务，里面默认会帮我们启动一个metastore线程服务。<br>hive根据hive.metastore.uris，如果为空，则为本地模式。</p><p>缺点是：每启动一次hive服务，都内置启动了一个metastore。</p><p><strong>（3）远程模式</strong></p><p>远程模式下，需要单独起metastore服务（hive –service metastore），然后每个客户端</p><p>都在配置文件里配置连接到该metastore服务。</p><p>远程模式的metastore服务和hive运行在不同的进程里。</p><p>在生产环境中，建议用远程模式来配置Hive Metastore。</p><p>在这种情况下，其他依赖hive的软件都可以通过** Metastore访问hive。**</p><p>远程模式下，需要配置hive.metastore.uris 参数来指定metastore服务运行的机器ip和端口，<br>并且需要单独手动启动metastore服务，如有多个metastore服务器，URI之间用逗号分隔。</p><h2 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h2><p>本次安装的hive版本为3.0x 基于Hadoop3.0x进行远程模式的搭建</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p><strong>基本的hadoop集群环境要确保能够正常启动</strong></p><h4 id="1-防火墙管理"><a href="#1-防火墙管理" class="headerlink" title="1.防火墙管理"></a>1.防火墙管理</h4><p><strong>(1)防火墙状态查询</strong>：systemctl status firewalld.service<br><strong>(2)防火墙关闭</strong>：systemctl stop firewalld.service<br><strong>(3)禁止防火墙开机启动</strong>：systemctl disable firewalld.service</p><h4 id="2-mysql安装配置成功"><a href="#2-mysql安装配置成功" class="headerlink" title="2.mysql安装配置成功"></a>2.mysql安装配置成功</h4><p>Mysql安装配置成功并能使用 mysql -uroot -p 进行登入</p><h4 id="3-JAVA-JDK配置"><a href="#3-JAVA-JDK配置" class="headerlink" title="3.JAVA JDK配置"></a>3.JAVA JDK配置</h4><p>JDK安装配置成功，并能查看java 版本信息</p><h4 id="4-Hadoop与hive整合"><a href="#4-Hadoop与hive整合" class="headerlink" title="4.Hadoop与hive整合"></a>4.Hadoop与hive整合</h4><p>因为Hive需要把数据存储在HDFS上，并且通过MapReduce作为执行引擎处理数据；<br>修改Hadoop中core-site.xml，并且Hadoop集群同步配置文件，重启生效。</p><pre><code>&lt;!-- 整合hive --&gt;  &lt;property&gt;    &lt;name&gt;hadoop.proxyuser.root.hosts&lt;/name&gt;    &lt;value&gt;*&lt;/value&gt;  &lt;/property&gt;  &lt;property&gt;    &lt;name&gt;hadoop.proxyuser.root.groups&lt;/name&gt;    &lt;value&gt;*&lt;/value&gt;  &lt;/property&gt;</code></pre><h4 id="5-hive的jar包准备"><a href="#5-hive的jar包准备" class="headerlink" title="5.hive的jar包准备"></a>5.hive的jar包准备</h4><p>地址：<a href="http://archive.apache.org/dist/hive/hive-3.1.0/">http://archive.apache.org/dist/hive/hive-3.1.0/</a><br>选择apache-hive-3.1.0-bin.tar.gz 进行下载</p><h2 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h2><h5 id="上传解压安装包"><a href="#上传解压安装包" class="headerlink" title="上传解压安装包"></a>上传解压安装包</h5><ol><li>解压hive安装包<pre><code>tar -zxvf apache-hive-3.1.0-bin.tar.gz  -C mv apache-hive-3.1.0-bin hive</code></pre></li><li>解决hadoop、hive之间guava版本差异</li></ol><p>进入hive目录 将guava-27.0-jre.jar 拷贝至lib目录下</p><pre><code>rm -rf lib/guava-19.0.jarcp /export/server/hadoop-3.1.3/share/hadoop/common/lib/guava-27.0-jre.jar ./lib/</code></pre><ol start="3"><li>添加mysql jdbc驱动到hive安装包lib&#x2F;文件下<br>下载地址：<a href="https://maven.ityuan.com/maven2/mysql/mysql-connector-java/5.1.32">https://maven.ityuan.com/maven2/mysql/mysql-connector-java/5.1.32</a></li></ol><h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><p>可参照自己的文件存放的位置进行修改<br>cd &#x2F;export&#x2F;server&#x2F;hive&#x2F;conf&#x2F;<br>mv hive-env.sh.template hive-env.sh<br>vim hive-env.sh<br>export HADOOP_HOME&#x3D;&#x2F;export&#x2F;server&#x2F;hadoop-3.1.0<br>export HIVE_CONF_DIR&#x3D;&#x2F;export&#x2F;server&#x2F;hive&#x2F;conf<br>export HIVE_AUX_JARS_PATH&#x3D;&#x2F;export&#x2F;server&#x2F;hive&#x2F;lib</p><p>修改conf路径下的hive-site.xml</p><p>vim hive-site.xml (配置路径与mysql)</p><pre><code>&lt;configuration&gt;    &lt;!-- 存储元数据mysql相关配置 --&gt;    &lt;property&gt;        &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;        &lt;value&gt; jdbc:mysql://hadoop102:3306/hive?createDatabaseIfNotExist=true&amp;amp;useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;        &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;        &lt;value&gt;root&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;        &lt;value&gt;hadoop&lt;/value&gt;    &lt;/property&gt;    &lt;!-- H2S运行绑定host --&gt;    &lt;property&gt;        &lt;name&gt;hive.server2.thrift.bind.host&lt;/name&gt;        &lt;value&gt;hadoop102&lt;/value&gt;    &lt;/property&gt;    &lt;!-- 远程模式部署metastore 服务地址 --&gt;    &lt;property&gt;        &lt;name&gt;hive.metastore.uris&lt;/name&gt;        &lt;value&gt;thrift://hadoop102:9083&lt;/value&gt;    &lt;/property&gt;    &lt;!-- 关闭元数据存储授权  --&gt;    &lt;property&gt;        &lt;name&gt;hive.metastore.event.db.notification.api.auth&lt;/name&gt;        &lt;value&gt;false&lt;/value&gt;    &lt;/property&gt;    &lt;!-- 关闭元数据存储版本的验证 --&gt;    &lt;property&gt;        &lt;name&gt;hive.metastore.schema.verification&lt;/name&gt;        &lt;value&gt;false&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><h3 id="初始化metadata"><a href="#初始化metadata" class="headerlink" title="初始化metadata"></a>初始化metadata</h3><p>cd &#x2F;export&#x2F;server&#x2F;hive<br>bin&#x2F;schematool -initSchema -dbType mysql -verbos<br>初始化成功会在mysql中创建74张表</p><h2 id="hiveserver2"><a href="#hiveserver2" class="headerlink" title="hiveserver2"></a>hiveserver2</h2><p>Hive发展至今，总共历经了两代客户端工具。</p><ol><li><p>第一代客户端（deprecated不推荐使用）：$HIVE_HOME&#x2F;bin&#x2F;hive, 是一个 shellUtil。<br>主要功能：一是可用于以交互或批处理模式运行Hive查询；二是用于Hive相关服务的启动，比如metastore服务。</p></li><li><p>第二代客户端（recommended 推荐使用）：$HIVE_HOME&#x2F;bin&#x2F;beeline，是一个JDBC客户端，<br>是官方强烈推荐使用的Hive命令行工具，和第一代客户端相比，性能加强安全性提高。</p></li></ol><p>Q:为什么我们要使用hiveserver2？</p><p>HiveServer2支持多客户端的并发和身份认证，旨在为开放API客户端如JDBC、ODBC提供更好的支持。</p><p>HiveServer2通过Metastore服务读写元数据。所以在远程模式下，启动HiveServer2之前<strong>必须先首先启动metastore服务</strong></p><h3 id="配置bin-x2F-hive-客户端（可选）"><a href="#配置bin-x2F-hive-客户端（可选）" class="headerlink" title="配置bin&#x2F;hive 客户端（可选）"></a>配置bin&#x2F;hive 客户端（可选）</h3><p>上传hive安装包到另一个机器上，比如node3<br>cd &#x2F;export&#x2F;server&#x2F;tar zxvf apache-hive-3.1.0-bin.tar.gzmv apache-hive-3.1.0-bin hive#</p><pre><code># 解决hadoop、hive之间guava版本差异cd /export/server/hive/rm -rf lib/guava-19.0.jarcp /export/server/hadoop-3.1.3/share/hadoop/common/lib/guava-27.0-jre.jar ./lib/# 修改hive环境变量文件 添加Hadoop_HOMEcd /export/server/hive/confmv hive-env.sh.template hive-env.shvim hive-env.shexport HADOOP_HOME=/export/server/hadoop-3.1.4# 添加metastore服务地址cd /export/server/hive/conf/vim  hive-site.xml&lt;configuration&gt;&lt;property&gt;    &lt;name&gt;hive.metastore.uris&lt;/name&gt;    &lt;value&gt;thrift://hadoop102:9083&lt;/value&gt; &lt;/property&gt;  &lt;/configuration&gt;</code></pre><p>hive经过发展，推出了第二代客户端beeline，但是beeline客户端不是直接访问metastore服务的，而是需要单独启动hiveserver2服务。<br>在hive安装的服务器上，首先启动metastore服务，然后启动hiveserver2服务。</p><h2 id="hive的使用"><a href="#hive的使用" class="headerlink" title="hive的使用"></a>hive的使用</h2><p>后台挂起 可使用jps命令查看是否开启 正常的话就是runjar<br>注意hivesever2开启后要等一段时间才可以使用 </p><pre><code>nohup /export/servers/hive/bin/hive --service metastore &amp;nohup /export/servers/hive/bin/hive --service hiveserver2 &amp;</code></pre><p>cd 到hive的bin目录下</p><pre><code>! connect jdbc:hive2://hadoop:10000Enter username for jdbc:hive2://hadoop102:10000: rootEnter password for jdbc:hive2://node1:10000: Connected to: Apache Hive (version 3.1.0)</code></pre><p>创建一个数据库<br>如果可以创建则表明成功，后续自行使用idea连接hive即可</p><h3 id="一些BUG解决方案"><a href="#一些BUG解决方案" class="headerlink" title="一些BUG解决方案"></a>一些BUG解决方案</h3><ol><li>User: root is not allowed to impersonate root(state&#x3D;08S01,code&#x3D;0)<pre><code>&lt;property&gt; &lt;name&gt;hadoop.proxyuser.root.hosts&lt;/name&gt; &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hadoop.proxyuser.root.groups&lt;/name&gt; &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;</code></pre></li></ol><p>在hive的conf下修改配置文件hive-site.xml</p><pre><code>&lt;property&gt;&lt;name&gt;hive.server2.enable.doAs&lt;/name&gt;&lt;value&gt;false&lt;/value&gt;&lt;/property&gt;端口号&lt;property&gt;&lt;name&gt;hive.server2.thrift.port&lt;/name&gt;&lt;value&gt;10000&lt;/value&gt;&lt;/property&gt;</code></pre><p>hdfs dfs -chmod -R 777 &#x2F;tmp</p><ol start="2"><li>Permission denied: user&#x3D;root, access&#x3D;WRITE, inode&#x3D;”&#x2F;user”:hdfs:supergroup:drwxr-xr-x</li></ol><p>众所周知，HDFS文件系统的目录基本都属于supergroup用户组，<br>所以我们就把就把用户添加到该用户组，即可解决很多权限问题，<br>例如连接Hive却无法操作的创建库、表的问题…</p><p><strong>解决hive中root权限不能写的问题</strong></p><p>1、在Linux执行如下命令增加supergroup<br>sudo groupadd supergroup</p><p>2、将用户增加到supergroup中<br>sudo usermod -a -G supergroup root</p><p>3、同步系统的权限信息到HDFS文件系统<br>hdfs dfsadmin -refreshUserToGroupsMappings</p><p>4、查看属于supergroup用户组的用户<br>grep ‘supergroup:’ &#x2F;etc&#x2F;group</p><p>重新连接 发现问题解决！</p>]]></content>
      
      
      <categories>
          
          <category> 大数据生态圈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HIVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的基本运用</title>
      <link href="/2022/03/10/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%94%A8/"/>
      <url>/2022/03/10/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="认识单链表"><a href="#认识单链表" class="headerlink" title="认识单链表"></a>认识单链表</h1><p>单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。<br>链表中的数据是以节点来表示的，每个节点的构成：data域（数据元素）+next域（下一个结点的存储位置）。<br>单链表与数组相比的最大差别是：单链表的数据元素存放在内存空间的地址是不连续的，<br>而数组的数据元素存放的地址在内存空间中是连续的，<br>这也是为什么根据索引无法像数组那样直接就能查询到数据元素。</p><h2 id="基本操作如下"><a href="#基本操作如下" class="headerlink" title="基本操作如下"></a>基本操作如下</h2><pre><code>public class LinkList &#123;    private static final LinkNode NULL = null;private LinkNode Head = new LinkNode();//先初始化一个头结点，头结点为空    LinkList() &#123;        Init_LinkNode();&#125;//内部类节点LinkNode    class LinkNode &#123;        int data;        LinkNode next=null;        LinkNode()&#123;        &#125;        LinkNode(int elem)&#123;            data=elem;        &#125;        LinkNode(int elem,LinkNode nextval)&#123;            data=elem;            next=nextval;        &#125;        LinkNode(LinkNode nextval)&#123;            next=nextval;        &#125;    &#125;        //1.单链表的初始化    public void Init_LinkNode() &#123;        LinkNode head = null;    &#125;//2.    判断表是否为空 public boolean isEmpty() &#123;//通过判断头结点的下一结点地址是否为空，即可判断单链表是否为空        if(this.Head.next == null) &#123;           return true;         &#125;        return false;    &#125;    //3.返回单链表的长度    public int Length_LinkList() &#123;        int j=0;        LinkNode tmp=Head; //head节点不能动，需要一个tmp辅助遍历        while(tmp != null) &#123;            j++;            tmp=tmp.next;        &#125;        return j;    &#125;        //4.返回第i个元素        public LinkNode Get_LinkList(int i) &#123;            LinkNode p = Head;            int a = 0;            while (p.next != null &amp;&amp; a &lt; i) &#123;                p = p.next;                a++;            &#125;            if (a == i) &#123;                return p;            &#125; else &#123;                return null;            &#125;        &#125;       //5.删除第i个元素        public int Delete_LinkList(int i) &#123;                LinkNode p;                LinkNode s;            p=Get_LinkList(i-1);            if(p==null)&#123;                System.out.println(&quot;第i-1个结点不存在&quot;);                return -1;            &#125;else if (p.next==null)&#123;                System.out.println(&quot;第i个结点不存在&quot;);                return 0;            &#125;else&#123;                s=p.next;                p.next=s.next;                return 1;            &#125;        &#125; //6.在第i个位置插入元素        public int  Insert_LinkList(int i,int x) &#123;        LinkNode p,s;        p=Get_LinkList(i-1);            if(p==null)&#123;                System.out.println(&quot;参数i错误&quot;);                return 0;            &#125;else &#123;                s=new LinkNode();                s.data=x;                s.next=p.next;                p.next=s;                return 1;            &#125;&#125;        //7.把表中的元素打印出来            public void display()&#123;                LinkNode tmp=Head;                while (tmp!=null) &#123;                    System.out.println(tmp.data+&quot;  &quot;);                    tmp=tmp.next;                &#125;                System.out.println();            &#125;&#125;</code></pre><h1 id="顺序表与单链表的比较"><a href="#顺序表与单链表的比较" class="headerlink" title="顺序表与单链表的比较"></a>顺序表与单链表的比较</h1><h2 id="顺序表的优点："><a href="#顺序表的优点：" class="headerlink" title="顺序表的优点："></a>顺序表的优点：</h2><p>其存储结构为随机存取结构，逻辑关系可直接用数组元素下标表示。</p><h2 id="顺序表的缺点："><a href="#顺序表的缺点：" class="headerlink" title="顺序表的缺点："></a>顺序表的缺点：</h2><p>①线性表的长度不确定，难以事先确定数组长度。<br>②存储空间必须是连续的，易造成存储空间的“碎片”现象。③插入和删除操作需要移动大量元素。</p><h2 id="单链表的优点："><a href="#单链表的优点：" class="headerlink" title="单链表的优点："></a>单链表的优点：</h2><p>①元素的存储单元是任意的，可连续也可不连续。②不需要限定长度。</p><h2 id="单链表的缺点"><a href="#单链表的缺点" class="headerlink" title="单链表的缺点"></a>单链表的缺点</h2><p>：①其查找时间复杂度为O(n)。②存放元素时需要另外开辟一个指针域的空间。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识数组</title>
      <link href="/2022/03/09/%E8%AE%A4%E8%AF%86%E6%95%B0%E7%BB%84/"/>
      <url>/2022/03/09/%E8%AE%A4%E8%AF%86%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h3 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h3><p>其实所谓的数组指的就是一组相关类型的变量集合，并且这些变量可以按照统一的方式进行操作。数组本身属于引用数据类型，那么既然是引用数据类型，<br>这里面实际又会牵扯到内存分配，而数组的定义语法有如下两类。</p><p>数组动态初始化：<br>声明并开辟数组：<br>数据类型 [] 数组名称 &#x3D; new 数据类型[长度];<br>数据类型 [] 数组名称 &#x3D; new 数据类型[长度];<br>分布进行数组空间开辟（实例化）<br>| Tables | Are |<br>| ————- |:————-?<br>| 声明数组： | 数组类型 数组名称[] &#x3D; null; | | | 数组类型 [] 数组名称 &#x3D;null; | | 开辟数组空间： | 数组名称 &#x3D;new&#96; 数组类型[长度]; |<br>那么当数组开辟空间之后，就可以采用如下的方式的操作：</p><p>数组的访问通过索引完成，即：“数组名称[索引]”，但是需要注意的是，数组的索引从0开始，<br>所以索引的范围就是0 ~ 数组长度-1，例如开辟了3个空间的数组，<br>所以可以使用的索引是：0,1,2，如果此时访问的时候超过了数组的索引范围，<br>会产生java.lang.ArrayIndexOutOfBoundsException 异常信息；<br>当我们数组采用动态初始化开辟空间后，数组里面的每一个元素都是该数组对应数据类型的默认值；<br>数组本身是一个有序的集合操作，所以对于数组的内容操作往往会采用循环的模式完成，数组是一个有限的数据集合，所以应该使用 for 循环。<br>在 Java 中提供有一种动态取得数组长度的方式：数组名称.length；</p><h2 id="1-1认识数组"><a href="#1-1认识数组" class="headerlink" title="1.1认识数组"></a>1.1认识数组</h2><p>数组Array，标志是[ ] ,用于储存多个相同类型数据的集合<br>想要获取数组中的元素值，可以通过脚标（下标）来获取<br>数组下标是从0开始的,下标的最大值是数组的长度减1</p><h2 id="1-2-创建数组"><a href="#1-2-创建数组" class="headerlink" title="1.2 创建数组"></a>1.2 创建数组</h2><p>数组的创建方式一般分为动态初始化和静态初始化</p><p>动态初始化<br>int[] a &#x3D; new int[5];<br>静态初始化<br>int[] b &#x3D; new int[]{1,2,3,4,5};<br>int[] c &#x3D; {1,2,3,4,5};</p><h2 id="1-3-创建数组过程分析"><a href="#1-3-创建数组过程分析" class="headerlink" title="1.3 创建数组过程分析"></a>1.3 创建数组过程分析</h2><p>程序创建数组 int[] a &#x3D; new int[5]; 时发生了什么?</p><p>1.在内存中开辟连续的空间,用来存放数据,长度是5<br>2.给数组完成初始化过程,给每个元素赋予默认值,int类型默认值是0<br>3.数组完成初始化会分配一个唯一的地址值<br>4.把唯一的地址值交给引用类型的变量a去保存</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
